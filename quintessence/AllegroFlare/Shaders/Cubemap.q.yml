parent_classes:


  - class: AllegroFlare::Shaders::Base
    scope: public
    init_with: "AllegroFlare::Shaders::Cubemap::TYPE, obtain_vertex_source(), obtain_fragment_source()"


properties:


  - name: cube_map
    type: AllegroFlare::Cubemap*
    init_with: nullptr
    constructor_arg: true
    getter: true
    setter: explicit

  - name: camera_position
    type: AllegroFlare::Vec3D
    init_with: AllegroFlare::Vec3D(0, 0, 0)
    getter: true
    setter: explicit

  - name: camera_viewing_direction
    type: AllegroFlare::Vec3D
    init_with: AllegroFlare::Vec3D(0, 0, 0)
    getter: true
    setter: explicit

  - name: object_placement_transform
    type: ALLEGRO_TRANSFORM
    init_with: '{}'

  - name: reflecting
    type: bool
    init_with: DEFAULT_REFLECTING
    constructor_arg: true
    getter: true
    setter: explicit

  - name: CUBEMAP_SHADER_UNIFORM_TEXTURE_INDEX
    type: int
# // ?? why 5? dunno
    init_with: 5
    static: true
    constexpr: true

  - name: DEFAULT_REFLECTING
    type: bool
    init_with: false
    static: true
    constexpr: true

  - name: CUBE_MAP_A_UNIFORM_IDENTIFIER
    type: char*
    init_with: '(char*)"cube_map_A"'
    static: true
    constexpr: true

  - name: CAMERA_POSITION_UNIFORM_IDENTIFIER
    type: char*
    init_with: '(char*)"camera_position"'
    static: true
    constexpr: true

  - name: CAMERA_VIEWING_DIRECTION_UNIFORM_IDENTIFIER
    type: char*
    init_with: '(char*)"camera_viewing_direction"'
    static: true
    constexpr: true

  - name: POSITION_TRANSFORM_UNIFORM_IDENTIFIER
    type: char*
    init_with: '(char*)"position_transform"'
    static: true
    constexpr: true

  - name: REFLECTING_UNIFORM_IDENTIFIER
    type: char*
    init_with: '(char*)"reflecting"'
    static: true
    constexpr: true

  - name: TYPE
    type: char*
    init_with: '(char*)"AllegroFlare/Shaders/Cubemap"'
    static: true
    constexpr: true


documentation:


  - definitions:
      - name: reflecting
        body: |
          When set to true, the material being rendered will act as a solid, reflecting the world around it.  When set
          to false, the material will be rendered as if it were a skybox.
  - todos:
      - Have "reflecting" be false by default
      - Rename "cube_map" to "cubemap"


functions:


  - name: activate
    type: void
    virtual: true
    override: true
    body: |
      AllegroFlare::Shaders::Base::activate();
      set_values_to_activated_shader();
      return;


  - name: set_cube_map
    parameters:
      - name: cube_map
        type: AllegroFlare::Cubemap*
        default_argument: nullptr
    guards: [ cube_map ]
    body: |
      // TODO: Test this
      this->cube_map = cube_map;
      if (is_active()) set_sampler_cube(CUBE_MAP_A_UNIFORM_IDENTIFIER, cube_map, CUBEMAP_SHADER_UNIFORM_TEXTURE_INDEX);
      return;


  - name: set_camera_position
    parameters:
      - name: camera_position
        type: AllegroFlare::Vec3D
        default_argument: '{}'
    body: |
      // TODO: Test this
      this->camera_position = camera_position;
      if (is_active()) set_vec3(CAMERA_POSITION_UNIFORM_IDENTIFIER, camera_position);
      return;


  - name: set_camera_viewing_direction
    parameters:
      - name: camera_viewing_direction
        type: AllegroFlare::Vec3D
        default_argument: '{}'
    body: |
      // TODO: Test this
      this->camera_viewing_direction = camera_viewing_direction;
      if (is_active()) set_vec3(CAMERA_VIEWING_DIRECTION_UNIFORM_IDENTIFIER, camera_viewing_direction);
      return;


  - name: set_reflecting
    parameters:
      - name: reflecting
        type: bool
        default_argument: false
    body: |
      // TODO: Test this
      this->reflecting = reflecting;
      if (is_active()) set_bool("reflecting", reflecting);
      return;


  - name: set_object_placement
    parameters:
      - name: object_placement
        type: AllegroFlare::Placement3D*
        default_argument: nullptr
    guards: [ object_placement ]
    body: |
      object_placement->build_transform(&object_placement_transform);
      if (is_active()) set_mat4(POSITION_TRANSFORM_UNIFORM_IDENTIFIER, &object_placement_transform); // TODO: Test this

      // TODO: if this shader is active, send the value to the shader directly
      return;


  - name: set_values_to_activated_shader
    private: true
    body: |
      set_sampler_cube(CUBE_MAP_A_UNIFORM_IDENTIFIER, cube_map, CUBEMAP_SHADER_UNIFORM_TEXTURE_INDEX);
      set_vec3(CAMERA_POSITION_UNIFORM_IDENTIFIER, camera_position);
      set_vec3(CAMERA_VIEWING_DIRECTION_UNIFORM_IDENTIFIER, camera_viewing_direction);
      set_mat4(POSITION_TRANSFORM_UNIFORM_IDENTIFIER, &object_placement_transform);
      set_bool(REFLECTING_UNIFORM_IDENTIFIER, reflecting);
      // TODO: set_float("tint_intensity", tint_intensity);
      return;
    body_dependency_symbols:
      - AllegroFlare::Placement3D
      - std::cout


  - name: obtain_vertex_source
    type: std::string
    static: true
    private: true
    body: |
      // HERE: Finishing this code
      // NOTE: this code was formerly in data/shaders/cube_vertex.glsl
      static const std::string source = R"DELIM(
         attribute vec4 al_pos;
         attribute vec3 al_user_attr_0; // Not sure if this is needed?

         uniform mat4 al_projview_matrix;
         uniform mat4 position_transform;
         uniform vec3 camera_position;

         varying vec3 normal;
         varying vec3 eye_dir;
         uniform samplerCube cube_map_A;
         uniform samplerCube cube_map_B;
         uniform bool reflecting;
         uniform vec3 camera_viewing_direction;

         void main()
         {
            //if (!reflecting)
            //{
               //gl_Position = al_projview_matrix * al_pos;
            //}
            //else
            //{
               gl_Position = al_projview_matrix * position_transform * al_pos;
            //}

            normal = (position_transform * vec4(al_user_attr_0, 0.0)).xyz;
            // this NORMAL val will probably ned to be multiplied by the position transform
             //	normal = (al_user_attr_0).xyz;
            vec3 world_position = (position_transform * al_pos).xyz;
            eye_dir = vec3(camera_position - world_position);

            //if (!reflecting) eye_dir = camera_viewing_direction;
         }
      )DELIM";
      return source;


  - name: obtain_fragment_source
    type: std::string
    static: true
    private: true
    body: |
      // HERE: Finishing this code
      // NOTE: this code was formerly in data/shaders/cube_fragment.glsl
      static const std::string source = R"DELIM(
         varying vec3 normal;
         varying vec3 eye_dir;
         uniform samplerCube cube_map_A;
         uniform samplerCube cube_map_B;
         //uniform sampler2D al_tex;
         uniform bool reflecting;

         void main()
         {
            vec3 reflected_dir = normalize(reflect(eye_dir, normalize(normal)));
 
            vec3 incoming_angle = reflecting ? reflected_dir : eye_dir;
            //vec3 incoming_angle = eye_dir;
 
            incoming_angle.y = -incoming_angle.y;
            incoming_angle.x = -incoming_angle.x;
            //incoming_angle.z = -incoming_angle.z; // NOTE: Should this be uncommented?
 
            vec4 color = textureCube(cube_map_A, incoming_angle);
            //color = textureCube(cube_map_B, incoming_angle);
          

            // TODO: add this "golden_color" as an optional pass-in-able value
            //vec4 golden_color = vec4(1.0, 0.74, 0.0, 1.0);

            //color = golden_color * 0.6 + color * 0.7;
          
          
            gl_FragColor = color;
         }
      )DELIM";
      return source;


dependencies:


  - symbol: AllegroFlare::Shaders::Base
    headers: [ AllegroFlare/Shaders/Base.hpp ]
  - symbol: AllegroFlare::Cubemap
    headers: [ AllegroFlare/Cubemap.hpp ]
  - symbol: AllegroFlare::Vec3D
    headers: [ AllegroFlare/Vec3D.hpp ]
  - symbol: AllegroFlare::Placement3D
    headers: [ AllegroFlare/Placement3D.hpp ]
  - symbol: ALLEGRO_TRANSFORM
    headers: [ allegro5/allegro.h ]


