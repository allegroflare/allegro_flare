properties:


  - name: pitches
    type: std::vector<AllegroFlare::MusicNotation::Parser::PitchToken>
    init_with: '{}'
    constructor_arg: true
    getter: true
    setter: false

  - name: stack
    type: std::vector<std::pair<AllegroFlare::MusicNotation::AccidentalStacker::AccidentalType, std::pair<int, int>>>
    init_with: '{}'
    constructor_arg: true
    getter: explicit
    setter: true

  - name: solved
    type: bool
    init_with: false
    constructor_arg: true
    getter: true
    setter: true


enums:


  - name: AccidentalType
    scope: public
    enumerators:
      - UNDEFINED
      - SHARP
      - FLAT
      - NATURAL


methods:


  - name: set_pitches
    parameters:
      - name: pitches
        type: const std::vector<AllegroFlare::MusicNotation::Parser::PitchToken>&
        default_argument: '{}'
    body: |
      this->pitches = pitches;
      solved = false;
      return;


  - name: get_stack
    type: std::vector<std::pair<AllegroFlare::MusicNotation::AccidentalStacker::AccidentalType, std::pair<int, int>>>
    guards: [ solved ]
    body: |
      return stack;


  - name: solve_one_from_top
    guards: [ (!pitches.empty()) ]
    parameters:
      - name: column_to_place_on
        type: int
        default_argument: 0
    body: |
         auto &pitch = pitches[0];

         if (!pitch.has_accidental())
         {
            // TODO: Replace with AllegroFlare::Logger error
            throw std::runtime_error("AccidentalStacker::solve_one_from_top: error: "
                  "Cannot solve. First pitch does not have an accidental.");
         }
          
         // Place the accidental at the current column
         int pitch_staff_position = pitch.get_staff_position();
         int pitch_staff_position_normalized = pitch_staff_position % 7;
         int pitch_accidental_weight = pitch.calculate_accidental_weight();
         AccidentalType accidental_type = find_accidental_type_by_weight(pitch_accidental_weight);

         // Put it in the stack
         stack.push_back({ accidental_type, { column_to_place_on, pitch_staff_position } });

         // Erase the list of pitches
         pitches.erase(pitches.begin() + 0);
         if (pitches.empty()) return;

         // Go through the list of pitches and look for any octaves to the current note, placing their accidentals
         // in the same column
         for (int j=0; j<pitches.size(); j++)
         {
            auto &possible_octave_to_pitch = pitches[j];
            int possible_octave_pitch_staff_position = possible_octave_to_pitch.get_staff_position();
            int possible_octave_pitch_staff_position_normalized = possible_octave_pitch_staff_position % 7;
            int possible_octave_pitch_accidental_weight = possible_octave_to_pitch.calculate_accidental_weight();
            bool is_an_octave_apart =
                  (possible_octave_pitch_staff_position_normalized == pitch_staff_position_normalized)
                  && (possible_octave_pitch_accidental_weight == pitch_accidental_weight);

            // This pitch is an octave apart, place it in the same column
            if (is_an_octave_apart)
            {
               AccidentalType accidental_type = find_accidental_type_by_weight(possible_octave_pitch_accidental_weight);
               stack.push_back({ accidental_type, { column_to_place_on, possible_octave_pitch_staff_position } });

               pitches.erase(pitches.begin() + j);
               //i--;
               j--;
            }
         }
    body: |
      return;


  - name: solve_one_from_bottom
    guards: [ (!pitches.empty()) ]
    parameters:
      - name: column_to_place_on
        type: int
        default_argument: 0
    body: |
         auto &pitch = pitches.back();

         if (!pitch.has_accidental())
         {
            // TODO: Replace with AllegroFlare::Logger error
            throw std::runtime_error("AccidentalStacker::solve_one_from_top: error: "
                  "Cannot solve. First pitch does not have an accidental.");
         }
          
         // Place the accidental at the current column
         int pitch_staff_position = pitch.get_staff_position();
         int pitch_staff_position_normalized = pitch_staff_position % 7;
         int pitch_accidental_weight = pitch.calculate_accidental_weight();
         AccidentalType accidental_type = find_accidental_type_by_weight(pitch_accidental_weight);

         // Put it in the stack
         stack.push_back({ accidental_type, { column_to_place_on, pitch_staff_position } });

         // Erase the list of pitches
         pitches.pop_back();
         if (pitches.empty()) return;

         // Go through the list of pitches and look for any octaves to the current note, placing their accidentals
         // in the same column
         for (int j=0; j<pitches.size(); j++)
         {
            auto &possible_octave_to_pitch = pitches[j];
            int possible_octave_pitch_staff_position = possible_octave_to_pitch.get_staff_position();
            int possible_octave_pitch_staff_position_normalized = possible_octave_pitch_staff_position % 7;
            int possible_octave_pitch_accidental_weight = possible_octave_to_pitch.calculate_accidental_weight();
            bool is_an_octave_apart =
                  (possible_octave_pitch_staff_position_normalized == pitch_staff_position_normalized)
                  && (possible_octave_pitch_accidental_weight == pitch_accidental_weight);

            // This pitch is an octave apart, place it in the same column
            if (is_an_octave_apart)
            {
               AccidentalType accidental_type = find_accidental_type_by_weight(possible_octave_pitch_accidental_weight);
               stack.push_back({ accidental_type, { column_to_place_on, possible_octave_pitch_staff_position } });

               pitches.erase(pitches.begin() + j);
               //i--;
               j--;
            }
         }
    body: |
      return;


  - name: solve
    body: |
      stack.clear();

      // TODO: Confirm pitches are sorted and unique, and are reversed (higher numbers at the top)

      bool top_bottom_toggle = true;
      int current_column = 0;
      //int last_ = 0;
      for (int i=0; i<pitches.size(); i++)
      {
         auto &pitch = pitches[i];

         // If pitch is not an accidental, remove it and continue
         if (!pitch.has_accidental())
         {
            pitches.erase(pitches.begin() + i);
            i--;
            continue;
         }

         solve_one_from_top();

         current_column--;

         if (!pitches.empty()) solve_one_from_bottom();

         current_column--;
      }

      solved = true;
      return;


  - name: find_accidental_type_by_weight
    type: AllegroFlare::MusicNotation::AccidentalStacker::AccidentalType
    static: true
    parameters:
      - name: accidental_weight
        type: int
        default_argument: 0
    body: |
      // TODO: Improve this calculation to permit for double sharps, double flats, etc
      if (accidental_weight == 0) return AccidentalType::NATURAL;
      else if (accidental_weight < 0) return AccidentalType::FLAT;
      else if (accidental_weight > 0) return AccidentalType::SHARP;
      return AccidentalType::UNDEFINED;


dependencies:


  - symbol: AllegroFlare::MusicNotation::AccidentalStacker::AccidentalType
    headers: [ ]
  - symbol: AllegroFlare::MusicNotation::Parser::PitchToken
    headers: [ AllegroFlare/MusicNotation/Parser/PitchToken.hpp ]


