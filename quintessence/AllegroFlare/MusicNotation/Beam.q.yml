properties:


  - name: staff_line_distance
    type: float
    init_with: 0
    constructor_arg: true
    getter: true
    setter: true

  - name: start_x
    type: float
    init_with: 0
    constructor_arg: true
    getter: true
    setter: true
    
  - name: start_staff_pos
    type: float
    init_with: 0
    constructor_arg: true
    getter: true
    setter: true

  - name: start_alignment
    type: Beam::Alignment
    init_with: Beam::Alignment::UNDEFINED
    constructor_arg: true
    getter: true
    setter: true

  - name: end_x
    type: float
    init_with: 0.0f
    constructor_arg: true
    getter: true
    setter: true
    
  - name: end_staff_pos
    type: float
    init_with: 0.0f
    constructor_arg: true
    getter: true
    setter: true
    
  - name: end_alignment
    type: Beam::Alignment
    init_with: Beam::Alignment::UNDEFINED
    constructor_arg: true
    getter: true
    setter: true

  - name: color
    type: ALLEGRO_COLOR
    init_with: ALLEGRO_COLOR{1, 1, 1, 1}
    constructor_arg: true
    getter: true
    setter: true

  - name: secondary_beams
    type: std::vector<std::vector<std::pair<float, float>>>
    init_with: '{}'
    constructor_arg: true
    getter: true
    setter: true


documentation:


  - notes:
      - Decent reference: https://sites.coloradocollege.edu/musicengraving/engraving-convention/beams-and-flags/#:~:text=Thickness%20of%20beams%20depends%20on,the%20space%20between%20staff%20lines.&text=When%20to%20UseIn%20General%3A,ends%20on%20the%20same%20note.
      - Another good reference: https://www.oscarvandillen.com/outline_of_basic_music_theory/musical_notation/


enums:


  - name: Alignment
    scope: public
    enumerators:
      - UNDEFINED
      - TOP
      - MIDDLE
      - BOTTOM
      

methods:


  - name: render
    type: void
    guards:
      - al_is_system_installed()
      - al_is_primitives_addon_initialized()
      - staff_line_distance > 0
      - start_alignment != Beam::Alignment::UNDEFINED
      - end_alignment != Beam::Alignment::UNDEFINED
    body: |
      float staff_line_h_distance = staff_line_distance * 0.5;
      float top_x1 = start_x;
      float top_y1 = start_staff_pos * staff_line_h_distance
                   + staff_line_h_distance * alignment_vertical_offset_for(start_alignment);
      float top_x2 = end_x;
      float top_y2 = end_staff_pos * staff_line_h_distance
                   + staff_line_h_distance * alignment_vertical_offset_for(end_alignment);

      render_primary_beam(top_x1, top_y1, top_x2, top_y2);
      render_secondary_beams();
      return;


  - name: render_primary_beam
    type: void
    parameters:
      - name: top_x1
        type: float
        default_argument: 0.0f
      - name: top_y1
        type: float
        default_argument: 0.0f
      - name: top_x2
        type: float
        default_argument: 0.0f
      - name: top_y2
        type: float
        default_argument: 0.0f
    body: |
      float staff_line_h_distance = staff_line_distance * 0.5;
      //float top_x1 = start_x;
      //float top_y1 = start_staff_pos * staff_line_h_distance
                   //+ staff_line_h_distance * alignment_vertical_offset_for(start_alignment);
      //float top_x2 = end_x;
      //float top_y2 = end_staff_pos * staff_line_h_distance
                   //+ staff_line_h_distance * alignment_vertical_offset_for(end_alignment);
      float bottom_x3 = top_x2;
      float bottom_y3 = top_y2 + staff_line_h_distance;
      float bottom_x4 = top_x1;
      float bottom_y4 = top_y1 + staff_line_h_distance;

      ALLEGRO_VERTEX v[6] = {
         ALLEGRO_VERTEX{.x = top_x1, .y = top_y1, .z = 0, .color = color, .u = 0, .v = 0},
         ALLEGRO_VERTEX{.x = top_x2, .y = top_y2, .z = 0, .color = color, .u = 0, .v = 0},
         ALLEGRO_VERTEX{.x = bottom_x3, .y = bottom_y3, .z = 0, .color = color, .u = 0, .v = 0},

         ALLEGRO_VERTEX{.x = bottom_x3, .y = bottom_y3, .z = 0, .color = color, .u = 0, .v = 0},
         ALLEGRO_VERTEX{.x = bottom_x4, .y = bottom_y4, .z = 0, .color = color, .u = 0, .v = 0},
         ALLEGRO_VERTEX{.x = top_x1, .y = top_y1, .z = 0, .color = color, .u = 0, .v = 0},
      };

      al_draw_prim(v, nullptr, nullptr, 0, 6, ALLEGRO_PRIM_TRIANGLE_LIST);

      // Draw a debug guide "through" line
      al_draw_line(
         start_x,
         start_staff_pos * staff_line_h_distance,
         end_x,
         end_staff_pos * staff_line_h_distance,
         ALLEGRO_COLOR{0, 0.5, 1.0, 1.0},
         1.0
      );

      return;
    body_dependency_symbols:
      - AllegroFlare::Vec2D
      - al_draw_rounded_rectangle


  - name: render_secondary_beams
    type: void
    body: |
      // TODO: Include secondary beam rendering here
      return;


  - name: alignment_vertical_offset_for
    type: float
    parameters:
      - name: alignment
        type: Beam::Alignment
        default_argument: Beam::Alignment::UNDEFINED
    guards: [ (alignment != Beam::Alignment::UNDEFINED) ]
    body: |
      if (alignment == Beam::Alignment::TOP) return -1.0;
      else if (alignment == Beam::Alignment::BOTTOM) return 0.0;
      else if (alignment == Beam::Alignment::MIDDLE) return -0.5;
      throw std::runtime_error("alignment_vertical_offset_for cannot handle case for beam alignment type");


dependencies:


  - symbol: ALLEGRO_COLOR
    headers: [ allegro5/allegro.h ]
  - symbol: Beam::Alignment
    headers: [ ]
  - symbol: al_draw_rounded_rectangle
    headers: [ allegro5/allegro_primitives.h ]
  - symbol: AllegroFlare::Vec2D
    headers: [ AllegroFlare/Vec2D.hpp ]


