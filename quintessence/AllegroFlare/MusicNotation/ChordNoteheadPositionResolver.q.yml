properties:


  - name: pitches
    type: std::vector<AllegroFlare::MusicNotation::Parser::PitchToken>
    init_with: '{}'
    constructor_arg: true
    getter: true
    setter: false

  - name: positions
    type: std::vector<std::pair<int, AllegroFlare::MusicNotation::ChordNoteheadPositionResolver::PositionType>>
    init_with: '{}'
    constructor_arg: true
    getter: explicit
    setter: false

  - name: seconds_exist
    type: bool
    init_with: false
    getter: explicit
    setter: false

  - name: solved
    type: bool
    init_with: false
    getter: true


enums:


  - name: PositionType
    scope: public
    enumerators:
      - UNDEFINED
      - LEFT
      - RIGHT
      - STEMSIDE


methods:


  - name: set_pitches
    parameters:
      - name: pitches
        type: const std::vector<AllegroFlare::MusicNotation::Parser::PitchToken>&
        default_argument: '{}'
    body: |
      this->pitches = pitches;
      seconds_exist = false;
      solved = false;
      return;


  - name: get_positions
    type: const std::vector<std::pair<int, AllegroFlare::MusicNotation::ChordNoteheadPositionResolver::PositionType>>&
    guards: [ solved ]
    body: |
      return positions;


  - name: get_seconds_exist
    type: bool
    guards: [ solved ]
    body: |
      return seconds_exist;


  - name: noteheads_exist_on_both_sides
    type: const std::vector<std::pair<int, AllegroFlare::MusicNotation::ChordNoteheadPositionResolver::PositionType>>&
    guards: [ solved ]
    body: |
      return positions;


  - name: solve
    guards: [ (!solved) ]
    body: |
      // TODO: Sort and make unique
      sort_and_make_unique();
      std::reverse(pitches.begin(), pitches.end());

      // TODO: Test context where notes must be sorted and made unique

      // NOTE: Algorithm works generally like this:
      // 2) If there is a 2nd, the higher note is on the right side, regardless of stem direction
      // 3) The remaining notes (that are note ajacent by step to another note), are all placed either on the right
      //    side or the left side, depending on the stem direction (Stem up? Notes on left side. Stem down? Notes on
      //    right side.)
      // If the chord has a 2nd in it, there will be two columns (the stem will be on the "right side"). Depending
      // on which direction the stem is facing, it'll be up to the user to determine which side STEMSIDE stems
      // should be on.

      if (pitches.size() == 0)
      {
         // Do nothing
      }
      else if (pitches.size() == 1)
      {
         int pitch_staff_position = pitches[0].get_staff_position();
         positions.push_back({ pitch_staff_position, PositionType::STEMSIDE });
      }
      else // There are 2 or more pitches
      {
         seconds_exist = false;
         for (int i=0; i<(pitches.size() - 1); i++)
         {
            int this_note_staff_position = pitches[i].get_staff_position();
            int next_note_staff_position = pitches[i+1].get_staff_position();

            if (abs(this_note_staff_position - next_note_staff_position) == 1)
            {
               seconds_exist = true;
               break;
            }
         }
 
         if (!seconds_exist)
         {
            for (auto &pitch : pitches)
            {
               int pitch_staff_position = pitch.get_staff_position();
               positions.push_back({ pitch_staff_position, PositionType::STEMSIDE });
            }
         }
         else
         {
            bool this_second_right_side = true;
            bool second_placed_previously = false;

            // Place all the notes leading up to the last note
            for (int i=0; i<(pitches.size() - 1); i++)
            {
               int this_note_staff_position = pitches[i].get_staff_position();
               int next_note_staff_position = pitches[i+1].get_staff_position();

               if (abs(this_note_staff_position - next_note_staff_position) == 1)
               {
                  positions.push_back({
                        this_note_staff_position,
                        this_second_right_side ? PositionType::RIGHT : PositionType::LEFT
                     });
                  second_placed_previously = true;
                  this_second_right_side = !this_second_right_side;
               }
               else
               {
                  if (second_placed_previously)
                  {
                     positions.push_back({
                           this_note_staff_position,
                           this_second_right_side ? PositionType::RIGHT : PositionType::LEFT
                        });
                  }
                  else // if (!second_placed_previously)
                  {
                     positions.push_back({this_note_staff_position, PositionType::STEMSIDE});
                  }

                  second_placed_previously = false;
                  this_second_right_side = true;
               }
            }

            // Place the last note
            int last_pitch_staff_position = pitches.back().get_staff_position();
            if (second_placed_previously)
            {
               positions.push_back({
                     last_pitch_staff_position,
                     this_second_right_side ? PositionType::RIGHT : PositionType::LEFT
                  });
            }
            else // if (!second_placed_previously)
            {
               positions.push_back({last_pitch_staff_position, PositionType::STEMSIDE});
            }
         }
      }

      solved = true;
      return;


  - name: custom_comparison_for_pitch_tokens
    private: true
    static: true
    type: bool
    parameters:
      - name: token1
        type: const AllegroFlare::MusicNotation::Parser::PitchToken&
        default_argument: AllegroFlare::MusicNotation::Parser::PitchToken()
      - name: token2
        type: const AllegroFlare::MusicNotation::Parser::PitchToken&
        default_argument: AllegroFlare::MusicNotation::Parser::PitchToken()
    body: |
      if (token1.staff_position != token2.staff_position) return token1.staff_position < token2.staff_position;
      return token1.calculate_accidental_weight() < token2.calculate_accidental_weight();


  - name: sort_and_make_unique
    body: |
      // TODO: Test this method
      std::set<
            AllegroFlare::MusicNotation::Parser::PitchToken,
            bool(*)(
                  const AllegroFlare::MusicNotation::Parser::PitchToken&,
                  const AllegroFlare::MusicNotation::Parser::PitchToken&
               )
         > result_pitches(
                  AllegroFlare::MusicNotation::ChordNoteheadPositionResolver::custom_comparison_for_pitch_tokens
             );

      for (auto &note : pitches)
      {
         result_pitches.insert(note);
      }

      pitches.clear();
      for (auto &note : result_pitches)
      {
         pitches.push_back(note);
      }
      return;
    body_dependency_symbols:
      - std::set


dependencies:


  - symbol: AllegroFlare::MusicNotation::Parser::PitchToken
    headers: [ AllegroFlare/MusicNotation/Parser/PitchToken.hpp ]
  - symbol: AllegroFlare::MusicNotation::ChordNoteheadPositionResolver::PositionType
    headers: [ ]


