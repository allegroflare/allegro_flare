properties:


  - name: offset_sec
    type: float
    init_with: 1.0
    constructor_arg: true
    getter: true
    setter: false

  - name: decay
    type: float
    init_with: 0.8
    constructor_arg: true
    getter: true

  - name: mixer
    type: AllegroFlare::AudioMixer
    init_with: ''

  - name: data_block
    type: AllegroFlare::AudioDataBlock
    init_with: ''
    getter_ref: true

  - name: initialized
    type: bool
    init_with: false


functions:


  - name: set_offset_sec
    parameters:
      - name: offset_sec
        type: float
        default_argument: 1.0f
    body: |
      data_block.set_sample_count(data_block.get_frequency() * offset_sec);
      return;


  - name: get_al_mixer
    type: ALLEGRO_MIXER*
    guards: [ initialized ]
    body: |
      return mixer.get_mixer();


  - name: initialize
    guards: [ (!initialized) ]
    body: |
      // initialize the mixer
      // DEBUG:
      mixer.initialize();

      // initialize the data_block
      data_block.initialize();
      float frequency = data_block.get_frequency(); // same as "samples per second"
      int samples_needed = (int)(frequency * offset_sec);
      data_block.set_sample_count(samples_needed);

      // attach the
      mixer.set_postprocess_callback(mixer_postprocess_callback, this);

      // set initialized
      initialized = true;
      return;


  - name: mixer_postprocess_callback
    type: void
    static: true
    parameters:
      - name: buf
        type: void*
        default_argument: nullptr
      - name: samples
        type: unsigned int
        default_argument: 0
      - name: data
        type: void*
        default_argument: nullptr
    guards: [ data ]
    body: |
      float *fbuf = (float *)buf;
      AllegroFlare::AudioProcessing::AllPass *all_pass= static_cast<AllegroFlare::AudioProcessing::AllPass*>(data);
      AllegroFlare::AudioDataBlock &data_block = all_pass->get_data_block_ref();
      float wet = 1.0; //all_pass->decay;
      float dry = 1.0;
      int channel_count = all_pass->mixer.get_channel_count();

      //int sample_offset = 256;
      //static std::pair<float, float> delayed_sample = {0, 0};

      float allPassGain = 1.0;

      for (int i=0; i<samples; i++)
      {
         int bufpos = i * 2;

         //float delayOutput = allPassDelayedSample;
         std::pair<float, float> delayOutput = data_block.get_sample_at(i+1);

         //float feedBack = delayOutput * allPassGain;
         std::pair<float, float> feedBack = std::pair<float, float>(
            delayOutput.first * allPassGain,
            delayOutput.second * allPassGain
         );

         //float delayInput = inSamp + feedBack;
         std::pair<float, float> delayInput = std::pair<float, float>(
            fbuf[bufpos+0] + feedBack.first,
            fbuf[bufpos+1] + feedBack.second
         );

         //float feedForward = delayInput * -allPassGain;
         std::pair<float, float> feedForward = std::pair<float, float>(
            delayInput.first * -allPassGain,
            delayInput.second * -allPassGain
         );

         //allPassDelayedSample = delayInput;
         data_block.set_sample_at(i-1, delayInput.first, delayInput.second);

         //return delayOutput + feedForward;
         fbuf[bufpos+0] = delayOutput.first + feedForward.first;
         fbuf[bufpos+1] = delayOutput.second + feedForward.second;
      }
      data_block.move_sample_head_position_by(samples);
 
      return;
    body_dependency_symbols:
      - std::cout


dependencies:


  - symbol: AllegroFlare::AudioDataBlock
    headers: [ AllegroFlare/AudioDataBlock.hpp ]
  - symbol: AllegroFlare::AudioMixer
    headers: [ AllegroFlare/AudioMixer.hpp ]
  - symbol: ALLEGRO_MIXER
    headers: [ allegro5/allegro_audio.h ]

