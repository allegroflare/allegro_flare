properties:


  - name: delay_sec
    type: float
    init_with: 1.0
    constructor_arg: true
    getter: true

  - name: decay
    type: float
    init_with: 0.8
    constructor_arg: true
    getter: true

  - name: memory
    type: AllegroFlare::AudioDataBlock
    init_with: '{}'

  - name: initialized
    type: bool
    init_with: false


functions:


  - name: initialize
    guards: [ (!initialized) ]
    body: |
      float frequency = memory.get_frequency(); // same as "samples per second"
      int samples_needed = (int)(frequency * delay_sec);
      memory.set_sample_count(samples_needed);
      memory.initialize();
      initialized = true;
      return;


  - name: mixer_postprocess_callback
    type: void
    static: true
    parameters:
      - name: buf
        type: void*
        default_argument: nullptr
      - name: samples
        type: unsigned int
        default_argument: 0
      - name: data
        type: void*
        default_argument: nullptr
    guards: [ data ]
    body: |
      float *fbuf = (float *)buf;
      AllegroFlare::AudioProcessing::Delay *delay = static_cast<AllegroFlare::AudioProcessing::Delay*>(data);
      float wet = 0.8;
      float dry = 1.0;

      // process by channel
      for (int i=0; i<samples; i++)
      {
         int pos = i*2; // 2 == channel_count;
         fbuf[pos+0] = fbuf[pos+0];
         fbuf[pos+1] = fbuf[pos+1];
         
         // write the current memory sample + (existing buffer * dry) to the delay buffer
         //memory.set_sample_at(pos, fbuf);

         // (int pos = i*channel_count)
      }

      //memcpy(processing_buffer, fbuf, samples * channel_count);
      // write the signal data to the delay buffer
 
      return;
    body_dependency_symbols:
      - std::cout


dependencies:


  - symbol: AllegroFlare::AudioDataBlock
    headers: [ AllegroFlare/AudioDataBlock.hpp ]


