properties:


  - name: raw_csv_content
    type: std::string
    constructor_arg: true
    init_with: '"[unset-csv_content]"'
    setter: explicit

  - name: parsed_content
    type: std::vector<std::vector<std::string>>
    init_with: '{}'
    getter: explicit

  - name: parsed
    type: bool
    init_with: false
    getter: true


enums:


  - class: ParseState
    enumerators:
       - NORMAL
       - INSIDE_QUOTES


methods:


  - name: num_rows
    type: int
    guards: [ parsed ]
    body: |
      return parsed_content.size();


  - name: num_columns
    type: int
    guards: [ parsed ]
    body: |
      if (parsed_content.empty()) return 0;
      return parsed_content[0].size();


  - name: set_raw_csv_content
    parameters:
      - name: raw_csv_content
        type: std::string
        default_argument: '"[unset-raw_csv_content]"'
    body: |
      this->raw_csv_content = raw_csv_content;
      parsed = false;
      parsed_content.clear();
      return;


  - name: get_parsed_content
    type: std::vector<std::vector<std::string>>
    guards: [ parsed ]
    body: |
      return parsed_content;


  - name: parse
    guards: [ (!parsed) ]
    body: |
      parsed_content.clear();
      std::stringstream ss;
      ss.str(raw_csv_content);
      int line_num = 0;
      std::string line;
      int num_columns = -1;
      while (std::getline(ss, line))
      {
         std::vector<std::string> parsed_row = parse_row(line);
         if (num_columns == -1) num_columns = parsed_row.size();
         if (parsed_row.size() != num_columns)
         {
            // TODO: Test this throw
            std::stringstream error_message;
            error_message << "The first row contained \"" << num_columns << "\", However the row \""
                  << (line_num+1) << "\" containes \"" << parsed_row.size() << "\" columns. The number "
                     "of columns must be the same on all rows.";
            AllegroFlare::Logger::throw_error("AllegroFlare::CSVParser", error_message.str());
         }

         parsed_content.push_back(parsed_row);
         line_num++;
      }
      parsed = true;
      return;
    body_dependency_symbols:
      - std::cout
      - AllegroFlare::Logger


  - name: parse_row
    parameters:
      - name: line
        type: std::string
        default_argument: '"[unset-line]"'
    type: std::vector<std::string>
    body: |
      ParseState state = ParseState::NORMAL;
      std::string token;
      std::vector<std::string> tokens;

      for (char ch : line)
      {
         switch (state)
         {
            case ParseState::NORMAL: {
               if (ch == '"') {
                  state = ParseState::INSIDE_QUOTES;
               } else if (ch == ',') {
                  // Process the token
                  tokens.push_back(token);
                  token.clear();
               } else {
                  token += ch;
               }
               break;
            } break;

            case ParseState::INSIDE_QUOTES: {
               if (ch == '"') {
                  state = ParseState::NORMAL;
               } else {
                  token += ch;
               }
               break;
            } break;
         }
      }

      // Process the last token
      tokens.push_back(token);

      return tokens;
    body_dependency_symbols:
      - std::stringstream
      - std::vector


dependencies:


  - symbol: AllegroFlare::Logger
    headers: [ AllegroFlare/Logger.hpp ]


