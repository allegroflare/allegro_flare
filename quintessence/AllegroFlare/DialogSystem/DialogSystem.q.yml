properties:


  - name: bitmap_bin
    type: AllegroFlare::BitmapBin*
    init_with: nullptr
    constructor_arg: true
    setter: explicit

  - name: font_bin
    type: AllegroFlare::FontBin*
    init_with: nullptr
    constructor_arg: true
    setter: explicit

  - name: event_emitter
    type: AllegroFlare::EventEmitter*
    init_with: nullptr
    constructor_arg: true
    setter: explicit
    getter: true

  - name: dialog_node_bank
    type: AllegroFlare::DialogTree::NodeBank
    init_with: '{}'
    getter: true
    getter_ref: true
    setter: explicit

  - name: selection_cursor_box
    type: AllegroFlare::Elements::SelectionCursorBox
    init_with: '{}'

  - name: active_dialog_node
    type: AllegroFlare::DialogTree::Nodes::Base*
    init_with: nullptr
    getter: true

  - name: active_dialog_node_name
    type: std::string
    init_with: '"[unset-active_dialog_node_name]"'
    getter: true

  - name: active_dialog_box
    type: AllegroFlare::Elements::DialogBoxes::Base*
    init_with: nullptr
    getter: true

  - name: interparsable_on_operational_chunk_func
    type: std::function<void(std::string, AllegroFlare::Elements::DialogBoxes::Interparsable*, void*)>
    init_with: '{}'
    getter: true
    setter: true

  - name: interparsable_on_operational_chunk_func_user_data
    type: void*
    init_with: nullptr
    getter: true
    setter: true

  - name: on_before_activating_dialog_node_by_name_callback_func
    type: std::function<void(AllegroFlare::DialogSystem::DialogSystem*, std::string, AllegroFlare::DialogTree::Nodes::Base*, void*)>
    init_with: '{}'
    getter: true
    setter: true

  - name: on_before_activating_dialog_node_by_name_callback_func_user_data
    type: void*
    init_with: nullptr
    getter: true
    setter: true

  - name: set_dialog_node_bank_while_active_behavior
    type: AllegroFlare::DialogSystem::DialogSystem::SetDialogNodeBankWhileActiveBehavior
    init_with: SetDialogNodeBankWhileActiveBehavior::RESPAWN_IF_PRESENT
    getter: true
    setter: true

  - name: driver
    type: AllegroFlare::DialogSystemDrivers::Base*
    init_with: nullptr
    getter_ref: true
    getter: true
    setter: explicit

  - name: switched_in
    type: bool
    init_with: false
    getter: true

  - name: standard_dialog_box_font_name
    type: std::string
    init_with: DEFAULT_STANDARD_DIALOG_BOX_FONT_NAME
    getter: true
    setter: true

  - name: standard_dialog_box_font_size
    type: int
    init_with: DEFAULT_STANDARD_DIALOG_BOX_FONT_SIZE
    getter: true
    setter: true

  - name: standard_dialog_box_x
    type: float
    init_with: DEFAULT_STANDARD_DIALOG_BOX_X
    getter: true
    setter: true

  - name: standard_dialog_box_y
    type: float
    init_with: DEFAULT_STANDARD_DIALOG_BOX_Y
    getter: true
    setter: true

  - name: standard_dialog_box_width
    type: float
    init_with: DEFAULT_STANDARD_DIALOG_BOX_WIDTH
    getter: true
    setter: true

  - name: standard_dialog_box_height
    type: float
    init_with: DEFAULT_STANDARD_DIALOG_BOX_HEIGHT
    getter: true
    setter: true

  - name: standard_dialog_box_frame_color
    type: ALLEGRO_COLOR
    init_with: DEFAULT_STANDARD_DIALOG_BOX_FRAME_COLOR
    getter: true
    setter: true

  - name: standard_dialog_box_text_color
    type: ALLEGRO_COLOR
    init_with: DEFAULT_STANDARD_DIALOG_BOX_TEXT_COLOR
    getter: true
    setter: true

  - name: standard_dialog_box_background_color
    type: ALLEGRO_COLOR
    init_with: DEFAULT_STANDARD_DIALOG_BOX_BACKGROUND_COLOR
    getter: true
    setter: true

  - name: standard_dialog_box_label_color
    type: ALLEGRO_COLOR
    init_with: DEFAULT_STANDARD_DIALOG_BOX_LABEL_COLOR
    getter: true
    setter: true

  - name: initialized
    type: bool
    init_with: false
    getter: true

  - name: DEFAULT_STANDARD_DIALOG_BOX_FONT_NAME
    type: char*
    constexpr: true
    const: true
    static: true
    init_with: AllegroFlare::Elements::DialogBoxStyles::DEFAULT_FONT_NAME

  - name: DEFAULT_STANDARD_DIALOG_BOX_FONT_SIZE
    type: int
    constexpr: true
    const: true
    static: true
    init_with: AllegroFlare::Elements::DialogBoxStyles::DEFAULT_FONT_SIZE

  - name: DEFAULT_STANDARD_DIALOG_BOX_X
    type: float
    constexpr: true
    const: true
    static: true
    init_with: 1920/2.0f

  - name: DEFAULT_STANDARD_DIALOG_BOX_Y
    type: float
    constexpr: true
    const: true
    static: true
    init_with: 1080/8.0f*6+16

  - name: DEFAULT_STANDARD_DIALOG_BOX_WIDTH
    type: float
    constexpr: true
    const: true
    static: true
    init_with: 1920/2.0f

  - name: DEFAULT_STANDARD_DIALOG_BOX_HEIGHT
    type: float
    constexpr: true
    const: true
    static: true
    init_with: 1080/5.0f

  - name: DEFAULT_STANDARD_DIALOG_BOX_FRAME_COLOR
    type: ALLEGRO_COLOR
    constexpr: true
    const: true
    static: true
    init_with: 'ALLEGRO_COLOR{0, 0, 0, 1}'

  - name: DEFAULT_STANDARD_DIALOG_BOX_BACKGROUND_COLOR
    type: ALLEGRO_COLOR
    constexpr: true
    const: true
    static: true
    init_with: 'ALLEGRO_COLOR{0, 0, 0, 0.7}'

  - name: DEFAULT_STANDARD_DIALOG_BOX_TEXT_COLOR
    type: ALLEGRO_COLOR
    constexpr: true
    const: true
    static: true
    init_with: 'ALLEGRO_COLOR{1, 1, 1, 1}'

  - name: DEFAULT_STANDARD_DIALOG_BOX_LABEL_COLOR
    type: ALLEGRO_COLOR
    constexpr: true
    const: true
    static: true
    init_with: 'ALLEGRO_COLOR{1, 1, 1, 1}'


enums:


  - class: SetDialogNodeBankWhileActiveBehavior
    enumerators:
      - UNDEF
      - SWITCH_OUT
      - RESPAWN_IF_PRESENT


documentation:


  - notes:
     - Consider this class mostly frozen for extending features, except in the following cases:
       - New standard dialog types and logic to handle them and/or spawn them
       - Additional "on_thing_that_happend" callbacks to the driver.
       - Some additional "standard_dialog_box_*" methods, for example to set the dialog box colors, frames, etc
     - Any additional features (emitting some consequential event, etc) would be handled in the driver
  - todo:
     - Having different drivers would move us closer to switching dialogs in and out (maybe a push/pop mechanism)
     - Right now there is no consequence on the driver when the dialog_node_bank is set. It's uncertain what events
       would need to occour.
  - leftover todos:
     - modify process_dialog_event to branch based on the ALLEGRO_FLARE_EVENT_DIALOG_* event
     - remove ALLEGRO_FLARE_OPEN_DIALOG, etc from EventEmitter type events that are no longer used
     - consider if you need to make GameEventDatas for each of the different types of events
     - review overall the integrety of the system, Add lots of tests
     - consider revising the arguments in "activate_dialog_node_by_name_func", and when/where the activation occurs
       in coordination with the assignment of the "active_dialog_node" and "active_dialog_node_name"
     - consider that dialog node options in MultipageWithOptions are probably not be deleted properly


methods:


  - name: __dep_trigger
    parameters:
      - name: x
        type: void*
        default_argument: nullptr
        default_argument_dependency_symbols: [ 'AllegroFlare::Elements::DialogBoxStyles' ]
    body: |
      return;


  - name: set_bitmap_bin
    parameters:
      - name: bitmap_bin
        type: AllegroFlare::BitmapBin*
        default_argument: nullptr
    guards: [ (!initialized) ]
    body: |
      this->bitmap_bin = bitmap_bin;


  - name: set_font_bin
    parameters:
      - name: font_bin
        type: AllegroFlare::FontBin*
        default_argument: nullptr
    guards: [ (!initialized) ]
    body: |
      this->font_bin = font_bin;


  - name: set_event_emitter
    parameters:
      - name: event_emitter
        type: AllegroFlare::EventEmitter*
        default_argument: nullptr
    guards: [ (!initialized) ]
    body: |
      this->event_emitter = event_emitter;


  - name: set_driver
    parameters:
      - name: driver
        type: AllegroFlare::DialogSystemDrivers::Base*
        default_argument: nullptr
    body: |
      // TODO: Consider consequences of assigning the driver mid-flight
      this->driver = driver;


  - name: clear_and_reset
    body: |
      if (active_dialog_box)
      {
         delete active_dialog_box;
         active_dialog_box = nullptr;
      }

      // TODO: Hide selection cursor box (if showing)

      if (active_dialog_node)
      {
         active_dialog_node = nullptr;
      }
      active_dialog_node_name = "";

      dialog_node_bank.delete_all_nodes_and_clear(); // TODO: Consider that pointers contained in this class could
                                                     // potentially be owned or in use by other objects

      return;


  - name: set_dialog_node_bank
    parameters:
      - name: dialog_node_bank
        type: AllegroFlare::DialogTree::NodeBank
        default_argument: '{}'
    body: |
      if (a_dialog_is_active())
      {
         switch (set_dialog_node_bank_while_active_behavior)
         {
            // TODO: Test this behavior
            case SetDialogNodeBankWhileActiveBehavior::SWITCH_OUT: {
               this->dialog_node_bank.delete_all_nodes_and_clear();
               this->dialog_node_bank = dialog_node_bank;
               shutdown(); // This calls switch_out()
            } break;

            // TODO: Test this behavior
            case SetDialogNodeBankWhileActiveBehavior::RESPAWN_IF_PRESENT: {
               std::string last_active_dialog_node_name = active_dialog_node_name;
               clear_and_reset();
               this->dialog_node_bank = dialog_node_bank;

               if (this->dialog_node_bank.node_exists_by_name(last_active_dialog_node_name))
               {
                  activate_dialog_node_by_name(last_active_dialog_node_name);
               }
            } break;

            default: {
               AllegroFlare::Logger::throw_error(
                  "AllegroFlare::DialogSystem::DialogSystem::set_dialog_node_bank",
                  "Unhandled case for on_set_dialog_node_bank_while_active_behavior"
               );
            } break;
         }
      }
      else
      {
         this->dialog_node_bank.delete_all_nodes_and_clear();
         this->dialog_node_bank = dialog_node_bank;
      }
    body_dependency_symbols:
      - AllegroFlare::Logger


  - name: load_dialog_node_bank_from_file
    parameters:
      - name: filename
        type: std::string
        default_argument: '"[unset-filename]"'
    guards: [ driver ]
    body: |
      // TODO: Validate a dialog is not currently running (or something)

      AllegroFlare::DialogTree::NodeBank loader_result_node_bank;
      bool handled = driver->on_load_node_bank_from_file(
         filename,
         &loader_result_node_bank
      );

      if (!handled)
      {
         AllegroFlare::Logger::throw_error(
               "AllegroFlare::DialogSystem::DialogSystem::load_dialog_node_bank_from_file"
               // TODO: Update this error message
               "\"on_load_node_bank_from_file\" was called on the driver but it returned false, indicating "
                  "that it was not able to load the NodeBank as expected."
            );
      }

      set_dialog_node_bank(loader_result_node_bank);
      return;
    body_dependency_symbols:
      - AllegroFlare::UsefulPHP
      - AllegroFlare::DialogTree::BasicScreenplayTextLoader
      - AllegroFlare::StringFormatValidator
      - AllegroFlare::Logger


  - name: initialize
    guards:
       - (!initialized)
       - al_is_system_installed()
       - al_is_primitives_addon_initialized()
       - al_is_font_addon_initialized()
       - bitmap_bin
       - font_bin
       - event_emitter
    body: |
      initialized = true;
      return;
    body_dependency_symbols:
      - al_is_primitives_addon_initialized


  - name: destroy
    body: |
      // TODO: This method requires consideration -- particularly active_speaker_layout which is currently owned
      // by this object. Also, this method will need to be called in Frameworks::Full
      //if (_driver) _driver->destroy();
      //delete driver.active_character_staging_layout;
      return;


  - name: switch_in
    guards: [ (!switched_in) ]
    body: |
      switched_in = true;
      if (driver) driver->on_switch_in();
      event_emitter->emit_dialog_switched_in_event();
      return;


  - name: switch_in_if_not
    body: |
      if (!switched_in) switch_in();
      return;


  - name: switch_out
    guards: [ initialized, switched_in ]
    body: |
      if (active_dialog_box)
      {
         delete active_dialog_box; // TODO: Consider a less intrusive soft delete (hide motion, with cleanup during update)
         active_dialog_box = nullptr;
      }

      active_dialog_node = nullptr;
      active_dialog_node_name = "";

      if (driver) driver->on_switch_out(); // TODO: This may need to be moved to "switch_out"

      event_emitter->emit_dialog_switched_out_event();

      switched_in = false;
      return;


  - name: activate_EmitGameEvent_dialog_node
    parameters:
      - name: node
        type: AllegroFlare::DialogTree::Nodes::EmitGameEvent*
        default_argument: nullptr
    guards: [ node ]
    body: |
      active_dialog_node = node; // TODO: Test this line
      // For now, nullptr data
      event_emitter->emit_game_event(AllegroFlare::GameEvent(node->get_game_event_name(), nullptr));
      if (!node->get_immediate_next_node_identifier().empty())
      {

         // If the "immediate_next_node_identifier" is not blank, activate that node. Note that any
         // expected consequences of the emitted game event will not have had time to process before this
         // "immediate_next_node_identifier" is emitted
         // TODO: Test this immediate next node activation
         // TODO: Consider if this should not be immediate and instead should be emitted as an event
            // (event would be cleaner)
         activate_dialog_node_by_name(node->get_immediate_next_node_identifier());
      }
      return;


  - name: activate_RawScriptLine_dialog_node
    parameters:
      - name: node
        type: AllegroFlare::DialogTree::Nodes::RawScriptLine*
        default_argument: nullptr
    guards: [ node ]
    body: |
      active_dialog_node = node; // TODO: Test this line
      // TODO: Investigate why no properties from RawScriptLine are used in this command
      // TODO: Test with driver and without driver
      if (driver) driver->on_raw_script_line_activate( // could find a better name for this method
         this,
         active_dialog_node_name,
         active_dialog_node
      );
      return;


  - name: activate_Wait_dialog_node
    parameters:
      - name: node
        type: AllegroFlare::DialogTree::Nodes::Wait*
        default_argument: nullptr
    guards: [ node ]
    body: |
      active_dialog_node = node;
      float duration_seconds = node->get_duration_sec();
      spawn_wait_dialog(duration_seconds);
      return;


  - name: activate_ChapterTitle_dialog_node
    parameters:
      - name: node
        type: AllegroFlare::DialogTree::Nodes::ChapterTitle*
        default_argument: nullptr
    guards: [ node ]
    body: |
      active_dialog_node = node;
      spawn_chapter_title_dialog(node->get_title_text(), node->get_duration());
      return;


  - name: activate_ExitDialog_dialog_node
    parameters:
      - name: node
        type: AllegroFlare::DialogTree::Nodes::ExitDialog*
        default_argument: nullptr
    guards: [ node ]
    body: |
      active_dialog_node = node; // Mostly redundant (shutdown_dialog will clear this value anyway)
      shutdown(); // TODO: See if this is a correct action for this event, e.g.
                         //       should it be "switch_out" or "shutdown", etc
      return;


  - name: activate_ExitProgram_dialog_node
    parameters:
      - name: node
        type: AllegroFlare::DialogTree::Nodes::ExitProgram*
        default_argument: nullptr
    guards: [ node ]
    body: |
      active_dialog_node = node;
      get_event_emitter()->emit_exit_game_event();
      return;


  - name: activate_YouGotAnItemDialog_dialog_node
    parameters:
      - name: node
        type: AllegroFlare::DialogTree::Nodes::YouGotAnItemDialog*
        default_argument: nullptr
    guards: [ node ]
    body: |
      active_dialog_node = node;
      std::string item_name = node->get_item_name();
      std::string item_bitmap_identifier = node->get_item_bitmap_identifier();
      spawn_you_got_an_item_dialog(item_name, item_bitmap_identifier);
      return;


  - name: activate_Interparsable_dialog_node
    parameters:
      - name: node
        type: AllegroFlare::DialogTree::Nodes::Interparsable*
        default_argument: nullptr
    guards: [ node ]
    body: |
      active_dialog_node = node;
      std::string speaker = node->get_speaker();
      std::vector<std::string> node_pages = node->get_pages();
      spawn_interparsable_dialog(
         speaker,
         node_pages,
         interparsable_on_operational_chunk_func,
         interparsable_on_operational_chunk_func_user_data
      );
      return;


  - name: activate_MultipageWithOptions_dialog_node
    parameters:
      - name: node
        type: AllegroFlare::DialogTree::Nodes::MultipageWithOptions*
        default_argument: nullptr
      - name: node_identifier
        type: std::string
        default_argument: '"[unset-node_identifier-for-MultipageWithOptions]"'
    guards: [ node ]
    body: |
      active_dialog_node = node; // TODO: Test this line
      // NOTE: The actual technique used to handle the "MutlipageWithOptions" node will vary depending on the
      //       content of the node.
      //    1) If it has a only one choice, then only a BasicDialog will be spawned
      //       and on advance(), will activate the choice as if it were the only choice. This was done for downstream
      //       simplicity, but should likely be fixed.
      //    2) If no options are listed at all, will throw an error
      //    3) When options are present, only 1 page of dialog is allowed. Again, this was probably for downstream
      //       simplicity, and should likely be fixed.

      // NOTE: Additional side-effects include:
      //    1) A callback is used on the driver (on_before_spawn_basic_dialog) and (on_before_spawn_choice_dialog),
      //       typically used for changing the layout. TODO: Consider alternative placement for this feature. I don't
      //       think it should go into the spawning of the dialog box itself.
      //    2) The dialog box speaking characters are decorated (via a deletgated call to the driver) before being
      //       passed along to the dialog box on the creation call
      //    3) Consider where/when any spoken text should be appended to the dialog roll
               
      
      // TODO: Consider making node const (will require const on "build_options_as_text")
      // TODO: Consider removing "node_identifier" from this method, it's present only for debugging reasons
      // TODO: Unindent this method
      //AllegroFlare::DialogTree::Nodes::MultipageWithOptions *as_multipage_with_options =
            //static_cast<AllegroFlare::DialogTree::Nodes::MultipageWithOptions*>(active_dialog_node);


      std::string node_pages_speaker = node->get_speaker();
      std::vector<std::string> node_pages = node->get_pages();
      std::vector<std::string> node_options_as_text = node->build_options_as_text();
      int cursor_position_on_spawn = node->infer_cursor_position_on_spawn();

      if (node_options_as_text.empty())
      {
         throw std::runtime_error(
            "DialogSystem::DialogSystem::activate_dialog_node_by_name: error: Expecting 1 or many options on "
               "node with node_identifier \"" + node_identifier + "\" but there are no options."
         );
      }
      else if (node_options_as_text.size() == 1)
      {
         // If dialog has only one option, spawn a basic dialog
         if (driver) driver->on_before_spawn_basic_dialog(node_pages_speaker);
         spawn_basic_dialog(
            driver ? driver->decorate_speaking_character_name(node_pages_speaker) : node_pages_speaker,
            //node_pages_speaker,
            node_pages
         );
         //append_to_dialog_roll(node_pages_speaker, node_pages[0]); // TODO: join(node_pages);
      }
      else // (node_options_as_text.size() > 1)
      {
         // If dialog has multiple options, spawn a "choice" dialog
         if (node_pages.size() != 1)
         {
            throw std::runtime_error(
               "DialogSystem::DialogSystem::activate_dialog_node_by_name: error: Expecting only 1 page for dialog "
                  "node (with identifier \"" + node_identifier + "\") because it is going to be used to build a "
                  "Choice dialog, however there are \"" + std::to_string(node_pages.size()) + "\" pages."
            );
         }
         if (driver) driver->on_before_spawn_choice_dialog(node_pages_speaker);
         spawn_choice_dialog(
            driver ? driver->decorate_speaking_character_name(node_pages_speaker) : node_pages_speaker,
            node_pages[0],
            node_options_as_text,
            cursor_position_on_spawn
         );
         //append_to_dialog_roll(node_pages_speaker, node_pages[0]); // TODO: join(node_pages);
      }
      return;


  - name: activate_dialog_node
    parameters:
      - name: dialog_node
        type: AllegroFlare::DialogTree::Nodes::Base*
        default_argument: nullptr
    guards: [ dialog_node ]
    body: |
      // TODO: Conaider that "active_dialog_node" is assigned inside each of the activate_TypeOfNode... methods and
      // this seems like a lot of duplicate logic (and also a bit brittle for refactoring and modification). Possibly
      // a better pattern is to set "active_dialog_node" here at the top (or at the bottom). I don't think any of
      // the methods in question have any specific behavior for assignment. I also think they are probably internal.
      // Also note that there is an assinment to "active_dialog_node" in the last else statement in this method.

      if (dialog_node->is_type(AllegroFlare::DialogTree::Nodes::EmitGameEvent::TYPE))
      {
         AllegroFlare::DialogTree::Nodes::EmitGameEvent *as =
            static_cast<AllegroFlare::DialogTree::Nodes::EmitGameEvent*>(dialog_node);
         activate_EmitGameEvent_dialog_node(as);
      }
      else if (dialog_node->is_type(AllegroFlare::DialogTree::Nodes::RawScriptLine::TYPE))
      {
         AllegroFlare::DialogTree::Nodes::RawScriptLine *as =
            static_cast<AllegroFlare::DialogTree::Nodes::RawScriptLine*>(dialog_node);
         activate_RawScriptLine_dialog_node(as);
      }
      else if (dialog_node->is_type(AllegroFlare::DialogTree::Nodes::Interparsable::TYPE))
      {
         AllegroFlare::DialogTree::Nodes::Interparsable *as =
            static_cast<AllegroFlare::DialogTree::Nodes::Interparsable*>(dialog_node);
         activate_Interparsable_dialog_node(as);
      }
      else if (dialog_node->is_type(AllegroFlare::DialogTree::Nodes::MultipageWithOptions::TYPE))
      {
         AllegroFlare::DialogTree::Nodes::MultipageWithOptions *as =
            static_cast<AllegroFlare::DialogTree::Nodes::MultipageWithOptions*>(dialog_node);
         activate_MultipageWithOptions_dialog_node(as);
      }
      else if (dialog_node->is_type(AllegroFlare::DialogTree::Nodes::YouGotAnItemDialog::TYPE))
      {
         AllegroFlare::DialogTree::Nodes::YouGotAnItemDialog *as =
            static_cast<AllegroFlare::DialogTree::Nodes::YouGotAnItemDialog*>(dialog_node);
         activate_YouGotAnItemDialog_dialog_node(as);
      }
      else if (dialog_node->is_type(AllegroFlare::DialogTree::Nodes::Wait::TYPE))
      {
         AllegroFlare::DialogTree::Nodes::Wait *as =
            static_cast<AllegroFlare::DialogTree::Nodes::Wait*>(dialog_node);
         activate_Wait_dialog_node(as);
      }
      else if (dialog_node->is_type(AllegroFlare::DialogTree::Nodes::ChapterTitle::TYPE))
      {
         AllegroFlare::DialogTree::Nodes::ChapterTitle *as =
            static_cast<AllegroFlare::DialogTree::Nodes::ChapterTitle*>(dialog_node);
         activate_ChapterTitle_dialog_node(as);
      }
      else if (dialog_node->is_type(AllegroFlare::DialogTree::Nodes::ExitDialog::TYPE))
      {
         AllegroFlare::DialogTree::Nodes::ExitDialog *as =
            static_cast<AllegroFlare::DialogTree::Nodes::ExitDialog*>(dialog_node);
         activate_ExitDialog_dialog_node(as);
      }
      else if (dialog_node->is_type(AllegroFlare::DialogTree::Nodes::ExitProgram::TYPE))
      {
         AllegroFlare::DialogTree::Nodes::ExitProgram *as =
            static_cast<AllegroFlare::DialogTree::Nodes::ExitProgram*>(dialog_node);
         activate_ExitProgram_dialog_node(as);
      }
      else
      {
         active_dialog_node = dialog_node; // NOTE: Unsure if assignment should occour here
         bool handled = false;
         if (driver)
         {
            // TODO: Test calling on this "unhandled" case
            handled = driver->on_activate_dialog_node_type_unhandled(this, active_dialog_node);
         }

         // TODO: Test throwing of this when not handled
         if (!handled)
         {
            throw std::runtime_error(
               "DialogSystem::DialogSystem::activate_dialog_node: error: "
                  "Unable to handle dialog node activation on type \""
                  + active_dialog_node->get_type() + "\". A condition is not provided to handle this type."
            );
         }
      }
      return;
    body_dependency_symbols:
     - AllegroFlare::DialogTree::Nodes::MultipageWithOptions
     - AllegroFlare::DialogTree::Nodes::YouGotAnItemDialog
     - AllegroFlare::DialogTree::Nodes::RawScriptLine
     - AllegroFlare::DialogTree::Nodes::EmitGameEvent
     - AllegroFlare::DialogTree::Nodes::ExitDialog
     - AllegroFlare::DialogTree::Nodes::ExitProgram
     - AllegroFlare::DialogTree::Nodes::Wait
     - AllegroFlare::DialogTree::Nodes::ChapterTitle


  - name: activate_dialog_node_by_name
    parameters:
      - name: dialog_node_name
        type: std::string
        default_argument: '"[unset-dialog_node_name]"'
    body: |
      AllegroFlare::DialogTree::Nodes::Base *found_dialog_node = dialog_node_bank.find_node_by_name(dialog_node_name);
      if (!found_dialog_node)
      {
         // TODO: Test this error message
         std::set<std::string> all_node_names = dialog_node_bank.get_all_node_names();
         std::stringstream error_message;
         error_message << "Could not find dialog node with identifier \"" << dialog_node_name << "\". "
                       << "The node bank contains " << dialog_node_bank.num_nodes() << " nodes. ";
         if (!all_node_names.empty())
         {
            error_message << "The available nodes are: ";
            int count = 0;
            int max_names_to_show = 20;
            for (const auto& node_name : all_node_names)
            {
               if (count > 0) error_message << ", ";
               error_message << "\"" << node_name << "\"";
               count++;
               if (count >= max_names_to_show)
               {
                  int remaining = all_node_names.size() - count;
                  if (remaining > 0)
                  {
                     error_message << ", and " << remaining << " more not listed here.";
                  }
                  break;
               }
            }
         }
         AllegroFlare::Logger::throw_error(
            "AllegroFlare::DialogSystem::DialogSystem::activate_dialog_node_by_name",
            error_message.str()
         );
      }

      if (on_before_activating_dialog_node_by_name_callback_func)
      {
         on_before_activating_dialog_node_by_name_callback_func(
            this,
            dialog_node_name,
            found_dialog_node,
            on_before_activating_dialog_node_by_name_callback_func_user_data
         );
      }

      active_dialog_node_name = dialog_node_name;
      activate_dialog_node(found_dialog_node);
      return;
    body_dependency_symbols:
     - AllegroFlare::Logger
     - std::stringstream
     - std::vector
     - std::string


  - name: advance_MultipageWithOptions_dialog_node
    parameters:
      - name: node
        type: AllegroFlare::DialogTree::Nodes::MultipageWithOptions*
        default_argument: nullptr
      - name: cursor_position
        type: int
        default_argument: 0
    guards: [ node, node->has_options(), (cursor_position >= 0), (cursor_position < node->num_options()) ]
    body: |
      activate_dialog_option(cursor_position);
      return;


  - name: dialog_advance
    guards: [ initialized, active_dialog_box ]
    body: |
      active_dialog_box->advance(); // Should the dialog box advance multiple pages in some cases (interparsable with
                                    // text that is operational only) Should that be included in its advance only?
      if (!active_dialog_box->get_finished()) return;
      if (!active_dialog_node)
      {
         AllegroFlare::Logger::warn_from(
            "AllegroFlare::DialogSystem::DialogSystem::dialog_advance",
            "When advancing the dialog box, the dialog indicated it was finished. However, there was no corresponding "
               "active_dialog_node. This may be expected behavior in your case."
         );
         return;
      }

      if (active_dialog_node->is_type(AllegroFlare::DialogTree::Nodes::MultipageWithOptions::TYPE))
      {
         AllegroFlare::DialogTree::Nodes::MultipageWithOptions *as =
            static_cast<AllegroFlare::DialogTree::Nodes::MultipageWithOptions*>(active_dialog_node);

         //if (as->num_options() == 0)
         //{
            //// If this dialog node has no options, then proceed to a "shutdown" state

            //// TODO: Replace this throw with a shutdown
            //throw std::runtime_error(
               //"DialogSystem::dialog_advance: error: Expecting 1 or many options for node named \""
                  //+ active_dialog_node_name + "\" but there are no options."
            //);
         //}
         //else if (as->num_options() == 1)
         if (as->num_options() == 1)
         {
            // If the dialog node has 1 option, "activate" it
            int current_dialog_selection_choice = 0;
            advance_MultipageWithOptions_dialog_node(as, current_dialog_selection_choice);
            //activate_dialog_option(current_dialog_selection_choice);
         }
         else
         {
            // If the dialog *node* has more than 1 option, correlate the dialog *box*'s current cursor position
               // with the result and "activate" it
            if (!active_dialog_box->is_type(AllegroFlare::Elements::DialogBoxes::Choice::TYPE))
            {
               throw std::runtime_error(
                  "DialogSystem::dialog_advance: error: Expecting active_dialog_box (with more than one option) "
                     "to be of type \"AllegroFlare::Elements::DialogBoxes::Choice::TYPE\", but it is of type \""
                     + active_dialog_box->get_type() + "\""
               );
            }
            else
            {
               AllegroFlare::Elements::DialogBoxes::Choice *as_choice_dialog_box = 
                  static_cast<AllegroFlare::Elements::DialogBoxes::Choice*>(active_dialog_box);

               int current_dialog_selection_choice = as_choice_dialog_box->get_cursor_position();
               advance_MultipageWithOptions_dialog_node(as, current_dialog_selection_choice);
               //activate_dialog_option(current_dialog_selection_choice);
            }
         }
      }
      else if (active_dialog_node->is_type(AllegroFlare::DialogTree::Nodes::Interparsable::TYPE))
      {
         shutdown(); // TODO: Verify if this is a correct complete action for this event

         //if (!active_dialog_box->is_type(AllegroFlare::Elements::DialogBoxes::Interparsable::TYPE))
         //{
            //throw std::runtime_error(
               //"DialogSystem::dialog_advance: error: Expecting active_dialog_box "
                  //"to be of type \"AllegroFlare::Elements::DialogBoxes::Interparsable::TYPE\", but it is of type \""
                  //+ active_dialog_box->get_type() + "\""
            //);
         //}
         //else
         //{
            //AllegroFlare::Elements::DialogBoxes::Interparsable *as = 
               //static_cast<AllegroFlare::Elements::DialogBoxes::Interparsable*>(active_dialog_box);

            ////int current_dialog_selection_choice = as->get_cursor_position();
            //advance_Interparsable_dialog_node(as);
         //}
         //AllegroFlare::DialogTree::Nodes::Wait *as =
            //static_cast<AllegroFlare::DialogTree::Nodes::Wait*>(active_dialog_node);
         //activate_dialog_node_by_name(as->get_next_node_identifier());
      }
      else if (active_dialog_node->is_type(AllegroFlare::DialogTree::Nodes::Wait::TYPE))
      {
         AllegroFlare::DialogTree::Nodes::Wait *as =
            static_cast<AllegroFlare::DialogTree::Nodes::Wait*>(active_dialog_node);
         activate_dialog_node_by_name(as->get_next_node_identifier());
      }
      else if (active_dialog_node->is_type(AllegroFlare::DialogTree::Nodes::ChapterTitle::TYPE))
      {
         AllegroFlare::DialogTree::Nodes::ChapterTitle *as =
            static_cast<AllegroFlare::DialogTree::Nodes::ChapterTitle*>(active_dialog_node);
         activate_dialog_node_by_name(as->get_next_node_identifier());
      }
      else if (active_dialog_node->is_type(AllegroFlare::DialogTree::Nodes::RawScriptLine::TYPE))
      {
         // TODO: Throw when no driver is present
         if (driver) driver->on_raw_script_line_finished(this, active_dialog_box, active_dialog_node);
      }
      else if (active_dialog_node->is_type(AllegroFlare::DialogTree::Nodes::ExitDialog::TYPE))
      {
         shutdown(); // TODO: Verify if this is a correct complete action for this event
      }
      else if (active_dialog_node->is_type(AllegroFlare::DialogTree::Nodes::YouGotAnItemDialog::TYPE))
      {
         shutdown(); // TODO: Verify if this is a correct complete action for this event
      }
      else if (active_dialog_node->is_type(AllegroFlare::DialogTree::Nodes::ExitProgram::TYPE))
      {
         event_emitter->emit_exit_game_event();
      }
      else
      {
         throw std::runtime_error(
            "DialogSystem::dialog_advance: error: Unable to handle case where dialog *box* is finished when "
               "the dialog *node* type \""
               + active_dialog_node->get_type() + "\". A condition is not provided to handle this type."
         );
      }
      return;
    body_dependency_symbols:
      - AllegroFlare::Elements::DialogBoxes::Choice
      - AllegroFlare::Elements::DialogBoxes::Wait
      - AllegroFlare::DialogTree::Nodes::ExitDialog
      - AllegroFlare::DialogTree::Nodes::ExitProgram
      - AllegroFlare::DialogTree::Nodes::ChapterTitle
      - AllegroFlare::DialogTree::Nodes::RawScriptLine


  - name: activate_dialog_option
    private: true
    type: void
    parameters:
      - name: selection_choice
        type: int
        default_argument: 0
    guards:
      - event_emitter
      - active_dialog_node
    body: |
      if (active_dialog_node->is_type(AllegroFlare::DialogTree::Nodes::MultipageWithOptions::TYPE))
      {

         AllegroFlare::DialogTree::Nodes::MultipageWithOptions *as_multipage_with_options =
            static_cast<AllegroFlare::DialogTree::Nodes::MultipageWithOptions*>(active_dialog_node);

         // TODO: Consider case where dialog node has no (empty) options
         if (!(selection_choice >= 0))
         {
            throw std::runtime_error(
               "DialogSystem::activate_dialog_option: error: selection_choice must be >= 0"
            );
         }
         if (!(selection_choice < as_multipage_with_options->num_options()))
         {
            throw std::runtime_error(
               "DialogSystem::activate_dialog_option: error: selection_choice must be less than the num options"
            );
         }

         AllegroFlare::DialogTree::NodeOptions::Base* node_option =
            std::get<1>(as_multipage_with_options->get_option_num(selection_choice)); //.second;
         std::string node_option_type = node_option->get_type();
   
         std::map<std::string, std::function<void()>> types_map = {
            { AllegroFlare::DialogTree::NodeOptions::ExitDialog::TYPE, [this, node_option]() {
               AllegroFlare::DialogTree::NodeOptions::ExitDialog* as_exit_dialog_node_option =
                  static_cast<AllegroFlare::DialogTree::NodeOptions::ExitDialog*>(node_option);

               //event_emitter->emit_dialog_close_event();
               shutdown(); // TODO: See if this is a correct expectation for this event
            }},
            { AllegroFlare::DialogTree::NodeOptions::GoToNode::TYPE, [this, node_option]() {
               // TODO: Test this case
               AllegroFlare::DialogTree::NodeOptions::GoToNode* as_go_to_node_dialog_node_option =
                  static_cast<AllegroFlare::DialogTree::NodeOptions::GoToNode*>(node_option);
               std::string target_node_name = as_go_to_node_dialog_node_option->get_target_node_name();

               //event_emitter->emit_dialog_open_event(target_node_name);
               activate_dialog_node_by_name(target_node_name);
            }},
         };

         // locate and call the function to handle the item
         if (types_map.count(node_option_type) == 0)
         {
            // item not found
            std::stringstream error_message;
            error_message << "[DialogTree::NodeOptionActivator::activate]: error: Cannot activate a node with the "
                          << "node_option_type \"" << node_option_type << "\", a handling for that type does not exist.";
            throw std::runtime_error(error_message.str());
         }
         else
         {
            // call the item
            types_map[node_option_type]();
         }
      }
      else
      {
         throw std::runtime_error(
            "DialogSystem::activate_dialog_option: error: Unable to handle case where dialog *node* is of type \""
               + active_dialog_node->get_type() + "\"."
         );
      }

      return;
    body_dependency_symbols:
      - std::function
      - AllegroFlare::DialogTree::NodeOptions::ExitDialog
      - AllegroFlare::DialogTree::NodeOptions::GoToNode


  - name: spawn_basic_dialog
    parameters:
      - name: speaking_character
        type: std::string
        default_argument: '"[unset-speaking_character]"'
      - name: pages
        type: std::vector<std::string>
        default_argument: '{}'
    body: |
      switch_in_if_not();

      bool a_dialog_existed_before = a_dialog_is_active();
      if (active_dialog_box) delete active_dialog_box; // TODO: address concern that this could clobber an active dialog
                                                       // And/or address concerns that derived dialog be deleted proper

      AllegroFlare::Elements::DialogBoxFactory dialog_box_factory;
      active_dialog_box = dialog_box_factory.create_basic_dialog(
         speaking_character,
         //speaking_character,
         pages
      );

      // TODO: Address when and where a switch_in should occur
      //bool a_new_dialog_was_created_and_dialog_system_is_now_active = !a_dialog_existed_before;
      //if (a_new_dialog_was_created_and_dialog_system_is_now_active)
      //{
         //switch_in();
      //}
      return;
    body_dependency_symbols:
      - AllegroFlare::Elements::DialogBoxFactory


  - name: spawn_interparsable_dialog
    parameters:
      - name: speaking_character
        type: std::string
        default_argument: '"[unset-speaking_character]"'
      - name: pages
        type: std::vector<std::string>
        default_argument: '{}'
      - name: on_operational_chunk_func
        type: std::function<void(std::string, AllegroFlare::Elements::DialogBoxes::Interparsable*, void*)>
        default_argument: '{}'
      - name: on_operational_chunk_func_user_data
        type: void*
        default_argument: nullptr
    body: |
      switch_in_if_not();

      bool a_dialog_existed_before = a_dialog_is_active();
      if (active_dialog_box) delete active_dialog_box; // TODO: address concern that this could clobber an active dialog
                                                       // And/or address concerns that derived dialog be deleted proper

      AllegroFlare::Elements::DialogBoxFactory dialog_box_factory;
      active_dialog_box = dialog_box_factory.create_interparsable_dialog(
         speaking_character,
         //speaking_character,
         pages,
         on_operational_chunk_func,
         on_operational_chunk_func_user_data
      );

      // TODO: Address when and where a switch_in should occur
      //bool a_new_dialog_was_created_and_dialog_system_is_now_active = !a_dialog_existed_before;
      //if (a_new_dialog_was_created_and_dialog_system_is_now_active)
      //{
         //switch_in();
      //}
      return;
    body_dependency_symbols:
      - AllegroFlare::Elements::DialogBoxFactory


  - name: spawn_intertitle_dialog
    parameters:
      - name: text
        type: std::string
        default_argument: '"[unset-text]"'
    body: |
      switch_in_if_not();

      bool a_dialog_existed_before = a_dialog_is_active();
      if (active_dialog_box) delete active_dialog_box; // TODO: address concern that this could clobber an active dialog
                                                       // And/or address concerns that derived dialog be deleted proper

      AllegroFlare::Elements::DialogBoxFactory dialog_box_factory;
      active_dialog_box = dialog_box_factory.create_intertitle_dialog(
         text
         //speaking_character,
         //pages
      );

      // TODO: Address when and where a switch_in should occur
      //bool a_new_dialog_was_created_and_dialog_system_is_now_active = !a_dialog_existed_before;
      //if (a_new_dialog_was_created_and_dialog_system_is_now_active)
      //{
         //switch_in();
      //}
      return;
    body_dependency_symbols:
      - AllegroFlare::Elements::DialogBoxFactory


  - name: spawn_text_messages_dialog
    parameters:
      - name: messages
        type: std::vector<std::tuple<std::string, std::string, float>>
        default_argument: '{}'
    body: |
      switch_in_if_not();

      bool a_dialog_existed_before = a_dialog_is_active();
      if (active_dialog_box) delete active_dialog_box; // TODO: address concern that this could clobber an active dialog
                                                       // And/or address concerns that derived dialog be deleted proper

      AllegroFlare::Elements::DialogBoxFactory dialog_box_factory;
      active_dialog_box = dialog_box_factory.create_text_messages_dialog(
         messages
         //speaking_character,
         //speaking_character,
         //pages
      );

      // TODO: Address when and where a switch_in should occur
      //bool a_new_dialog_was_created_and_dialog_system_is_now_active = !a_dialog_existed_before;
      //if (a_new_dialog_was_created_and_dialog_system_is_now_active)
      //{
         //switch_in();
      //}
      return;
    body_dependency_symbols:
      - AllegroFlare::Elements::DialogBoxFactory


  - name: spawn_wait_dialog
    parameters:
      - name: duration_seconds
        type: float
        default_argument: 1.0f
    body: |
      switch_in_if_not();

      bool a_dialog_existed_before = a_dialog_is_active();
      if (active_dialog_box) delete active_dialog_box; // TODO: address concern that this could clobber an active dialog
                                                       // And/or address concerns that derived dialog be deleted proper

      AllegroFlare::Elements::DialogBoxFactory dialog_box_factory;
      active_dialog_box = dialog_box_factory.create_wait_dialog(duration_seconds);

      // TODO: Address when and where a switch_in should occur
      //bool a_new_dialog_was_created_and_dialog_system_is_now_active = !a_dialog_existed_before;
      //if (a_new_dialog_was_created_and_dialog_system_is_now_active)
      //{
         //switch_in();
      //}
      return;
    body_dependency_symbols:
      - AllegroFlare::Elements::DialogBoxFactory


  - name: spawn_chapter_title_dialog
    parameters:
      - name: title_text
        type: std::string
        default_argument: '"[unset-title_text]"'
      - name: duration_seconds
        type: float
        default_argument: 1.0f
    body: |
      switch_in_if_not();

      bool a_dialog_existed_before = a_dialog_is_active();
      if (active_dialog_box) delete active_dialog_box; // TODO: address concern that this could clobber an active dialog
                                                       // And/or address concerns that derived dialog be deleted proper

      AllegroFlare::Elements::DialogBoxFactory dialog_box_factory;
      active_dialog_box = dialog_box_factory.create_chapter_title_dialog(
         title_text,
         duration_seconds
      );

      // TODO: Address when and where a switch_in should occur
      //bool a_new_dialog_was_created_and_dialog_system_is_now_active = !a_dialog_existed_before;
      //if (a_new_dialog_was_created_and_dialog_system_is_now_active)
      //{
         //switch_in();
      //}
      return;
    body_dependency_symbols:
      - AllegroFlare::Elements::DialogBoxFactory


  - name: spawn_you_got_an_item_dialog
    parameters:
      - name: item_name
        type: std::string
        default_argument: '"[unset-item_name]"'
      - name: item_bitmap_identifier
        type: std::string
        default_argument: '"[unset-item_bitmap_identifier]"'
    body: |
      switch_in_if_not();

      bool a_dialog_existed_before = a_dialog_is_active();
      if (active_dialog_box) delete active_dialog_box; // TODO: address concern that this could clobber an active dialog
                                                       // And/or address concerns that derived dialog be deleted proper

      AllegroFlare::Elements::DialogBoxFactory dialog_box_factory;
      active_dialog_box = dialog_box_factory.create_you_got_an_item_dialog(
         item_name,
         item_bitmap_identifier
      );

      return;
    body_dependency_symbols:
      - AllegroFlare::Elements::DialogBoxFactory


  - name: spawn_character_feature_dialog
    parameters:
      - name: character_name
        type: std::string
        default_argument: '"[unset-character_name]"'
      - name: character_description
        type: std::string
        default_argument: '"[unset-character_description]"'
      - name: character_image_identifier
        type: std::string
        default_argument: '"[unset-character_image_identifier]"'
      - name: duration_seconds
        type: float
        default_argument: 6.0f
    body: |
      switch_in_if_not();

      // TODO: Use a DEFAULT_DURATION_SECONDS
      bool a_dialog_existed_before = a_dialog_is_active();
      if (active_dialog_box) delete active_dialog_box; // TODO: address concern that this could clobber an active dialog
                                                       // And/or address concerns that derived dialog be deleted proper

      AllegroFlare::Elements::DialogBoxFactory dialog_box_factory;
      active_dialog_box = dialog_box_factory.create_character_feature_dialog(
         //driver ? driver->decorate_speaking_character(speaking_character) : speaking_character,
         character_name,
         character_description,
         character_image_identifier,
         duration_seconds
      );

      // TODO: Address when and where a switch_in should occur
      //bool a_new_dialog_was_created_and_dialog_system_is_now_active = !a_dialog_existed_before;
      //if (a_new_dialog_was_created_and_dialog_system_is_now_active)
      //{
         //switch_in();
      //}
      return;
    body_dependency_symbols:
      - AllegroFlare::Elements::DialogBoxFactory


  - name: spawn_choice_dialog
    parameters:
      - name: speaking_character
        type: std::string
        default_argument: '"[unset-speaking_character]"'
      - name: prompt
        type: std::string
        default_argument: '"[unset-prompt]"'
      - name: options
        type: std::vector<std::string>
        default_argument: '{}'
      - name: cursor_position_on_spawn
        type: int
        default_argument: 0
    guards: [ (cursor_position_on_spawn >= 0), (cursor_position_on_spawn < options.size()) ]
    body: |
      switch_in_if_not();

      bool a_dialog_existed_before = a_dialog_is_active();
      if (active_dialog_box) delete active_dialog_box; // TODO: address concern that this could clobber an active dialog

      // NOTE: In order to be compatable with "create_choice_dialog", we will fill with some dummy values.
      // For now, we use the cursor position of the choice dialog to pick the option. Consider revising or cleaning up
      std::vector<std::pair<std::string, std::string>> options_that_are_also_values;
      for (auto &option : options)
      {
         options_that_are_also_values.push_back({option, option});
      }

      AllegroFlare::Elements::DialogBoxFactory dialog_box_factory;
      AllegroFlare::Elements::DialogBoxes::Choice *choice_dialog_box =
            dialog_box_factory.create_choice_dialog(
               //driver ? driver->decorate_speaking_character_name(speaking_character) : speaking_character,
               speaking_character,
               prompt,
               options_that_are_also_values,
               cursor_position_on_spawn
            );
      active_dialog_box = choice_dialog_box;



      // Calculate the dimensions of the box, to set the cursor selection box on it
      AllegroFlare::Elements::DialogBoxRenderers::ChoiceRenderer choice_renderer_for_dimensions(
         font_bin,
         bitmap_bin,
         choice_dialog_box
      );

      std::tuple<float, float, float, float> selection_dimensions =
            choice_renderer_for_dimensions.calculate_dimensions_of_current_selection();
      choice_renderer_for_dimensions.helper__set_selection_cursor_box_dimensions_to(
         &selection_cursor_box,
         selection_dimensions
      );

      // TODO: Address when and where a switch_in should occur
      //bool a_new_dialog_was_created_and_dialog_system_is_now_active = !a_dialog_existed_before;
      //if (a_new_dialog_was_created_and_dialog_system_is_now_active)
      //{
         //switch_in();
      //}
      return;
    body_dependency_symbols:
      - AllegroFlare::Elements::DialogBoxFactory
      - AllegroFlare::Elements::DialogBoxRenderers::ChoiceRenderer


  - name: update
    parameters:
      - name: time_now
        type: float
        default_argument: 0
    guards: [ initialized ]
    body: |
      // TODO: Ensure time_now does not accidentally become 0 by not being noticed as an argument
      // TODO: Ensure time_now is passed down to active dialog updates()
      // TODO: Consider if ordering of events is correct
      if (active_dialog_box) active_dialog_box->update();
      selection_cursor_box.update();
      //if (active_dialog_node_state) active_dialog_node_state->update(); // TODO: Pass down time_now

      // TODO: Consider moving this block above with the normal update
      if (active_dialog_box && active_dialog_box->ready_to_auto_advance()) dialog_advance();
      if (driver) driver->update();

      return;


  - name: render
    type: void
    guards: [ initialized, driver ]
    body: |
      if (driver) driver->on_render();

      if (active_dialog_box)
      {
         AllegroFlare::Elements::DialogBoxRenderer dialog_box_renderer(
               font_bin,
               bitmap_bin,
               active_dialog_box,
               &selection_cursor_box
            );
         dialog_box_renderer.set_standard_dialog_box_font_name(standard_dialog_box_font_name);
         dialog_box_renderer.set_standard_dialog_box_font_size(standard_dialog_box_font_size);
         dialog_box_renderer.set_standard_dialog_box_x(standard_dialog_box_x);
         dialog_box_renderer.set_standard_dialog_box_y(standard_dialog_box_y);
         dialog_box_renderer.set_standard_dialog_box_width(standard_dialog_box_width);
         dialog_box_renderer.set_standard_dialog_box_height(standard_dialog_box_height);
         dialog_box_renderer.set_standard_dialog_box_frame_color(standard_dialog_box_frame_color);
         dialog_box_renderer.set_standard_dialog_box_text_color(standard_dialog_box_text_color);
         dialog_box_renderer.set_standard_dialog_box_background_color(standard_dialog_box_background_color);
         dialog_box_renderer.set_standard_dialog_box_label_color(standard_dialog_box_label_color);
         dialog_box_renderer.render();
      }
    body_dependency_symbols:
      - AllegroFlare::Elements::DialogBoxRenderer


  - name: a_dialog_is_active
    type: bool
    body: |
      return (active_dialog_box != nullptr);


  - name: dialog_is_finished
    type: bool
    guards: [ initialized, active_dialog_box ]
    body: |
      return active_dialog_box->get_finished();


  - name: shutdown
    type: bool
    guards: [ initialized, driver, switched_in ]
    body: |
      switch_out();
      return true;


  - name: move_dialog_cursor_position_up
    guards: [ initialized ]
    body: |
      if (!active_dialog_box) return;
      active_dialog_box->move_cursor_position_up();
      if (active_dialog_box->is_type(AllegroFlare::Elements::DialogBoxes::Choice::TYPE))
      {
         AllegroFlare::Elements::DialogBoxes::Choice *as_choice_dialog_box =
               static_cast<AllegroFlare::Elements::DialogBoxes::Choice*>(active_dialog_box);

         // Set the cursor selection box position to this point
         AllegroFlare::Elements::DialogBoxRenderers::ChoiceRenderer choice_renderer_for_dimensions(
            font_bin,
            bitmap_bin,
            as_choice_dialog_box
         );

         std::tuple<float, float, float, float> selection_dimensions =
               choice_renderer_for_dimensions.calculate_dimensions_of_current_selection();
         choice_renderer_for_dimensions.helper__reposition_selection_cursor_box_dimensions_to(
            &selection_cursor_box,
            selection_dimensions
         );
      }
      return;


  - name: move_dialog_cursor_position_down
    guards: [ initialized ]
    body: |
      if (!active_dialog_box) return;
      active_dialog_box->move_cursor_position_down();
      // TODO: Reposition the cursor
      if (active_dialog_box->is_type(AllegroFlare::Elements::DialogBoxes::Choice::TYPE))
      {
         AllegroFlare::Elements::DialogBoxes::Choice *as_choice_dialog_box =
               static_cast<AllegroFlare::Elements::DialogBoxes::Choice*>(active_dialog_box);

         // Set the cursor selection box position to this point
         AllegroFlare::Elements::DialogBoxRenderers::ChoiceRenderer choice_renderer_for_dimensions(
            font_bin,
            bitmap_bin,
            as_choice_dialog_box
         );

         std::tuple<float, float, float, float> selection_dimensions =
               choice_renderer_for_dimensions.calculate_dimensions_of_current_selection();
         choice_renderer_for_dimensions.helper__reposition_selection_cursor_box_dimensions_to(
            &selection_cursor_box,
            selection_dimensions
         );
      }
      return;


  - name: handle_raw_ALLEGRO_EVENT_that_is_dialog_event
    parameters:
      - name: ev
        type: ALLEGRO_EVENT*
        default_argument: nullptr
      - name: data
        type: AllegroFlare::GameEventDatas::Base*
        default_argument: nullptr
    guards: [ ev, data ]
    body: |
      // TODO: Update this to a map caller pattern (static const)
      if (data->is_type(AllegroFlare::DialogSystem::DialogEventDatas::LoadDialogNodeBankFromFile::TYPE))
      {
         auto *as = static_cast<AllegroFlare::DialogSystem::DialogEventDatas::LoadDialogNodeBankFromFile*>(data);
         load_dialog_node_bank_from_file(as->get_yaml_filename());
      }
      // TODO: Rename this SpawnDialogByName to ActivateDialogNodeByName
      else if (data->is_type(AllegroFlare::DialogSystem::DialogEventDatas::SpawnDialogByName::TYPE))
      {
         auto *as = static_cast<AllegroFlare::DialogSystem::DialogEventDatas::SpawnDialogByName*>(data);
         activate_dialog_node_by_name(as->get_name());
      }
      else
      {
         AllegroFlare::Logger::throw_error(
            "AllegroFlare::DialogSystem::DialogSystem::handle_raw_ALLEGRO_EVENT_that_is_dialog_event",
            "Unhandled case on type \"" + data->get_type() + "\"."
         );
      }
      return;
    body_dependency_symbols:
      - AllegroFlare::DialogSystem::DialogEventDatas::SpawnDialogByName
      - AllegroFlare::DialogSystem::DialogEventDatas::LoadDialogNodeBankFromFile


dependencies:


  - symbol: AllegroFlare::DialogSystem::DialogSystem
    headers: [ ]
  - symbol: ALLEGRO_BITMAP
    headers: [ allegro5/allegro.h ]
  - symbol: ALLEGRO_EVENT
    headers: [ allegro5/allegro.h ]
  - symbol: al_is_primitives_addon_initialized
    headers: [ allegro5/allegro_primitives.h ]
  - symbol: AllegroFlare::FontBin
    headers: [ AllegroFlare/FontBin.hpp ]
  - symbol: AllegroFlare::EventNames
    headers: [ AllegroFlare/EventNames.hpp ]
  - symbol: AllegroFlare::DialogSystem::DialogEventDatas::CloseDialog
    headers: [ AllegroFlare/DialogSystem/DialogEventDatas/CloseDialog.hpp ]
  - symbol: AllegroFlare::Elements::DialogBoxes::YouGotEvidence
    headers: [ AllegroFlare/Elements/DialogBoxes/YouGotEvidence.hpp ]
  - symbol: AllegroFlare::Elements::DialogBoxes::Base
    headers: [ AllegroFlare/Elements/DialogBoxes/Base.hpp ]
  - symbol: AllegroFlare::Elements::DialogBoxes::Choice
    headers: [ AllegroFlare/Elements/DialogBoxes/Choice.hpp ]
  - symbol: AllegroFlare::GameEvent
    headers: [ AllegroFlare/GameEvent.hpp ]
  - symbol: AllegroFlare::GameEventDatas::Base
    headers: [ AllegroFlare/GameEventDatas/Base.hpp ]
  - symbol: AllegroFlare::Elements::DialogBoxRenderer
    headers: [ AllegroFlare/Elements/DialogBoxRenderer.hpp ]
  - symbol: AllegroFlare::BitmapBin
    headers: [ AllegroFlare/BitmapBin.hpp ]
  - symbol: AllegroFlare::Elements::DialogBoxes::Basic
    headers: [ AllegroFlare/Elements/DialogBoxes/Basic.hpp ]
  - symbol: AllegroFlare::Elements::DialogBoxes::YouGotAnItem
    headers: [ AllegroFlare/Elements/DialogBoxes/YouGotAnItem.hpp ]
  - symbol: AllegroFlare::Elements::DialogBoxes::YouGotAnItem
    headers: [ AllegroFlare/Elements/DialogBoxes/YouGotAnItem.hpp ]
  - symbol: AllegroFlare::Elements::DialogBoxes::Wait
    headers: [ AllegroFlare/Elements/DialogBoxes/Wait.hpp ]
  - symbol: AllegroFlare::InventoryDictionaryItems::WithAttributes
    headers: [ AllegroFlare/InventoryDictionaryItems/WithAttributes.hpp ]
  - symbol: AllegroFlare::Elements::DialogBoxFactory
    headers: [ AllegroFlare/Elements/DialogBoxFactory.hpp ]
  - symbol: AllegroFlare::DialogSystem::DialogEventDatas::CreateYouGotAnItemDialog
    headers: [ AllegroFlare/DialogSystem/DialogEventDatas/CreateYouGotAnItemDialog.hpp ]
  - symbol: AllegroFlare::DialogSystem::DialogEventDatas::CreateYouGotEvidenceDialog
    headers: [ AllegroFlare/DialogSystem/DialogEventDatas/CreateYouGotEvidenceDialog.hpp ]
  - symbol: AllegroFlare::EventEmitter
    headers: [ AllegroFlare/EventEmitter.hpp ]
  - symbol: AllegroFlare::DialogTree::NodeBank
    headers: [ AllegroFlare/DialogTree/NodeBank.hpp ]
  - symbol: AllegroFlare::DialogTree::Nodes::Base
    headers: [ AllegroFlare/DialogTree/Nodes/Base.hpp ]
  - symbol: AllegroFlare::DialogTree::NodeOptions::GoToNode
    headers: [ AllegroFlare/DialogTree/NodeOptions/GoToNode.hpp ]
  - symbol: AllegroFlare::DialogTree::NodeOptions::ExitDialog
    headers: [ AllegroFlare/DialogTree/NodeOptions/ExitDialog.hpp ]
  - symbol: AllegroFlare::DialogTree::Nodes::MultipageWithOptions
    headers: [ AllegroFlare/DialogTree/Nodes/MultipageWithOptions.hpp ]
  - symbol: AllegroFlare::DialogTree::Nodes::YouGotAnItemDialog
    headers: [ AllegroFlare/DialogTree/Nodes/YouGotAnItemDialog.hpp ]
  - symbol: AllegroFlare::Elements::SelectionCursorBox
    headers: [ AllegroFlare/Elements/SelectionCursorBox.hpp ]
  - symbol: AllegroFlare::Elements::DialogBoxRenderers::ChoiceRenderer
    headers: [ AllegroFlare/Elements/DialogBoxRenderers/ChoiceRenderer.hpp ]
  - symbol: AllegroFlare::DialogSystem::DialogEventDatas::SpawnDialogByName
    headers: [ AllegroFlare/DialogSystem/DialogEventDatas/SpawnDialogByName.hpp ]
  - symbol: AllegroFlare::DialogSystem::DialogEventDatas::LoadDialogNodeBankFromFile
    headers: [ AllegroFlare/DialogSystem/DialogEventDatas/LoadDialogNodeBankFromFile.hpp ]
  - symbol: AllegroFlare::DialogSystem::CharacterStagingLayouts::Base
    headers: [ AllegroFlare/DialogSystem/CharacterStagingLayouts/Base.hpp ]
  - symbol: AllegroFlare::DialogSystem::CharacterRoster
    headers: [ AllegroFlare/DialogSystem/CharacterRoster.hpp ]
  - symbol: AllegroFlare::DialogSystem::Characters::Basic
    headers: [ AllegroFlare/DialogSystem/Characters/Basic.hpp ]
  - symbol: AllegroFlare::StringFormatValidator
    headers: [ AllegroFlare/StringFormatValidator.hpp ]
  - symbol: AllegroFlare::DialogTree::BasicScreenplayTextLoader
    headers: [ AllegroFlare/DialogTree/BasicScreenplayTextLoader.hpp ]
  - symbol: AllegroFlare::Logger
    headers: [ AllegroFlare/Logger.hpp ]
  - symbol: AllegroFlare::UsefulPHP
    headers: [ AllegroFlare/UsefulPHP.hpp ]
  - symbol: AllegroFlare::DialogTree::Nodes::ExitDialog
    headers: [ AllegroFlare/DialogTree/Nodes/ExitDialog.hpp ]
  - symbol: AllegroFlare::DialogTree::Nodes::ExitProgram
    headers: [ AllegroFlare/DialogTree/Nodes/ExitProgram.hpp ]
  - symbol: AllegroFlare::DialogTree::Nodes::ChapterTitle
    headers: [ AllegroFlare/DialogTree/Nodes/ChapterTitle.hpp ]
  - symbol: AllegroFlare::DialogTree::Nodes::RawScriptLine
    headers: [ AllegroFlare/DialogTree/Nodes/RawScriptLine.hpp ]
  - symbol: AllegroFlare::DialogTree::Nodes::EmitGameEvent
    headers: [ AllegroFlare/DialogTree/Nodes/EmitGameEvent.hpp ]
  - symbol: AllegroFlare::Elements::DialogRoll
    headers: [ AllegroFlare/Elements/DialogRoll.hpp ]
  - symbol: AllegroFlare::DialogTree::Nodes::Wait
    headers: [ AllegroFlare/DialogTree/Nodes/Wait.hpp ]
  - symbol: AllegroFlare::DialogSystemDrivers::Base
    headers: [ AllegroFlare/DialogSystemDrivers/Base.hpp ]
  - symbol: AllegroFlare::Elements::DialogBoxes::CharacterFeature
    headers: [ AllegroFlare/Elements/DialogBoxes/CharacterFeature.hpp ]
  - symbol: AllegroFlare::DialogTree::Nodes::Interparsable
    headers: [ AllegroFlare/DialogTree/Nodes/Interparsable.hpp ]
  - symbol: AllegroFlare::Elements::DialogBoxes::Interparsable
    headers: [ AllegroFlare/Elements/DialogBoxes/Interparsable.hpp ]
  - symbol: ALLEGRO_COLOR
    headers: [ allegro5/allegro.h ]
  - symbol: AllegroFlare::DialogSystem::DialogSystem::SetDialogNodeBankWhileActiveBehavior
    headers: [ AllegroFlare/DialogSystem/DialogSystem.hpp ]
  - symbol: AllegroFlare::Elements::DialogBoxStyles
    headers: [ AllegroFlare/Elements/DialogBoxStyles.hpp ]


