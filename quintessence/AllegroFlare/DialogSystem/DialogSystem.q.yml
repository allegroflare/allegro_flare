properties:


  - name: bitmap_bin
    type: AllegroFlare::BitmapBin*
    init_with: nullptr
    constructor_arg: true
    setter: explicit

  - name: font_bin
    type: AllegroFlare::FontBin*
    init_with: nullptr
    constructor_arg: true
    setter: explicit

  - name: event_emitter
    type: AllegroFlare::EventEmitter*
    init_with: nullptr
    constructor_arg: true
    setter: explicit
    getter: true

  - name: dialog_node_bank
    type: AllegroFlare::DialogTree::NodeBank
    init_with: '{}'
    getter: true
    setter: explicit

  - name: active_dialog_box
    type: AllegroFlare::Elements::DialogBoxes::Base*
    init_with: nullptr

  - name: selection_cursor_box
    type: AllegroFlare::Elements::SelectionCursorBox
    init_with: '{}'

  - name: active_dialog_node
    type: AllegroFlare::DialogTree::Nodes::Base*
    init_with: nullptr

  - name: active_dialog_node_name
    type: std::string
    init_with: '"[unset-active_dialog_node_name]"'
    getter: true

  - name: active_dialog_node_state
    type: AllegroFlare::DialogSystem::NodeStates::Base*
    init_with: nullptr

  - name: driver
    type: AllegroFlare::DialogSystemDrivers::BasicCharacterDialogDriver
    init_with: ''
    getter_ref: true
    getter: false
    setter: false

  - name: load_node_bank_func
    type: std::function<bool(std::string, AllegroFlare::DialogTree::NodeBank*, void*)>
    init_with: ''
    getter: true
    setter: true

  - name: load_node_bank_func_user_data
    type: void*
    init_with: nullptr
    getter: true
    setter: true

  - name: activate_dialog_node_by_name_func
    type: std::function<bool(AllegroFlare::DialogSystem::DialogSystem*, std::string, AllegroFlare::DialogTree::Nodes::Base*, void*)>
    init_with: ''
    getter: true
    setter: true

  - name: activate_dialog_node_by_name_func_user_data
    type: void*
    init_with: nullptr
    getter: true
    setter: true

  - name: activate_dialog_node_type_unhandled_func
    type: std::function<bool(AllegroFlare::DialogSystem::DialogSystem*, void*)>
    init_with: ''
    getter: true
    setter: true

  - name: activate_dialog_node_type_unhandled_func_user_data
    type: void*
    init_with: nullptr
    getter: true
    setter: true

  - name: dialog_advance_is_finished_node_type_unhandled_func
    type: std::function<bool(AllegroFlare::DialogSystem::DialogSystem*, AllegroFlare::Elements::DialogBoxes::Base*, AllegroFlare::DialogTree::Nodes::Base*, void*)>
    init_with: ''
    getter: true
    setter: true

  - name: dialog_advance_is_finished_node_type_unhandled_func_user_data
    type: void*
    init_with: nullptr
    getter: true
    setter: true

  - name: switched_in
    type: bool
    init_with: false
    getter: true

  - name: standard_dialog_box_font_name
    type: std::string
    init_with: DEFAULT_STANDARD_DIALOG_BOX_FONT_NAME
    getter: true
    setter: true

  - name: standard_dialog_box_font_size
    type: int
    init_with: DEFAULT_STANDARD_DIALOG_BOX_FONT_SIZE
    getter: true
    setter: true

  - name: initialized
    type: bool
    init_with: false

  - name: DEFAULT_STANDARD_DIALOG_BOX_FONT_NAME
    type: char*
    constexpr: true
    const: true
    static: true
    init_with: '(char*)"Inter-Regular.ttf"'

  - name: DEFAULT_STANDARD_DIALOG_BOX_FONT_SIZE
    type: int
    constexpr: true
    const: true
    static: true
    init_with: -36


documentation:


  - next_steps:
     - modify process_dialog_event to branch based on the ALLEGRO_FLARE_EVENT_DIALOG_* event
     - consider if you need to make GameEventDatas for each of the different types of events
     - review overall the integrety of the system, Add lots of tests, make it so "anybody can emit a dialog event"
  - todo:
     - currently, "active_character_staging_layout" is owned by this system and requires destruction
     - consider owning "character_roster" and loading from a file
     - consider revising the arguments in "activate_dialog_node_by_name_func", and when/where the activation occurs
       in coordination with the assignment of the "active_dialog_node" and "active_dialog_node_name"

methods:


  - name: set_bitmap_bin
    parameters:
      - name: bitmap_bin
        type: AllegroFlare::BitmapBin*
        default_argument: nullptr
    guards: [ (!initialized) ]
    body: |
      this->bitmap_bin = bitmap_bin;


  - name: set_font_bin
    parameters:
      - name: font_bin
        type: AllegroFlare::FontBin*
        default_argument: nullptr
    guards: [ (!initialized) ]
    body: |
      this->font_bin = font_bin;


  - name: set_event_emitter
    parameters:
      - name: event_emitter
        type: AllegroFlare::EventEmitter*
        default_argument: nullptr
    guards: [ (!initialized) ]
    body: |
      this->event_emitter = event_emitter;


  - name: set_dialog_node_bank
    parameters:
      - name: dialog_node_bank
        type: AllegroFlare::DialogTree::NodeBank
        default_argument: '{}'
    guards: [ (!initialized) ]
    body: |
      // For now, assigning the dialog_node_bank will be restricted to only before initialization.  There are currently
      // unknown side effects (for example, currently running dialog, sound effects playing, etc), that are not
      // accounted for here. However, you can "load_dialog_node_bank_from_file", so maybe there's some shared logic
      // there
      this->dialog_node_bank = dialog_node_bank;


  - name: load_dialog_node_bank_from_file
    parameters:
      - name: filename
        type: std::string
        default_argument: '"[unset-filename]"'
    guards: [ 'std::filesystem::exists(filename)' ]
    body: |
      // TODO: Validate a dialog is not currently running (or something)
      // TODO: Test these cases for loading multiple file formats with these extensions
      if (load_node_bank_func)
      {
         // TODO: Test the case where "load_node_bank_func"
         AllegroFlare::DialogTree::NodeBank loader_result_node_bank;
         bool handled = load_node_bank_func(filename, &loader_result_node_bank, load_node_bank_func_user_data);

         if (!handled)
         {
            AllegroFlare::Logger::throw_error(
                  "AllegroFlare::DialogSystem::DialogSystem::load_dialog_node_bank_from_file"
                  "a user \"load_node_bank_func\" has been provided, but it returned false when called, indicating "
                     "that it was not able to load the NodeBank as expected."
               );
         }

         dialog_node_bank = loader_result_node_bank;
      }
      else
      {
         AllegroFlare::StringFormatValidator validator(filename);

         if (validator.ends_with(".screenplay.txt"))
         {
            AllegroFlare::DialogTree::BasicScreenplayTextLoader loader;
            loader.load_file(filename);
            dialog_node_bank = loader.get_node_bank();
         }
         //else if (validator.ends_with(".yml") || validator.ends_with(".yaml"))
         //{
            //AllegroFlare::DialogTree::YAMLLoader yaml_loader;
            //yaml_loader.load_file(filename);
            //dialog_node_bank = yaml_loader.get_node_bank();
         //}
         else
         {
            AllegroFlare::Logger::throw_error(
               "AllegroFlare::DialogSystem::DialogSystem::load_dialog_node_bank_from_file",
               "Cannot load file. Unable to know what loader should be used for filename \"" + filename + "\""
            );
         }
      }
      return;
    body_dependency_symbols:
      - std::filesystem::exists
      - AllegroFlare::UsefulPHP
      - AllegroFlare::DialogTree::BasicScreenplayTextLoader
      - AllegroFlare::StringFormatValidator
      - AllegroFlare::Logger


  - name: initialize
    guards:
       - (!initialized)
       - al_is_system_installed()
       - al_is_primitives_addon_initialized()
       - al_is_font_addon_initialized()
       - bitmap_bin
       - font_bin
       - event_emitter
    body: |
      driver.initialize();
      //driver.active_character_staging_layout = new AllegroFlare::DialogSystem::CharacterStagingLayouts::BasicCentered();
      initialized = true;
      return;
    body_dependency_symbols:
      - al_is_primitives_addon_initialized
      - AllegroFlare::DialogSystem::CharacterStagingLayouts::BasicCentered


  - name: destroy
    body: |
      // TODO: This method requires consideration -- particularly active_speaker_layout which is currently owned
      // by this object. Also, this method will need to be called in Frameworks::Full
      driver.destroy();
      //delete driver.active_character_staging_layout;
      return;


  - name: switch_in
    guards: [ (!switched_in) ]
    body: |
      switched_in = true;
      return;


  - name: switch_out
    guards: [ (switched_in) ]
    body: |
      switched_in = false;
      return;


  - name: clear_character_staging_layout
    guards: [ initialized ]
    body: |
      if (driver.active_character_staging_layout->is_type(
               AllegroFlare::DialogSystem::CharacterStagingLayouts::BasicCentered::TYPE
            ))
      {
         AllegroFlare::DialogSystem::CharacterStagingLayouts::BasicCentered *as =
            static_cast<AllegroFlare::DialogSystem::CharacterStagingLayouts::BasicCentered*>(
               driver.active_character_staging_layout
            );
         as->clear_speaking_character_bitmap();
      }
      else
      {
         throw std::runtime_error(
            "DialogSystem::set_speaking_character: error: Unable to perform action because "
               "\"driver.active_character_staging_layout\" is of type \"" + driver.active_character_staging_layout->get_type() + "\" "
               "and a condition is not provided to handle this type."
         );
      }
      return;


  - name: set_speaking_character_avatar
    guards: [ initialized ]
    parameters:
      - name: speaking_character_identifier
        type: std::string
        default_argument: '"[unset-speaking_character_identifier]"'
      - name: speaking_character_expression
        type: std::string
        default_argument: '"[unset-speaking_character_expression]"'
    guards: [ driver.active_character_staging_layout, (speaking_character_identifier.empty()) ]
    body: |
      if (driver.active_character_staging_layout->is_type(
               AllegroFlare::DialogSystem::CharacterStagingLayouts::BasicCentered::TYPE
            ))
      {
         AllegroFlare::DialogSystem::CharacterStagingLayouts::BasicCentered *as =
            static_cast<AllegroFlare::DialogSystem::CharacterStagingLayouts::BasicCentered*>(
               driver.active_character_staging_layout
            );
         ALLEGRO_BITMAP *speaking_character_bitmap = lookup_speaking_character_avatar(
               speaking_character_identifier,
               speaking_character_expression
            );
         if (!speaking_character_bitmap) as->clear_speaking_character_bitmap();
         else as->set_speaking_character_bitmap(speaking_character_bitmap);
         // TODO: Set the character
      }
      else
      {
         throw std::runtime_error(
            "DialogSystem::set_speaking_character: error: Unable to perform action because "
               "\"driver.active_character_staging_layout\" is of type \"" + driver.active_character_staging_layout->get_type() + "\" "
               "and a condition is not provided to handle this type."
         );
      }
      return;


  - name: lookup_speaking_character_avatar
    type: ALLEGRO_BITMAP*
    parameters:
      - name: speaking_character_identifier
        type: std::string
        default_argument: '"[unset-speaking_character_identifier]"'
      - name: speaking_character_expression
        type: std::string
        default_argument: '"[unset-speaking_character_expression]"'
    guards: [ bitmap_bin ]
    body: |
      if (driver.character_roster)
      {
         if (!driver.character_roster->character_exists_by_name(speaking_character_identifier))
         {
            // Throw for now
            std::stringstream available_character_names;
            available_character_names << "[ ";
            for (auto &character_identifier : driver.character_roster->get_character_names())
            {
               available_character_names << "\"" << character_identifier << "\", ";
            }
            available_character_names << " ]";

            throw std::runtime_error("Roster is present, but character \"" + speaking_character_identifier + "\" "
                                     "does not exist in roster. Available names are " + available_character_names.str()
                                     );
         }

         AllegroFlare::DialogSystem::Characters::Base *base =
            driver.character_roster->find_character_by_name(speaking_character_identifier);

         if (base->is_type(AllegroFlare::DialogSystem::Characters::Basic::TYPE))
         {
            AllegroFlare::DialogSystem::Characters::Basic *as =
               static_cast<AllegroFlare::DialogSystem::Characters::Basic*>(base);

            std::string bitmap_identifier_to_use = "";
            if (as->expression_exists(speaking_character_expression))
            {
               bitmap_identifier_to_use = as->find_expression(speaking_character_expression);
            }
            else
            {
               // TODO: Add report about missing expression
               bitmap_identifier_to_use = as->get_avatar_portrait_identifier();
            }

            return bitmap_bin->auto_get(bitmap_identifier_to_use);
         }
         else
         {
            throw std::runtime_error("DialogSystem: unknown handled character type");
         }
      }
      return nullptr;
    body_dependency_symbols:
      - AllegroFlare::DialogSystem::Characters::Basic


  - name: activate_dialog_node_by_name
    parameters:
      - name: dialog_name
        type: std::string
        default_argument: '"[unset-dialog_name]"'
    body: |
      active_dialog_node = dialog_node_bank.find_node_by_name(dialog_name);
      active_dialog_node_name = dialog_name;
      if (active_dialog_node_state)
      {
         delete active_dialog_node_state;
         active_dialog_node_state = nullptr;
      }

      if (activate_dialog_node_by_name_func)
      {
         bool handled = activate_dialog_node_by_name_func(
               this,
               active_dialog_node_name,
               active_dialog_node,
               activate_dialog_node_by_name_func_user_data
            );

         if (!handled)
         {
            throw std::runtime_error(
                  "DialogSystem::activate_dialog_node_by_name: error: a user \"activate_dialog_node_by_name_func\" has "
                     "been provided, but it returned false when called, indicating that it was not able to handle the "
                     "node activation."
               );
         }
      }
      else if (active_dialog_node->is_type(AllegroFlare::DialogTree::Nodes::MultipageWithOptions::TYPE))
      {
         AllegroFlare::DialogTree::Nodes::MultipageWithOptions *as_multipage_with_options =
            static_cast<AllegroFlare::DialogTree::Nodes::MultipageWithOptions*>(active_dialog_node);

         std::string node_pages_speaker = as_multipage_with_options->get_speaker();
         std::vector<std::string> node_pages = as_multipage_with_options->get_pages();
         std::vector<std::string> node_options_as_text = as_multipage_with_options->build_options_as_text();

         if (node_options_as_text.empty())
         {
            throw std::runtime_error(
               "DialogSystem::activate_dialog_node_by_name: error: Expecting 1 or many options for node named \""
                  + dialog_name + "\" but there are no options."
            );
         }
         else if (node_options_as_text.size() == 1)
         {
            // If dialog has only one option, spawn a basic dialog
            set_speaking_character_avatar(node_pages_speaker);
            spawn_basic_dialog(node_pages_speaker, node_pages);
            //append_to_dialog_roll(node_pages_speaker, node_pages[0]); // TODO: join(node_pages);
         }
         else // (node_options_as_text.size() > 1)
         {
            // TODO: Here, if dialog has multiple options, spawn a "choice" dialog
            if (node_pages.size() != 1)
            {
               throw std::runtime_error(
                  "DialogSystem::activate_dialog_node_by_name: error: Expecting only 1 page for dialog node \""
                     + dialog_name + "\" (because it is going to be used to build a Choice dialog, "
                     "but there are \"" + std::to_string(node_pages.size()) + "\" pages."
               );
            }
            set_speaking_character_avatar(node_pages_speaker);
            spawn_choice_dialog(node_pages_speaker, node_pages[0], node_options_as_text);
            //append_to_dialog_roll(node_pages_speaker, node_pages[0]); // TODO: join(node_pages);
         }
      }
      else if (active_dialog_node->is_type(AllegroFlare::DialogTree::Nodes::Wait::TYPE))
      {
         // Cast our class
         AllegroFlare::DialogTree::Nodes::Wait *as =
            static_cast<AllegroFlare::DialogTree::Nodes::Wait*>(active_dialog_node);

         // Create a new state for this node
         AllegroFlare::DialogSystem::NodeStates::Wait *wait_node_state =
               new AllegroFlare::DialogSystem::NodeStates::Wait(as);
         wait_node_state->initialize();

         // Assign the state to our "active_dialog_node_state" so it can be managed
         active_dialog_node_state = wait_node_state;
      }
      else if (active_dialog_node->is_type(AllegroFlare::DialogTree::Nodes::ExitDialog::TYPE))
      {
         //AllegroFlare::DialogTree::Nodes::ExitDialog *as =
            //static_cast<AllegroFlare::DialogTree::Nodes::ExitDialog*>(base);
         shutdown_dialog(); // TODO: See if this is a correct expectation for this event
      }
      else if (active_dialog_node->is_type(AllegroFlare::DialogTree::Nodes::ExitProgram::TYPE))
      {
         // TODO: Test this event emission
         event_emitter->emit_exit_game_event();
         // TODO: Exit program (either set shutdown_system on framework or emit event)
      }
      else
      {
         bool handled = false;
         if (activate_dialog_node_type_unhandled_func)
         {
            handled = activate_dialog_node_type_unhandled_func(
                  this,
                  activate_dialog_node_type_unhandled_func_user_data
            );
         }

         if (!handled)
         {
            throw std::runtime_error(
               "DialogSystem::activate_dialog_node_by_name: error: Unable to handle dialog node activation on type \""
                  + active_dialog_node->get_type() + "\". A condition is not provided to handle this type."
            );
         }
      }
      return;
    body_dependency_symbols:
     - AllegroFlare::DialogTree::Nodes::MultipageWithOptions
     - AllegroFlare::DialogTree::Nodes::ExitDialog
     - AllegroFlare::DialogTree::Nodes::ExitProgram
     - AllegroFlare::DialogTree::Nodes::Wait
     - AllegroFlare::DialogSystem::NodeStates::Wait


  - name: spawn_basic_dialog
    parameters:
      - name: speaking_character
        type: std::string
        default_argument: '"[unset-speaking_character]"'
      - name: pages
        type: std::vector<std::string>
        default_argument: '{}'
    body: |
      bool a_dialog_existed_before = a_dialog_is_active();
      if (active_dialog_box) delete active_dialog_box; // TODO: address concern that this could clobber an active dialog
                                                       // And/or address concerns that derived dialog be deleted proper

      AllegroFlare::Elements::DialogBoxFactory dialog_box_factory;
      active_dialog_box = dialog_box_factory.create_basic_dialog(speaking_character, pages);

      // TODO: Address when and where a switch_in should occur
      bool a_new_dialog_was_created_and_dialog_system_is_now_active = !a_dialog_existed_before;
      if (a_new_dialog_was_created_and_dialog_system_is_now_active)
      {
         switch_in();
         driver.active_character_staging_layout->show(); // TODO: Test the show occurs
         event_emitter->emit_dialog_switch_in_event();
      }
      return;
    body_dependency_symbols:
      - AllegroFlare::Elements::DialogBoxFactory


  - name: spawn_choice_dialog
    parameters:
      - name: speaking_character
        type: std::string
        default_argument: '"[unset-speaking_character]"'
      - name: prompt
        type: std::string
        default_argument: '"[unset-prompt]"'
      - name: options
        type: std::vector<std::string>
        default_argument: '{}'
    body: |
      bool a_dialog_existed_before = a_dialog_is_active();
      if (active_dialog_box) delete active_dialog_box; // TODO: address concern that this could clobber an active dialog

      // NOTE: In order to be compatable with "create_choice_dialog", we will fill with some dummy values.
      // For now, we use the cursor position of the choice dialog to pick the option. Consider revising or cleaning up
      std::vector<std::pair<std::string, std::string>> options_that_are_also_values;
      for (auto &option : options)
      {
         options_that_are_also_values.push_back({option, option});
      }

      AllegroFlare::Elements::DialogBoxFactory dialog_box_factory;
      AllegroFlare::Elements::DialogBoxes::Choice *choice_dialog_box =
            dialog_box_factory.create_choice_dialog(speaking_character, prompt, options_that_are_also_values);
      active_dialog_box = choice_dialog_box;


      // Set the cursor selection box position to this point
      AllegroFlare::Elements::DialogBoxRenderers::ChoiceRenderer choice_renderer_for_dimensions(
         font_bin,
         bitmap_bin,
         choice_dialog_box
      );

      std::tuple<float, float, float, float> selection_dimensions =
            choice_renderer_for_dimensions.calculate_dimensions_of_current_selection();
      choice_renderer_for_dimensions.helper__set_selection_cursor_box_dimensions_to(
            &selection_cursor_box,
            selection_dimensions
         );

      // TODO: Address when and where a switch_in should occur
      bool a_new_dialog_was_created_and_dialog_system_is_now_active = !a_dialog_existed_before;
      if (a_new_dialog_was_created_and_dialog_system_is_now_active)
      {
         switch_in();
         driver.active_character_staging_layout->show(); // TODO: Test the show occurs
         event_emitter->emit_dialog_switch_in_event();
      }
      return;
    body_dependency_symbols:
      - AllegroFlare::Elements::DialogBoxFactory
      - AllegroFlare::Elements::DialogBoxRenderers::ChoiceRenderer


  - name: update
    parameters:
      - name: time_now
        type: float
        default_argument: 0
    guards: [ initialized ]
    body: |
      // TODO: Ensure time_now does not accidentally become 0 by not being noticed as an argument
      // TODO: Ensure time_now is passed down to active dialog updates()
      // TODO: Consider if ordering of events is correct
      if (active_dialog_box) active_dialog_box->update();
      selection_cursor_box.update();
      if (active_dialog_node_state) active_dialog_node_state->update(); // TODO: Pass down time_now

      evaluate_auto_advance_on_dialog_node_state();

      return;


  - name: evaluate_auto_advance_on_dialog_node_state
    guards: [ initialized ]
    body: |
      if (!active_dialog_node_state) return;

      if (active_dialog_node_state->is_type(AllegroFlare::DialogSystem::NodeStates::Wait::TYPE))
      {
         AllegroFlare::DialogSystem::NodeStates::Wait *as =
            static_cast<AllegroFlare::DialogSystem::NodeStates::Wait*>(active_dialog_node_state);
         if (as->get_is_finished())
         {
            activate_dialog_node_by_name(as->get_wait_node()->get_next_node_identifier());
         }
      }
      // TODO: Consider using blacklist for items that are handled, but have no behavior
      // TODO: Consider throwing on unhandled type
      // TODO: Consider user callback for handling unknown node state type

      return;


  - name: render
    type: void
    guards: [ initialized ]
    body: |
      if (driver.active_character_staging_layout)
      {
         driver.active_character_staging_layout->render();
      }

      if (active_dialog_box)
      {
         AllegroFlare::Elements::DialogBoxRenderer dialog_box_renderer(
               font_bin,
               bitmap_bin,
               active_dialog_box,
               &selection_cursor_box
            );
         dialog_box_renderer.set_standard_dialog_box_font_name(standard_dialog_box_font_name);
         dialog_box_renderer.set_standard_dialog_box_font_size(standard_dialog_box_font_size);
         dialog_box_renderer.render();
      }
    body_dependency_symbols:
      - AllegroFlare::Elements::DialogBoxRenderer


  - name: a_dialog_is_active
    type: bool
    body: |
      return (active_dialog_box != nullptr);


  - name: dialog_advance
    guards: [ initialized, active_dialog_box ]
    body: |
      active_dialog_box->advance();
      if (active_dialog_box->get_finished())
      {
         if (active_dialog_node)
         {
            if (active_dialog_node->is_type(AllegroFlare::DialogTree::Nodes::MultipageWithOptions::TYPE))
            {
               AllegroFlare::DialogTree::Nodes::MultipageWithOptions *as_multipage_with_options =
                  static_cast<AllegroFlare::DialogTree::Nodes::MultipageWithOptions*>(active_dialog_node);

               if (as_multipage_with_options->num_options() == 0)
               {
                  // If this dialog node has no options, then proceed to a "shutdown" state

                  // TODO: Replace this throw with a shutdown
                  throw std::runtime_error(
                     "DialogSystem::dialog_advance: error: Expecting 1 or many options for node named \""
                        + active_dialog_node_name + "\" but there are no options."
                  );
               }
               else if (as_multipage_with_options->num_options() == 1)
               {
                  // If the dialog node has 1 option, "activate" it
                  int current_dialog_selection_choice = 0;
                  activate_dialog_option(current_dialog_selection_choice);
               }
               else // if (as_multipage_with_options.num_options() > 1)
               {
                  // If the dialog *node* has more than 1 option, correlate the dialog *box*'s current cursor position
                     // with the result and "activate" it
                  if (!active_dialog_box->is_type(AllegroFlare::Elements::DialogBoxes::Choice::TYPE))
                  {
                     throw std::runtime_error(
                        "DialogSystem::dialog_advance: error: Expecting active_dialog_box (with more than one option) "
                           "to be of type \"AllegroFlare::Elements::DialogBoxes::Choice::TYPE\", but it is of type \""
                           + active_dialog_box->get_type() + "\""
                     );
                  }
                  else
                  {
                     AllegroFlare::Elements::DialogBoxes::Choice *as_choice_dialog_box = 
                        static_cast<AllegroFlare::Elements::DialogBoxes::Choice*>(active_dialog_box);

                     int current_dialog_selection_choice = as_choice_dialog_box->get_cursor_position();
                     activate_dialog_option(current_dialog_selection_choice);
                  }
               }
            }
            //else if (active_dialog_node->is_type(AllegroFlare::DialogTree::Nodes::Wait::TYPE))
            //{
               //AllegroFlare::DialogTree::Nodes::Wait *as =
                     //static_cast<AllegroFlare::DialogTree::Nodes::Wait*>(active_dialog_node);
               //if (as->get_is_finished())
               //{
                  //activate_dialog_node_by_name(as->get_next_node_identifier());
               //}
            //}
            //else if (active_dialog_node->is_type(AllegroFlare::DialogTree::Nodes::ExitDialog::TYPE))
            //{
               //AllegroFlare::DialogTree::Nodes::ExitDialog *as =
                  //static_cast<AllegroFlare::DialogTree::Nodes::ExitDialog*>(base);
               //shutdown_dialog(); // TODO: See if this is a correct expectation for this event
            //}
            else
            {
               bool handled = false;
               if (dialog_advance_is_finished_node_type_unhandled_func)
               {
                  handled = dialog_advance_is_finished_node_type_unhandled_func(
                        this,
                        active_dialog_box,
                        active_dialog_node,
                        dialog_advance_is_finished_node_type_unhandled_func_user_data
                     );
               }

               if (!handled)
               {
                  throw std::runtime_error(
                     "DialogSystem::dialog_advance: error: Unable to handle case where dialog *box* is finished when "
                        "the dialog *node* type \""
                        + active_dialog_node->get_type() + "\". A condition is not provided to handle this type."
                  );
                  //throw std::runtime_error(
                     //"DialogSystem::activate_dialog_node_by_name: error: Unable to handle dialog node activation on type \""
                        //+ active_dialog_node->get_type() + "\". A condition is not provided to handle this type."
                  //);
               }

               //throw std::runtime_error(
                  //"DialogSystem::dialog_advance: error: Unable to handle case where dialog *box* is finished when "
                     //"the dialog *node* type \""
                     //+ active_dialog_node->get_type() + "\". A condition is not provided to handle this type."
               //);
            }
         }

         // TODO: Figure out what to do when the dialog is finished.
      }
      return;
    body_dependency_symbols:
      - AllegroFlare::Elements::DialogBoxes::Choice
      - AllegroFlare::DialogTree::Nodes::ExitDialog


  - name: activate_dialog_option
    type: void
    parameters:
      - name: selection_choice
        type: int
        default_argument: 0
    guards:
      - event_emitter
      - active_dialog_node
    body: |
      if (active_dialog_node->is_type(AllegroFlare::DialogTree::Nodes::MultipageWithOptions::TYPE))
      {

         AllegroFlare::DialogTree::Nodes::MultipageWithOptions *as_multipage_with_options =
            static_cast<AllegroFlare::DialogTree::Nodes::MultipageWithOptions*>(active_dialog_node);

         // TODO: Consider case where dialog node has no (empty) options
         if (!(selection_choice >= 0))
         {
            throw std::runtime_error(
               "DialogSystem::activate_dialog_option: error: selection_choice must be >= 0"
            );
         }
         if (!(selection_choice < as_multipage_with_options->num_options()))
         {
            throw std::runtime_error(
               "DialogSystem::activate_dialog_option: error: selection_choice must be less than the num options"
            );
         }

         AllegroFlare::DialogTree::NodeOptions::Base* node_option =
            as_multipage_with_options->get_option_num(selection_choice).second;
         std::string node_option_type = node_option->get_type();
   
         std::map<std::string, std::function<void()>> types_map = {
            { AllegroFlare::DialogTree::NodeOptions::ExitDialog::TYPE, [this, node_option]() {
               AllegroFlare::DialogTree::NodeOptions::ExitDialog* as_exit_dialog_node_option =
                  static_cast<AllegroFlare::DialogTree::NodeOptions::ExitDialog*>(node_option);

               //event_emitter->emit_dialog_close_event();
               shutdown_dialog(); // TODO: See if this is a correct expectation for this event
            }},
            { AllegroFlare::DialogTree::NodeOptions::GoToNode::TYPE, [this, node_option]() {
               // TODO: Test this case
               AllegroFlare::DialogTree::NodeOptions::GoToNode* as_go_to_node_dialog_node_option =
                  static_cast<AllegroFlare::DialogTree::NodeOptions::GoToNode*>(node_option);
               std::string target_node_name = as_go_to_node_dialog_node_option->get_target_node_name();

               //event_emitter->emit_dialog_open_event(target_node_name);
               activate_dialog_node_by_name(target_node_name);
            }},
         };

         // locate and call the function to handle the item
         if (types_map.count(node_option_type) == 0)
         {
            // item not found
            std::stringstream error_message;
            error_message << "[DialogTree::NodeOptionActivator::activate]: error: Cannot activate a node with the "
                          << "node_option_type \"" << node_option_type << "\", a handling for that type does not exist.";
            throw std::runtime_error(error_message.str());
         }
         else
         {
            // call the item
            types_map[node_option_type]();
         }
      }
      else
      {
         throw std::runtime_error(
            "DialogSystem::activate_dialog_option: error: Unable to handle case where dialog *node* is of type \""
               + active_dialog_node->get_type() + "\"."
         );
      }

      return;
    body_dependency_symbols:
      - std::function
      - AllegroFlare::DialogTree::NodeOptions::ExitDialog
      - AllegroFlare::DialogTree::NodeOptions::GoToNode


  - name: dialog_is_finished
    type: bool
    guards: [ initialized, active_dialog_box ]
    body: |
      return active_dialog_box->get_finished();


  - name: shutdown_dialog
    type: bool
    guards: [ initialized ]
    body: |
      if (!active_dialog_box) return false;
      delete active_dialog_box; // TODO: Consider a less intrusive soft delete (hide motion, with cleanup during update)
      active_dialog_box = nullptr;

      active_dialog_node = nullptr;
      active_dialog_node_name = "";

      if (driver.active_character_staging_layout)
      {
         // TODO: Confirm "hide" should occur here
         driver.active_character_staging_layout->hide(); // TODO: Test this hide occurs as expected
      }

      // NOTE: Note that active_dialog_node is not deleted, because any pointer to a dialog node is a pointer
      // to one that is static in the dialog_node_bank
      if (get_switched_in())
      {
         switch_out();
         event_emitter->emit_dialog_switch_out_event();
      }
      return true;


  - name: move_dialog_cursor_position_up
    guards: [ initialized ]
    body: |
      if (!active_dialog_box) return;
      active_dialog_box->move_cursor_position_up();
      if (active_dialog_box->is_type(AllegroFlare::Elements::DialogBoxes::Choice::TYPE))
      {
         AllegroFlare::Elements::DialogBoxes::Choice *as_choice_dialog_box =
               static_cast<AllegroFlare::Elements::DialogBoxes::Choice*>(active_dialog_box);

         // Set the cursor selection box position to this point
         AllegroFlare::Elements::DialogBoxRenderers::ChoiceRenderer choice_renderer_for_dimensions(
            font_bin,
            bitmap_bin,
            as_choice_dialog_box
         );

         std::tuple<float, float, float, float> selection_dimensions =
               choice_renderer_for_dimensions.calculate_dimensions_of_current_selection();
         choice_renderer_for_dimensions.helper__reposition_selection_cursor_box_dimensions_to(
               &selection_cursor_box,
               selection_dimensions
            );
      }
      return;


  - name: move_dialog_cursor_position_down
    guards: [ initialized ]
    body: |
      if (!active_dialog_box) return;
      active_dialog_box->move_cursor_position_down();
      // TODO: Reposition the cursor
      if (active_dialog_box->is_type(AllegroFlare::Elements::DialogBoxes::Choice::TYPE))
      {
         AllegroFlare::Elements::DialogBoxes::Choice *as_choice_dialog_box =
               static_cast<AllegroFlare::Elements::DialogBoxes::Choice*>(active_dialog_box);

         // Set the cursor selection box position to this point
         AllegroFlare::Elements::DialogBoxRenderers::ChoiceRenderer choice_renderer_for_dimensions(
            font_bin,
            bitmap_bin,
            as_choice_dialog_box
         );

         std::tuple<float, float, float, float> selection_dimensions =
               choice_renderer_for_dimensions.calculate_dimensions_of_current_selection();
         choice_renderer_for_dimensions.helper__reposition_selection_cursor_box_dimensions_to(
               &selection_cursor_box,
               selection_dimensions
            );
      }
      return;


  - name: handle_raw_ALLEGRO_EVENT_that_is_dialog_event
    parameters:
      - name: ev
        type: ALLEGRO_EVENT*
        default_argument: nullptr
      - name: data
        type: AllegroFlare::GameEventDatas::Base*
        default_argument: nullptr
    guards: [ ev, data ]
    body: |
      // TODO: Update this to a map caller pattern (static const)
      if (data->is_type(AllegroFlare::DialogSystem::DialogEventDatas::LoadDialogNodeBankFromFile::TYPE))
      {
         auto *as = static_cast<AllegroFlare::DialogSystem::DialogEventDatas::LoadDialogNodeBankFromFile*>(data);
         load_dialog_node_bank_from_file(as->get_yaml_filename());
      }
      // TODO: Rename this SpawnDialogByName to ActivateDialogNodeByName
      else if (data->is_type(AllegroFlare::DialogSystem::DialogEventDatas::SpawnDialogByName::TYPE))
      {
         auto *as = static_cast<AllegroFlare::DialogSystem::DialogEventDatas::SpawnDialogByName*>(data);
         activate_dialog_node_by_name(as->get_name());
      }
      else
      {
         AllegroFlare::Logger::throw_error(
               "AllegroFlare::DialogSystem::DialogSystem::handle_raw_ALLEGRO_EVENT_that_is_dialog_event",
               "Unhandled case on type \"" + data->get_type() + "\"."
            );
      }
      return;
    body_dependency_symbols:
      - AllegroFlare::DialogSystem::DialogEventDatas::SpawnDialogByName
      - AllegroFlare::DialogSystem::DialogEventDatas::LoadDialogNodeBankFromFile


dependencies:


  - symbol: AllegroFlare::DialogSystem::DialogSystem
    headers: [ ]
  - symbol: ALLEGRO_BITMAP
    headers: [ allegro5/allegro.h ]
  - symbol: ALLEGRO_EVENT
    headers: [ allegro5/allegro.h ]
  - symbol: al_is_primitives_addon_initialized
    headers: [ allegro5/allegro_primitives.h ]
  - symbol: AllegroFlare::FontBin
    headers: [ AllegroFlare/FontBin.hpp ]
  - symbol: AllegroFlare::EventNames
    headers: [ AllegroFlare/EventNames.hpp ]
  - symbol: AllegroFlare::DialogSystem::DialogEventDatas::CloseDialog
    headers: [ AllegroFlare/DialogSystem/DialogEventDatas/CloseDialog.hpp ]
  - symbol: AllegroFlare::Elements::DialogBoxes::YouGotEvidence
    headers: [ AllegroFlare/Elements/DialogBoxes/YouGotEvidence.hpp ]
  - symbol: AllegroFlare::Elements::DialogBoxes::Base
    headers: [ AllegroFlare/Elements/DialogBoxes/Base.hpp ]
  - symbol: AllegroFlare::Elements::DialogBoxes::Choice
    headers: [ AllegroFlare/Elements/DialogBoxes/Choice.hpp ]
  - symbol: AllegroFlare::GameEvent
    headers: [ AllegroFlare/GameEvent.hpp ]
  - symbol: AllegroFlare::GameEventDatas::Base
    headers: [ AllegroFlare/GameEventDatas/Base.hpp ]
  - symbol: AllegroFlare::Elements::DialogBoxRenderer
    headers: [ AllegroFlare/Elements/DialogBoxRenderer.hpp ]
  - symbol: AllegroFlare::BitmapBin
    headers: [ AllegroFlare/BitmapBin.hpp ]
  - symbol: AllegroFlare::Elements::DialogBoxes::Basic
    headers: [ AllegroFlare/Elements/DialogBoxes/Basic.hpp ]
  - symbol: AllegroFlare::Elements::DialogBoxes::YouGotAnItem
    headers: [ AllegroFlare/Elements/DialogBoxes/YouGotAnItem.hpp ]
  - symbol: AllegroFlare::Elements::DialogBoxes::YouGotAnItem
    headers: [ AllegroFlare/Elements/DialogBoxes/YouGotAnItem.hpp ]
  - symbol: AllegroFlare::InventoryDictionaryItems::WithAttributes
    headers: [ AllegroFlare/InventoryDictionaryItems/WithAttributes.hpp ]
  - symbol: AllegroFlare::Elements::DialogBoxFactory
    headers: [ AllegroFlare/Elements/DialogBoxFactory.hpp ]
  - symbol: AllegroFlare::DialogSystem::DialogEventDatas::CreateYouGotAnItemDialog
    headers: [ AllegroFlare/DialogSystem/DialogEventDatas/CreateYouGotAnItemDialog.hpp ]
  - symbol: AllegroFlare::DialogSystem::DialogEventDatas::CreateYouGotEvidenceDialog
    headers: [ AllegroFlare/DialogSystem/DialogEventDatas/CreateYouGotEvidenceDialog.hpp ]
  - symbol: AllegroFlare::EventEmitter
    headers: [ AllegroFlare/EventEmitter.hpp ]
  - symbol: AllegroFlare::DialogTree::NodeBank
    headers: [ AllegroFlare/DialogTree/NodeBank.hpp ]
  - symbol: AllegroFlare::DialogTree::Nodes::Base
    headers: [ AllegroFlare/DialogTree/Nodes/Base.hpp ]
  - symbol: std::filesystem::exists
    headers: [ filesystem ]
  - symbol: AllegroFlare::DialogTree::NodeOptions::GoToNode
    headers: [ AllegroFlare/DialogTree/NodeOptions/GoToNode.hpp ]
  - symbol: AllegroFlare::DialogTree::NodeOptions::ExitDialog
    headers: [ AllegroFlare/DialogTree/NodeOptions/ExitDialog.hpp ]
  - symbol: AllegroFlare::DialogTree::Nodes::MultipageWithOptions
    headers: [ AllegroFlare/DialogTree/Nodes/MultipageWithOptions.hpp ]
  - symbol: AllegroFlare::Elements::SelectionCursorBox
    headers: [ AllegroFlare/Elements/SelectionCursorBox.hpp ]
  - symbol: AllegroFlare::Elements::DialogBoxRenderers::ChoiceRenderer
    headers: [ AllegroFlare/Elements/DialogBoxRenderers/ChoiceRenderer.hpp ]
  - symbol: AllegroFlare::DialogSystem::DialogEventDatas::SpawnDialogByName
    headers: [ AllegroFlare/DialogSystem/DialogEventDatas/SpawnDialogByName.hpp ]
  - symbol: AllegroFlare::DialogSystem::DialogEventDatas::LoadDialogNodeBankFromFile
    headers: [ AllegroFlare/DialogSystem/DialogEventDatas/LoadDialogNodeBankFromFile.hpp ]
  - symbol: AllegroFlare::DialogSystem::CharacterStagingLayouts::Base
    headers: [ AllegroFlare/DialogSystem/CharacterStagingLayouts/Base.hpp ]
  - symbol: AllegroFlare::DialogSystem::CharacterStagingLayouts::BasicCentered
    headers: [ AllegroFlare/DialogSystem/CharacterStagingLayouts/BasicCentered.hpp ]
  - symbol: AllegroFlare::DialogSystem::CharacterRoster
    headers: [ AllegroFlare/DialogSystem/CharacterRoster.hpp ]
  - symbol: AllegroFlare::DialogSystem::Characters::Basic
    headers: [ AllegroFlare/DialogSystem/Characters/Basic.hpp ]
  - symbol: AllegroFlare::StringFormatValidator
    headers: [ AllegroFlare/StringFormatValidator.hpp ]
  - symbol: AllegroFlare::DialogTree::BasicScreenplayTextLoader
    headers: [ AllegroFlare/DialogTree/BasicScreenplayTextLoader.hpp ]
  - symbol: AllegroFlare::Logger
    headers: [ AllegroFlare/Logger.hpp ]
  - symbol: AllegroFlare::UsefulPHP
    headers: [ AllegroFlare/UsefulPHP.hpp ]
  - symbol: AllegroFlare::DialogTree::Nodes::ExitDialog
    headers: [ AllegroFlare/DialogTree/Nodes/ExitDialog.hpp ]
  - symbol: AllegroFlare::DialogTree::Nodes::ExitProgram
    headers: [ AllegroFlare/DialogTree/Nodes/ExitProgram.hpp ]
  - symbol: AllegroFlare::Elements::DialogRoll
    headers: [ AllegroFlare/Elements/DialogRoll.hpp ]
  - symbol: AllegroFlare::DialogTree::Nodes::Wait
    headers: [ AllegroFlare/DialogTree/Nodes/Wait.hpp ]
  - symbol: AllegroFlare::DialogSystem::NodeStates::Base
    headers: [ AllegroFlare/DialogSystem/NodeStates/Base.hpp ]
  - symbol: AllegroFlare::DialogSystem::NodeStates::Wait
    headers: [ AllegroFlare/DialogSystem/NodeStates/Wait.hpp ]
  - symbol: AllegroFlare::DialogSystemDrivers::BasicCharacterDialogDriver
    headers: [ AllegroFlare/DialogSystemDrivers/BasicCharacterDialogDriver.hpp ]


