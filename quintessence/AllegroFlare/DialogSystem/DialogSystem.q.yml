properties:


  - name: bitmap_bin
    type: AllegroFlare::BitmapBin*
    init_with: nullptr
    constructor_arg: true
    setter: explicit

  - name: font_bin
    type: AllegroFlare::FontBin*
    init_with: nullptr
    constructor_arg: true
    setter: explicit

  - name: event_emitter
    type: AllegroFlare::EventEmitter*
    init_with: nullptr
    constructor_arg: true
    setter: explicit
    getter: true

  - name: dialog_node_bank
    type: AllegroFlare::DialogTree::NodeBank
    init_with: '{}'
    getter: true
    setter: explicit

  - name: active_dialog_box
    type: AllegroFlare::Elements::DialogBoxes::Base*
    init_with: nullptr

  - name: selection_cursor_box
    type: AllegroFlare::Elements::SelectionCursorBox
    init_with: '{}'

  - name: active_dialog_node
    type: AllegroFlare::DialogTree::Nodes::Base*
    init_with: nullptr

  - name: active_dialog_node_name
    type: std::string
    init_with: '"[unset-active_dialog_node_name]"'
    getter: true

  - name: driver
    type: AllegroFlare::DialogSystemDrivers::Base*
    init_with: nullptr
    getter_ref: true
    getter: true
    setter: explicit

  - name: switched_in
    type: bool
    init_with: false
    getter: true

  - name: standard_dialog_box_font_name
    type: std::string
    init_with: DEFAULT_STANDARD_DIALOG_BOX_FONT_NAME
    getter: true
    setter: true

  - name: standard_dialog_box_font_size
    type: int
    init_with: DEFAULT_STANDARD_DIALOG_BOX_FONT_SIZE
    getter: true
    setter: true

  - name: standard_dialog_box_x
    type: float
    init_with: DEFAULT_STANDARD_DIALOG_BOX_X
    getter: true
    setter: true

  - name: standard_dialog_box_y
    type: float
    init_with: DEFAULT_STANDARD_DIALOG_BOX_Y
    getter: true
    setter: true

  - name: standard_dialog_box_width
    type: float
    init_with: DEFAULT_STANDARD_DIALOG_BOX_WIDTH
    getter: true
    setter: true

  - name: standard_dialog_box_height
    type: float
    init_with: DEFAULT_STANDARD_DIALOG_BOX_HEIGHT
    getter: true
    setter: true

  - name: initialized
    type: bool
    init_with: false
    getter: true

  - name: DEFAULT_STANDARD_DIALOG_BOX_FONT_NAME
    type: char*
    constexpr: true
    const: true
    static: true
    init_with: '(char*)"Inter-Regular.ttf"'

  - name: DEFAULT_STANDARD_DIALOG_BOX_FONT_SIZE
    type: int
    constexpr: true
    const: true
    static: true
    init_with: -36

  - name: DEFAULT_STANDARD_DIALOG_BOX_X
    type: float
    constexpr: true
    const: true
    static: true
    init_with: 1920/2.0f

  - name: DEFAULT_STANDARD_DIALOG_BOX_Y
    type: float
    constexpr: true
    const: true
    static: true
    init_with: 1080/8.0f*6

  - name: DEFAULT_STANDARD_DIALOG_BOX_WIDTH
    type: float
    constexpr: true
    const: true
    static: true
    init_with: 1920/2.0f

  - name: DEFAULT_STANDARD_DIALOG_BOX_HEIGHT
    type: float
    constexpr: true
    const: true
    static: true
    init_with: 1080/5.0f


documentation:


  - notes:
     - Consider this class mostly frozen for extending features, except in the following cases:
       - New standard dialog types and logic to handle them and/or spawn them
       - Additional "on_thing_that_happend" callbacks to the driver.
     - Any additional features (emitting some consequential event, etc) would be handled in the driver
  - todo:
     - Having different drivers would move us closer to switching dialogs in and out (maybe a push/pop mechanism)
     - Right now there is no consequence on the driver when the dialog_node_bank is set. It's uncertain what events
       would need to occour.
  - leftover todos:
     - modify process_dialog_event to branch based on the ALLEGRO_FLARE_EVENT_DIALOG_* event
     - remove ALLEGRO_FLARE_OPEN_DIALOG, etc from EventEmitter type events that are no longer used
     - consider if you need to make GameEventDatas for each of the different types of events
     - review overall the integrety of the system, Add lots of tests
     - consider revising the arguments in "activate_dialog_node_by_name_func", and when/where the activation occurs
       in coordination with the assignment of the "active_dialog_node" and "active_dialog_node_name"
     - consider that dialog node options in MultipageWithOptions are probably not be deleted properly


methods:


  - name: set_bitmap_bin
    parameters:
      - name: bitmap_bin
        type: AllegroFlare::BitmapBin*
        default_argument: nullptr
    guards: [ (!initialized) ]
    body: |
      this->bitmap_bin = bitmap_bin;


  - name: set_font_bin
    parameters:
      - name: font_bin
        type: AllegroFlare::FontBin*
        default_argument: nullptr
    guards: [ (!initialized) ]
    body: |
      this->font_bin = font_bin;


  - name: set_event_emitter
    parameters:
      - name: event_emitter
        type: AllegroFlare::EventEmitter*
        default_argument: nullptr
    guards: [ (!initialized) ]
    body: |
      this->event_emitter = event_emitter;


  - name: set_driver
    parameters:
      - name: driver
        type: AllegroFlare::DialogSystemDrivers::Base*
        default_argument: nullptr
    body: |
      // TODO: Consider consequences of assigning the driver mid-flight
      this->driver = driver;


  - name: clear_and_reset
    body: |
      if (active_dialog_box)
      {
         delete active_dialog_box;
         active_dialog_box = nullptr;
      }

      // TODO: Hide selection cursor box (if showing)

      if (active_dialog_node)
      {
         active_dialog_node = nullptr;
      }

      dialog_node_bank.delete_all_nodes_and_clear();
      // TODO: Destroy dialog_node_bank

      active_dialog_node_name = "";
      return;


  - name: set_dialog_node_bank
    parameters:
      - name: dialog_node_bank
        type: AllegroFlare::DialogTree::NodeBank
        default_argument: '{}'
    body: |
      // TODO: Test the expected conditions when calling "set_dialog_node_bank" after init and/or when the node bank
      // is currently loaded (is it cleared? Does the active_dialog_box become nullptr, active_dialog_name empty, etc..)
      clear_and_reset(); // This step includes deleting all the nodes* in the node_bank
      this->dialog_node_bank = dialog_node_bank;


  - name: load_dialog_node_bank_from_file
    parameters:
      - name: filename
        type: std::string
        default_argument: '"[unset-filename]"'
    guards: [ driver ]
    body: |
      // TODO: Validate a dialog is not currently running (or something)

      AllegroFlare::DialogTree::NodeBank loader_result_node_bank;
      bool handled = driver->on_load_node_bank_from_file(
         filename,
         &loader_result_node_bank
      );

      if (!handled)
      {
         AllegroFlare::Logger::throw_error(
               "AllegroFlare::DialogSystem::DialogSystem::load_dialog_node_bank_from_file"
               // TODO: Update this error message
               "\"on_load_node_bank_from_file\" was called on the driver but it returned false, indicating "
                  "that it was not able to load the NodeBank as expected."
            );
      }

      set_dialog_node_bank(loader_result_node_bank);
      return;
    body_dependency_symbols:
      - AllegroFlare::UsefulPHP
      - AllegroFlare::DialogTree::BasicScreenplayTextLoader
      - AllegroFlare::StringFormatValidator
      - AllegroFlare::Logger


  - name: initialize
    guards:
       - (!initialized)
       - al_is_system_installed()
       - al_is_primitives_addon_initialized()
       - al_is_font_addon_initialized()
       - bitmap_bin
       - font_bin
       - event_emitter
    body: |
      initialized = true;
      return;
    body_dependency_symbols:
      - al_is_primitives_addon_initialized


  - name: destroy
    body: |
      // TODO: This method requires consideration -- particularly active_speaker_layout which is currently owned
      // by this object. Also, this method will need to be called in Frameworks::Full
      //if (_driver) _driver->destroy();
      //delete driver.active_character_staging_layout;
      return;


  - name: switch_in
    guards: [ (!switched_in) ]
    body: |
      switched_in = true;
      if (driver) driver->on_switch_in();
      event_emitter->emit_dialog_switch_in_event();
      return;


  - name: switch_in_if_not
    body: |
      if (!switched_in) switch_in();
      return;


  - name: switch_out
    guards: [ initialized, switched_in ]
    body: |
      if (active_dialog_box)
      {
         delete active_dialog_box; // TODO: Consider a less intrusive soft delete (hide motion, with cleanup during update)
         active_dialog_box = nullptr;
      }

      active_dialog_node = nullptr;
      active_dialog_node_name = "";

      if (driver) driver->on_switch_out(); // TODO: This may need to be moved to "switch_out"

      event_emitter->emit_dialog_switch_out_event();

      switched_in = false;
      return;


  - name: activate_dialog_node_by_name
    parameters:
      - name: dialog_name
        type: std::string
        default_argument: '"[unset-dialog_name]"'
    body: |
      active_dialog_node = dialog_node_bank.find_node_by_name(dialog_name);
      active_dialog_node_name = dialog_name;

      // NOTE: This function is responsible for interpreting a DialogSystem::Node* into an action.  In general
      // this method should not focus on translating the parameters/properties of the node to another, single function
      // call that is responsible for performing the action(s).  Avoid doing state-changing logic in this function
      // (unless those state changes are done in the called functions themselves.).  If you find functionality like
      // that here, consider extracting it to a function.

      //std::string &dialog_name = active_dialog_node_name;

      if (active_dialog_node->is_type(AllegroFlare::DialogTree::Nodes::EmitGameEvent::TYPE))
      {
         AllegroFlare::DialogTree::Nodes::EmitGameEvent *as =
            static_cast<AllegroFlare::DialogTree::Nodes::EmitGameEvent*>(active_dialog_node);
         event_emitter->emit_game_event(
            AllegroFlare::GameEvent(as->get_game_event_name(), nullptr) // For now, nullptr data
         );
         if (!as->get_immediate_next_node_identifier().empty())
         {
            // If the "immediate_next_node_identifier" is not blank, activate that node. Note that any
            // expected consequences of the emitted game event will not have had time to process before this
            // "immediate_next_node_identifier" is emitted
            activate_dialog_node_by_name(as->get_immediate_next_node_identifier());
         }
      }
      else if (active_dialog_node->is_type(AllegroFlare::DialogTree::Nodes::RawScriptLine::TYPE))
      {
         if (driver) driver->on_raw_script_line_activate( // could find a better name for this method
            this,
            active_dialog_node_name,
            active_dialog_node
         );
      }
      else if (active_dialog_node->is_type(AllegroFlare::DialogTree::Nodes::MultipageWithOptions::TYPE))
      {
         AllegroFlare::DialogTree::Nodes::MultipageWithOptions *as_multipage_with_options =
            static_cast<AllegroFlare::DialogTree::Nodes::MultipageWithOptions*>(active_dialog_node);

         std::string node_pages_speaker = as_multipage_with_options->get_speaker();
         std::vector<std::string> node_pages = as_multipage_with_options->get_pages();
         std::vector<std::string> node_options_as_text = as_multipage_with_options->build_options_as_text();
         int cursor_position_on_spawn = as_multipage_with_options->infer_cursor_position_on_spawn();

         if (node_options_as_text.empty())
         {
            throw std::runtime_error(
               "DialogSystem::DialogSystem::activate_dialog_node_by_name: error: Expecting 1 or many options for node named \""
                  + dialog_name + "\" but there are no options."
            );
         }
         else if (node_options_as_text.size() == 1)
         {
            // If dialog has only one option, spawn a basic dialog
            // TODO: Consider moving this call to _driver->on_before_spawn_choice_dialog into the "spawn_basic_dialog"
            if (driver) driver->on_before_spawn_basic_dialog(node_pages_speaker);
            spawn_basic_dialog(
               // TODO: Consider moving this call to _driver->decorate_speaking_char... into the "spawn_basic_dialog"
               driver ? driver->decorate_speaking_character_name(node_pages_speaker) : node_pages_speaker,
               //node_pages_speaker,
               node_pages
            );
            //append_to_dialog_roll(node_pages_speaker, node_pages[0]); // TODO: join(node_pages);
         }
         else // (node_options_as_text.size() > 1)
         {
            // If dialog has multiple options, spawn a "choice" dialog
            if (node_pages.size() != 1)
            {
               throw std::runtime_error(
                  "DialogSystem::DialogSystem::activate_dialog_node_by_name: error: Expecting only 1 page for dialog node \""
                     + dialog_name + "\" (because it is going to be used to build a Choice dialog, "
                     "but there are \"" + std::to_string(node_pages.size()) + "\" pages."
               );
            }
            // TODO: Consider moving this call to _driver->on_before_spawn_choice_dialog into the "spawn_choice_dialog"
            if (driver) driver->on_before_spawn_choice_dialog(node_pages_speaker);
            spawn_choice_dialog(
               // TODO: Consider moving this call to _driver->decorate_speaking_char... into the "spawn_choice_dialog"
               driver ? driver->decorate_speaking_character_name(node_pages_speaker) : node_pages_speaker,
               //node_pages_speaker,
               node_pages[0],
               node_options_as_text,
               cursor_position_on_spawn
            );
            //append_to_dialog_roll(node_pages_speaker, node_pages[0]); // TODO: join(node_pages);
         }
      }
      else if (active_dialog_node->is_type(AllegroFlare::DialogTree::Nodes::Wait::TYPE))
      {
         AllegroFlare::DialogTree::Nodes::Wait *as =
            static_cast<AllegroFlare::DialogTree::Nodes::Wait*>(active_dialog_node);

         float duration_seconds = as->get_duration_sec();
         spawn_wait_dialog(duration_seconds);
      }
      else if (active_dialog_node->is_type(AllegroFlare::DialogTree::Nodes::ChapterTitle::TYPE))
      {
         AllegroFlare::DialogTree::Nodes::ChapterTitle *as =
            static_cast<AllegroFlare::DialogTree::Nodes::ChapterTitle*>(active_dialog_node);

         spawn_chapter_title_dialog(
               as->get_title_text(),
               as->get_duration()
            );
      }
      else if (active_dialog_node->is_type(AllegroFlare::DialogTree::Nodes::ExitDialog::TYPE))
      {
         shutdown_dialog(); // TODO: See if this is a correct action for this event, e.g.
                                           // should it be "switch_out" or "shutdown", etc
      }
      else if (active_dialog_node->is_type(AllegroFlare::DialogTree::Nodes::ExitProgram::TYPE))
      {
         // TODO: Test this event emission
         get_event_emitter()->emit_exit_game_event();
      }
      else
      {
         bool handled = false;
         if (driver)
         {
            // TODO: Test calling on this "unhandled" case
            handled = driver->on_activate_dialog_node_type_unhandled(
               this,
               active_dialog_node_name,
               active_dialog_node
            );
         }

         // TODO: Test throwing of this when not handled
         if (!handled)
         {
            throw std::runtime_error(
               "DialogSystem::DialogSystem::activate_dialog_node_by_name: error: "
                  "Unable to handle dialog node activation on type \""
                  + active_dialog_node->get_type() + "\". A condition is not provided to handle this type."
            );
         }
      }
      return;
    body_dependency_symbols:
     - AllegroFlare::DialogTree::Nodes::MultipageWithOptions
     - AllegroFlare::DialogTree::Nodes::RawScriptLine
     - AllegroFlare::DialogTree::Nodes::EmitGameEvent
     - AllegroFlare::DialogTree::Nodes::ExitDialog
     - AllegroFlare::DialogTree::Nodes::ExitProgram
     - AllegroFlare::DialogTree::Nodes::Wait
     - AllegroFlare::DialogTree::Nodes::ChapterTitle


  - name: spawn_basic_dialog
    parameters:
      - name: speaking_character
        type: std::string
        default_argument: '"[unset-speaking_character]"'
      - name: pages
        type: std::vector<std::string>
        default_argument: '{}'
    body: |
      switch_in_if_not();

      bool a_dialog_existed_before = a_dialog_is_active();
      if (active_dialog_box) delete active_dialog_box; // TODO: address concern that this could clobber an active dialog
                                                       // And/or address concerns that derived dialog be deleted proper

      AllegroFlare::Elements::DialogBoxFactory dialog_box_factory;
      active_dialog_box = dialog_box_factory.create_basic_dialog(
         speaking_character,
         //speaking_character,
         pages
      );

      // TODO: Address when and where a switch_in should occur
      //bool a_new_dialog_was_created_and_dialog_system_is_now_active = !a_dialog_existed_before;
      //if (a_new_dialog_was_created_and_dialog_system_is_now_active)
      //{
         //switch_in();
      //}
      return;
    body_dependency_symbols:
      - AllegroFlare::Elements::DialogBoxFactory


  - name: spawn_intertitle_dialog
    parameters:
      - name: text
        type: std::string
        default_argument: '"[unset-text]"'
    body: |
      switch_in_if_not();

      bool a_dialog_existed_before = a_dialog_is_active();
      if (active_dialog_box) delete active_dialog_box; // TODO: address concern that this could clobber an active dialog
                                                       // And/or address concerns that derived dialog be deleted proper

      AllegroFlare::Elements::DialogBoxFactory dialog_box_factory;
      active_dialog_box = dialog_box_factory.create_intertitle_dialog(
         text
         //speaking_character,
         //pages
      );

      // TODO: Address when and where a switch_in should occur
      //bool a_new_dialog_was_created_and_dialog_system_is_now_active = !a_dialog_existed_before;
      //if (a_new_dialog_was_created_and_dialog_system_is_now_active)
      //{
         //switch_in();
      //}
      return;
    body_dependency_symbols:
      - AllegroFlare::Elements::DialogBoxFactory


  - name: spawn_text_messages_dialog
    parameters:
      - name: messages
        type: std::vector<std::tuple<std::string, std::string, float>>
        default_argument: '{}'
    body: |
      switch_in_if_not();

      bool a_dialog_existed_before = a_dialog_is_active();
      if (active_dialog_box) delete active_dialog_box; // TODO: address concern that this could clobber an active dialog
                                                       // And/or address concerns that derived dialog be deleted proper

      AllegroFlare::Elements::DialogBoxFactory dialog_box_factory;
      active_dialog_box = dialog_box_factory.create_text_messages_dialog(
         messages
         //speaking_character,
         //speaking_character,
         //pages
      );

      // TODO: Address when and where a switch_in should occur
      //bool a_new_dialog_was_created_and_dialog_system_is_now_active = !a_dialog_existed_before;
      //if (a_new_dialog_was_created_and_dialog_system_is_now_active)
      //{
         //switch_in();
      //}
      return;
    body_dependency_symbols:
      - AllegroFlare::Elements::DialogBoxFactory


  - name: spawn_wait_dialog
    parameters:
      - name: duration_seconds
        type: float
        default_argument: 1.0f
    body: |
      switch_in_if_not();

      bool a_dialog_existed_before = a_dialog_is_active();
      if (active_dialog_box) delete active_dialog_box; // TODO: address concern that this could clobber an active dialog
                                                       // And/or address concerns that derived dialog be deleted proper

      AllegroFlare::Elements::DialogBoxFactory dialog_box_factory;
      active_dialog_box = dialog_box_factory.create_wait_dialog(duration_seconds);

      // TODO: Address when and where a switch_in should occur
      //bool a_new_dialog_was_created_and_dialog_system_is_now_active = !a_dialog_existed_before;
      //if (a_new_dialog_was_created_and_dialog_system_is_now_active)
      //{
         //switch_in();
      //}
      return;
    body_dependency_symbols:
      - AllegroFlare::Elements::DialogBoxFactory


  - name: spawn_chapter_title_dialog
    parameters:
      - name: title_text
        type: std::string
        default_argument: '"[unset-title_text]"'
      - name: duration_seconds
        type: float
        default_argument: 1.0f
    body: |
      switch_in_if_not();

      bool a_dialog_existed_before = a_dialog_is_active();
      if (active_dialog_box) delete active_dialog_box; // TODO: address concern that this could clobber an active dialog
                                                       // And/or address concerns that derived dialog be deleted proper

      AllegroFlare::Elements::DialogBoxFactory dialog_box_factory;
      active_dialog_box = dialog_box_factory.create_chapter_title_dialog(
         title_text,
         duration_seconds
      );

      // TODO: Address when and where a switch_in should occur
      //bool a_new_dialog_was_created_and_dialog_system_is_now_active = !a_dialog_existed_before;
      //if (a_new_dialog_was_created_and_dialog_system_is_now_active)
      //{
         //switch_in();
      //}
      return;
    body_dependency_symbols:
      - AllegroFlare::Elements::DialogBoxFactory


  - name: spawn_character_feature_dialog
    parameters:
      - name: character_name
        type: std::string
        default_argument: '"[unset-character_name]"'
      - name: character_description
        type: std::string
        default_argument: '"[unset-character_description]"'
      - name: character_image_identifier
        type: std::string
        default_argument: '"[unset-character_image_identifier]"'
      - name: duration_seconds
        type: float
        default_argument: 6.0f
    body: |
      switch_in_if_not();

      // TODO: Use a DEFAULT_DURATION_SECONDS
      bool a_dialog_existed_before = a_dialog_is_active();
      if (active_dialog_box) delete active_dialog_box; // TODO: address concern that this could clobber an active dialog
                                                       // And/or address concerns that derived dialog be deleted proper

      AllegroFlare::Elements::DialogBoxFactory dialog_box_factory;
      active_dialog_box = dialog_box_factory.create_character_feature_dialog(
         //driver ? driver->decorate_speaking_character(speaking_character) : speaking_character,
         character_name,
         character_description,
         character_image_identifier,
         duration_seconds
      );

      // TODO: Address when and where a switch_in should occur
      //bool a_new_dialog_was_created_and_dialog_system_is_now_active = !a_dialog_existed_before;
      //if (a_new_dialog_was_created_and_dialog_system_is_now_active)
      //{
         //switch_in();
      //}
      return;
    body_dependency_symbols:
      - AllegroFlare::Elements::DialogBoxFactory


  - name: spawn_choice_dialog
    parameters:
      - name: speaking_character
        type: std::string
        default_argument: '"[unset-speaking_character]"'
      - name: prompt
        type: std::string
        default_argument: '"[unset-prompt]"'
      - name: options
        type: std::vector<std::string>
        default_argument: '{}'
      - name: cursor_position_on_spawn
        type: int
        default_argument: 0
    guards: [ (cursor_position_on_spawn >= 0), (cursor_position_on_spawn < options.size()) ]
    body: |
      switch_in_if_not();

      bool a_dialog_existed_before = a_dialog_is_active();
      if (active_dialog_box) delete active_dialog_box; // TODO: address concern that this could clobber an active dialog

      // NOTE: In order to be compatable with "create_choice_dialog", we will fill with some dummy values.
      // For now, we use the cursor position of the choice dialog to pick the option. Consider revising or cleaning up
      std::vector<std::pair<std::string, std::string>> options_that_are_also_values;
      for (auto &option : options)
      {
         options_that_are_also_values.push_back({option, option});
      }

      AllegroFlare::Elements::DialogBoxFactory dialog_box_factory;
      AllegroFlare::Elements::DialogBoxes::Choice *choice_dialog_box =
            dialog_box_factory.create_choice_dialog(
               //driver ? driver->decorate_speaking_character_name(speaking_character) : speaking_character,
               speaking_character,
               prompt,
               options_that_are_also_values,
               cursor_position_on_spawn
            );
      active_dialog_box = choice_dialog_box;


      // Calculate the dimensions of the box, to set the cursor selection box on it
      AllegroFlare::Elements::DialogBoxRenderers::ChoiceRenderer choice_renderer_for_dimensions(
         font_bin,
         bitmap_bin,
         choice_dialog_box
      );

      std::tuple<float, float, float, float> selection_dimensions =
            choice_renderer_for_dimensions.calculate_dimensions_of_current_selection();
      choice_renderer_for_dimensions.helper__set_selection_cursor_box_dimensions_to(
            &selection_cursor_box,
            selection_dimensions
         );

      // TODO: Address when and where a switch_in should occur
      //bool a_new_dialog_was_created_and_dialog_system_is_now_active = !a_dialog_existed_before;
      //if (a_new_dialog_was_created_and_dialog_system_is_now_active)
      //{
         //switch_in();
      //}
      return;
    body_dependency_symbols:
      - AllegroFlare::Elements::DialogBoxFactory
      - AllegroFlare::Elements::DialogBoxRenderers::ChoiceRenderer


  - name: update
    parameters:
      - name: time_now
        type: float
        default_argument: 0
    guards: [ initialized ]
    body: |
      // TODO: Ensure time_now does not accidentally become 0 by not being noticed as an argument
      // TODO: Ensure time_now is passed down to active dialog updates()
      // TODO: Consider if ordering of events is correct
      if (active_dialog_box) active_dialog_box->update();
      selection_cursor_box.update();
      //if (active_dialog_node_state) active_dialog_node_state->update(); // TODO: Pass down time_now

      // TODO: Consider moving this block above with the normal update
      if (active_dialog_box && active_dialog_box->ready_to_auto_advance()) dialog_advance();

      return;


  - name: render
    type: void
    guards: [ initialized, driver ]
    body: |
      if (driver) driver->on_render();

      if (active_dialog_box)
      {
         AllegroFlare::Elements::DialogBoxRenderer dialog_box_renderer(
               font_bin,
               bitmap_bin,
               active_dialog_box,
               &selection_cursor_box
            );
         dialog_box_renderer.set_standard_dialog_box_font_name(standard_dialog_box_font_name);
         dialog_box_renderer.set_standard_dialog_box_font_size(standard_dialog_box_font_size);
         dialog_box_renderer.set_standard_dialog_box_x(standard_dialog_box_x);
         dialog_box_renderer.set_standard_dialog_box_y(standard_dialog_box_y);
         dialog_box_renderer.set_standard_dialog_box_width(standard_dialog_box_width);
         dialog_box_renderer.set_standard_dialog_box_height(standard_dialog_box_height);
         dialog_box_renderer.render();
      }
    body_dependency_symbols:
      - AllegroFlare::Elements::DialogBoxRenderer


  - name: a_dialog_is_active
    type: bool
    body: |
      return (active_dialog_box != nullptr);


  - name: dialog_advance
    guards: [ initialized, active_dialog_box ]
    body: |
      active_dialog_box->advance();
      if (active_dialog_box->get_finished())
      {
         if (active_dialog_node)
         {
            if (active_dialog_node->is_type(AllegroFlare::DialogTree::Nodes::MultipageWithOptions::TYPE))
            {
               AllegroFlare::DialogTree::Nodes::MultipageWithOptions *as_multipage_with_options =
                  static_cast<AllegroFlare::DialogTree::Nodes::MultipageWithOptions*>(active_dialog_node);

               if (as_multipage_with_options->num_options() == 0)
               {
                  // If this dialog node has no options, then proceed to a "shutdown" state

                  // TODO: Replace this throw with a shutdown
                  throw std::runtime_error(
                     "DialogSystem::dialog_advance: error: Expecting 1 or many options for node named \""
                        + active_dialog_node_name + "\" but there are no options."
                  );
               }
               else if (as_multipage_with_options->num_options() == 1)
               {
                  // If the dialog node has 1 option, "activate" it
                  int current_dialog_selection_choice = 0;
                  activate_dialog_option(current_dialog_selection_choice);
               }
               else // if (as_multipage_with_options.num_options() > 1)
               {
                  // If the dialog *node* has more than 1 option, correlate the dialog *box*'s current cursor position
                     // with the result and "activate" it
                  if (!active_dialog_box->is_type(AllegroFlare::Elements::DialogBoxes::Choice::TYPE))
                  {
                     throw std::runtime_error(
                        "DialogSystem::dialog_advance: error: Expecting active_dialog_box (with more than one option) "
                           "to be of type \"AllegroFlare::Elements::DialogBoxes::Choice::TYPE\", but it is of type \""
                           + active_dialog_box->get_type() + "\""
                     );
                  }
                  else
                  {
                     AllegroFlare::Elements::DialogBoxes::Choice *as_choice_dialog_box = 
                        static_cast<AllegroFlare::Elements::DialogBoxes::Choice*>(active_dialog_box);

                     int current_dialog_selection_choice = as_choice_dialog_box->get_cursor_position();
                     activate_dialog_option(current_dialog_selection_choice);
                  }
               }
            }
            else if (active_dialog_node->is_type(AllegroFlare::DialogTree::Nodes::Wait::TYPE))
            {
               if (!active_dialog_box->is_type(AllegroFlare::Elements::DialogBoxes::Wait::TYPE))
               {
                  throw std::runtime_error(
                     "DialogSystem::dialog_advance: error: Expecting active_dialog_box to be a nullptr (when node "
                        "is of type \"AllegroFlare::Elements::DialogBoxes::Wait::TYPE\"), but it is not."
                  );
               }

               AllegroFlare::DialogTree::Nodes::Wait *as =
                  static_cast<AllegroFlare::DialogTree::Nodes::Wait*>(active_dialog_node);
               std::cout << " next_node_identifier: " << as->get_next_node_identifier() << std::endl;
               activate_dialog_node_by_name(as->get_next_node_identifier());
            }
            else if (active_dialog_node->is_type(AllegroFlare::DialogTree::Nodes::ChapterTitle::TYPE))
            {
               if (!active_dialog_box->is_type(AllegroFlare::Elements::DialogBoxes::ChapterTitle::TYPE))
               {
                  throw std::runtime_error(
                     "DialogSystem::dialog_advance: error: Expecting active_dialog_box to be a nullptr (when node "
                        "is of type \"AllegroFlare::Elements::DialogBoxes::ChapterTitle::TYPE\"), but it is not."
                  );
               }

               AllegroFlare::DialogTree::Nodes::ChapterTitle *as =
                  static_cast<AllegroFlare::DialogTree::Nodes::ChapterTitle*>(active_dialog_node);
               std::cout << " next_node_identifier: " << as->get_next_node_identifier() << std::endl;
               activate_dialog_node_by_name(as->get_next_node_identifier());
            }
            else if (AllegroFlare::DialogTree::Nodes::RawScriptLine::TYPE)
                        //, [dialog_system, active_dialog_box, active_dialog_node, user_data](){
            {
               //if (driver) driver->on_render();
               //FadeToWhite::DialogSystemDriver *this_dialog_system_driver =
                  //static_cast<FadeToWhite::DialogSystemDriver*>(user_data);
               if (driver) driver->on_raw_script_line_finished(
                  this,
                  active_dialog_box,
                  active_dialog_node
               );
               //if (handle_finished_dialog_from_raw_script_line_func) // Name is more "handle_finished_dialog_on_raw_script_line"
               //{
                  //handle_finished_dialog_from_raw_script_line_func(
                     //this,
                     //active_dialog_box,
                     //active_dialog_node,
                     //handle_finished_dialog_from_raw_script_line_func_user_data
                  //);
               //}
            }
            //}},
            else if (active_dialog_node->is_type(AllegroFlare::DialogTree::Nodes::ExitDialog::TYPE))
            {
               //AllegroFlare::DialogTree::Nodes::ExitDialog *as =
                  //static_cast<AllegroFlare::DialogTree::Nodes::ExitDialog*>(base);
               shutdown_dialog(); // TODO: Verify if this is a correct complete action for this event
            }
            else if (active_dialog_node->is_type(AllegroFlare::DialogTree::Nodes::ExitProgram::TYPE))
            {
               // TODO: Consider renaming ExitProgram
               event_emitter->emit_exit_game_event();
            }
            else
            {
                  throw std::runtime_error(
                     "DialogSystem::dialog_advance: error: Unable to handle case where dialog *box* is finished when "
                        "the dialog *node* type \""
                        + active_dialog_node->get_type() + "\". A condition is not provided to handle this type."
                  );
                  //throw std::runtime_error(
                     //"DialogSystem::activate_dialog_node_by_name: error: Unable to handle dialog node activation on type \""
                        //+ active_dialog_node->get_type() + "\". A condition is not provided to handle this type."
                  //);
               //}

               //throw std::runtime_error(
                  //"DialogSystem::dialog_advance: error: Unable to handle case where dialog *box* is finished when "
                     //"the dialog *node* type \""
                     //+ active_dialog_node->get_type() + "\". A condition is not provided to handle this type."
               //);
            }
         }
         else // There is no "active_dialog_node", even though there is an "active_dialog_box"
         {
            // TODO: Consider if should throw in this case
         }
      }
      return;
    body_dependency_symbols:
      - AllegroFlare::Elements::DialogBoxes::Choice
      - AllegroFlare::Elements::DialogBoxes::Wait
      - AllegroFlare::DialogTree::Nodes::ExitDialog
      - AllegroFlare::DialogTree::Nodes::ExitProgram
      - AllegroFlare::DialogTree::Nodes::ChapterTitle
      - AllegroFlare::DialogTree::Nodes::RawScriptLine


  - name: activate_dialog_option
    type: void
    parameters:
      - name: selection_choice
        type: int
        default_argument: 0
    guards:
      - event_emitter
      - active_dialog_node
    body: |
      if (active_dialog_node->is_type(AllegroFlare::DialogTree::Nodes::MultipageWithOptions::TYPE))
      {

         AllegroFlare::DialogTree::Nodes::MultipageWithOptions *as_multipage_with_options =
            static_cast<AllegroFlare::DialogTree::Nodes::MultipageWithOptions*>(active_dialog_node);

         // TODO: Consider case where dialog node has no (empty) options
         if (!(selection_choice >= 0))
         {
            throw std::runtime_error(
               "DialogSystem::activate_dialog_option: error: selection_choice must be >= 0"
            );
         }
         if (!(selection_choice < as_multipage_with_options->num_options()))
         {
            throw std::runtime_error(
               "DialogSystem::activate_dialog_option: error: selection_choice must be less than the num options"
            );
         }

         AllegroFlare::DialogTree::NodeOptions::Base* node_option =
            std::get<1>(as_multipage_with_options->get_option_num(selection_choice)); //.second;
         std::string node_option_type = node_option->get_type();
   
         std::map<std::string, std::function<void()>> types_map = {
            { AllegroFlare::DialogTree::NodeOptions::ExitDialog::TYPE, [this, node_option]() {
               AllegroFlare::DialogTree::NodeOptions::ExitDialog* as_exit_dialog_node_option =
                  static_cast<AllegroFlare::DialogTree::NodeOptions::ExitDialog*>(node_option);

               //event_emitter->emit_dialog_close_event();
               shutdown_dialog(); // TODO: See if this is a correct expectation for this event
            }},
            { AllegroFlare::DialogTree::NodeOptions::GoToNode::TYPE, [this, node_option]() {
               // TODO: Test this case
               AllegroFlare::DialogTree::NodeOptions::GoToNode* as_go_to_node_dialog_node_option =
                  static_cast<AllegroFlare::DialogTree::NodeOptions::GoToNode*>(node_option);
               std::string target_node_name = as_go_to_node_dialog_node_option->get_target_node_name();

               //event_emitter->emit_dialog_open_event(target_node_name);
               activate_dialog_node_by_name(target_node_name);
            }},
         };

         // locate and call the function to handle the item
         if (types_map.count(node_option_type) == 0)
         {
            // item not found
            std::stringstream error_message;
            error_message << "[DialogTree::NodeOptionActivator::activate]: error: Cannot activate a node with the "
                          << "node_option_type \"" << node_option_type << "\", a handling for that type does not exist.";
            throw std::runtime_error(error_message.str());
         }
         else
         {
            // call the item
            types_map[node_option_type]();
         }
      }
      else
      {
         throw std::runtime_error(
            "DialogSystem::activate_dialog_option: error: Unable to handle case where dialog *node* is of type \""
               + active_dialog_node->get_type() + "\"."
         );
      }

      return;
    body_dependency_symbols:
      - std::function
      - AllegroFlare::DialogTree::NodeOptions::ExitDialog
      - AllegroFlare::DialogTree::NodeOptions::GoToNode


  - name: dialog_is_finished
    type: bool
    guards: [ initialized, active_dialog_box ]
    body: |
      return active_dialog_box->get_finished();


  - name: shutdown_dialog
    type: bool
    guards: [ initialized, driver, switched_in ]
    body: |
      switch_out();
      return true;


  - name: move_dialog_cursor_position_up
    guards: [ initialized ]
    body: |
      if (!active_dialog_box) return;
      active_dialog_box->move_cursor_position_up();
      if (active_dialog_box->is_type(AllegroFlare::Elements::DialogBoxes::Choice::TYPE))
      {
         AllegroFlare::Elements::DialogBoxes::Choice *as_choice_dialog_box =
               static_cast<AllegroFlare::Elements::DialogBoxes::Choice*>(active_dialog_box);

         // Set the cursor selection box position to this point
         AllegroFlare::Elements::DialogBoxRenderers::ChoiceRenderer choice_renderer_for_dimensions(
            font_bin,
            bitmap_bin,
            as_choice_dialog_box
         );

         std::tuple<float, float, float, float> selection_dimensions =
               choice_renderer_for_dimensions.calculate_dimensions_of_current_selection();
         choice_renderer_for_dimensions.helper__reposition_selection_cursor_box_dimensions_to(
               &selection_cursor_box,
               selection_dimensions
            );
      }
      return;


  - name: move_dialog_cursor_position_down
    guards: [ initialized ]
    body: |
      if (!active_dialog_box) return;
      active_dialog_box->move_cursor_position_down();
      // TODO: Reposition the cursor
      if (active_dialog_box->is_type(AllegroFlare::Elements::DialogBoxes::Choice::TYPE))
      {
         AllegroFlare::Elements::DialogBoxes::Choice *as_choice_dialog_box =
               static_cast<AllegroFlare::Elements::DialogBoxes::Choice*>(active_dialog_box);

         // Set the cursor selection box position to this point
         AllegroFlare::Elements::DialogBoxRenderers::ChoiceRenderer choice_renderer_for_dimensions(
            font_bin,
            bitmap_bin,
            as_choice_dialog_box
         );

         std::tuple<float, float, float, float> selection_dimensions =
               choice_renderer_for_dimensions.calculate_dimensions_of_current_selection();
         choice_renderer_for_dimensions.helper__reposition_selection_cursor_box_dimensions_to(
               &selection_cursor_box,
               selection_dimensions
            );
      }
      return;


  - name: handle_raw_ALLEGRO_EVENT_that_is_dialog_event
    parameters:
      - name: ev
        type: ALLEGRO_EVENT*
        default_argument: nullptr
      - name: data
        type: AllegroFlare::GameEventDatas::Base*
        default_argument: nullptr
    guards: [ ev, data ]
    body: |
      // TODO: Update this to a map caller pattern (static const)
      if (data->is_type(AllegroFlare::DialogSystem::DialogEventDatas::LoadDialogNodeBankFromFile::TYPE))
      {
         auto *as = static_cast<AllegroFlare::DialogSystem::DialogEventDatas::LoadDialogNodeBankFromFile*>(data);
         load_dialog_node_bank_from_file(as->get_yaml_filename());
      }
      // TODO: Rename this SpawnDialogByName to ActivateDialogNodeByName
      else if (data->is_type(AllegroFlare::DialogSystem::DialogEventDatas::SpawnDialogByName::TYPE))
      {
         auto *as = static_cast<AllegroFlare::DialogSystem::DialogEventDatas::SpawnDialogByName*>(data);
         activate_dialog_node_by_name(as->get_name());
      }
      else
      {
         AllegroFlare::Logger::throw_error(
               "AllegroFlare::DialogSystem::DialogSystem::handle_raw_ALLEGRO_EVENT_that_is_dialog_event",
               "Unhandled case on type \"" + data->get_type() + "\"."
            );
      }
      return;
    body_dependency_symbols:
      - AllegroFlare::DialogSystem::DialogEventDatas::SpawnDialogByName
      - AllegroFlare::DialogSystem::DialogEventDatas::LoadDialogNodeBankFromFile


dependencies:


  - symbol: AllegroFlare::DialogSystem::DialogSystem
    headers: [ ]
  - symbol: ALLEGRO_BITMAP
    headers: [ allegro5/allegro.h ]
  - symbol: ALLEGRO_EVENT
    headers: [ allegro5/allegro.h ]
  - symbol: al_is_primitives_addon_initialized
    headers: [ allegro5/allegro_primitives.h ]
  - symbol: AllegroFlare::FontBin
    headers: [ AllegroFlare/FontBin.hpp ]
  - symbol: AllegroFlare::EventNames
    headers: [ AllegroFlare/EventNames.hpp ]
  - symbol: AllegroFlare::DialogSystem::DialogEventDatas::CloseDialog
    headers: [ AllegroFlare/DialogSystem/DialogEventDatas/CloseDialog.hpp ]
  - symbol: AllegroFlare::Elements::DialogBoxes::YouGotEvidence
    headers: [ AllegroFlare/Elements/DialogBoxes/YouGotEvidence.hpp ]
  - symbol: AllegroFlare::Elements::DialogBoxes::Base
    headers: [ AllegroFlare/Elements/DialogBoxes/Base.hpp ]
  - symbol: AllegroFlare::Elements::DialogBoxes::Choice
    headers: [ AllegroFlare/Elements/DialogBoxes/Choice.hpp ]
  - symbol: AllegroFlare::GameEvent
    headers: [ AllegroFlare/GameEvent.hpp ]
  - symbol: AllegroFlare::GameEventDatas::Base
    headers: [ AllegroFlare/GameEventDatas/Base.hpp ]
  - symbol: AllegroFlare::Elements::DialogBoxRenderer
    headers: [ AllegroFlare/Elements/DialogBoxRenderer.hpp ]
  - symbol: AllegroFlare::BitmapBin
    headers: [ AllegroFlare/BitmapBin.hpp ]
  - symbol: AllegroFlare::Elements::DialogBoxes::Basic
    headers: [ AllegroFlare/Elements/DialogBoxes/Basic.hpp ]
  - symbol: AllegroFlare::Elements::DialogBoxes::YouGotAnItem
    headers: [ AllegroFlare/Elements/DialogBoxes/YouGotAnItem.hpp ]
  - symbol: AllegroFlare::Elements::DialogBoxes::YouGotAnItem
    headers: [ AllegroFlare/Elements/DialogBoxes/YouGotAnItem.hpp ]
  - symbol: AllegroFlare::Elements::DialogBoxes::Wait
    headers: [ AllegroFlare/Elements/DialogBoxes/Wait.hpp ]
  - symbol: AllegroFlare::InventoryDictionaryItems::WithAttributes
    headers: [ AllegroFlare/InventoryDictionaryItems/WithAttributes.hpp ]
  - symbol: AllegroFlare::Elements::DialogBoxFactory
    headers: [ AllegroFlare/Elements/DialogBoxFactory.hpp ]
  - symbol: AllegroFlare::DialogSystem::DialogEventDatas::CreateYouGotAnItemDialog
    headers: [ AllegroFlare/DialogSystem/DialogEventDatas/CreateYouGotAnItemDialog.hpp ]
  - symbol: AllegroFlare::DialogSystem::DialogEventDatas::CreateYouGotEvidenceDialog
    headers: [ AllegroFlare/DialogSystem/DialogEventDatas/CreateYouGotEvidenceDialog.hpp ]
  - symbol: AllegroFlare::EventEmitter
    headers: [ AllegroFlare/EventEmitter.hpp ]
  - symbol: AllegroFlare::DialogTree::NodeBank
    headers: [ AllegroFlare/DialogTree/NodeBank.hpp ]
  - symbol: AllegroFlare::DialogTree::Nodes::Base
    headers: [ AllegroFlare/DialogTree/Nodes/Base.hpp ]
  - symbol: AllegroFlare::DialogTree::NodeOptions::GoToNode
    headers: [ AllegroFlare/DialogTree/NodeOptions/GoToNode.hpp ]
  - symbol: AllegroFlare::DialogTree::NodeOptions::ExitDialog
    headers: [ AllegroFlare/DialogTree/NodeOptions/ExitDialog.hpp ]
  - symbol: AllegroFlare::DialogTree::Nodes::MultipageWithOptions
    headers: [ AllegroFlare/DialogTree/Nodes/MultipageWithOptions.hpp ]
  - symbol: AllegroFlare::Elements::SelectionCursorBox
    headers: [ AllegroFlare/Elements/SelectionCursorBox.hpp ]
  - symbol: AllegroFlare::Elements::DialogBoxRenderers::ChoiceRenderer
    headers: [ AllegroFlare/Elements/DialogBoxRenderers/ChoiceRenderer.hpp ]
  - symbol: AllegroFlare::DialogSystem::DialogEventDatas::SpawnDialogByName
    headers: [ AllegroFlare/DialogSystem/DialogEventDatas/SpawnDialogByName.hpp ]
  - symbol: AllegroFlare::DialogSystem::DialogEventDatas::LoadDialogNodeBankFromFile
    headers: [ AllegroFlare/DialogSystem/DialogEventDatas/LoadDialogNodeBankFromFile.hpp ]
  - symbol: AllegroFlare::DialogSystem::CharacterStagingLayouts::Base
    headers: [ AllegroFlare/DialogSystem/CharacterStagingLayouts/Base.hpp ]
  - symbol: AllegroFlare::DialogSystem::CharacterRoster
    headers: [ AllegroFlare/DialogSystem/CharacterRoster.hpp ]
  - symbol: AllegroFlare::DialogSystem::Characters::Basic
    headers: [ AllegroFlare/DialogSystem/Characters/Basic.hpp ]
  - symbol: AllegroFlare::StringFormatValidator
    headers: [ AllegroFlare/StringFormatValidator.hpp ]
  - symbol: AllegroFlare::DialogTree::BasicScreenplayTextLoader
    headers: [ AllegroFlare/DialogTree/BasicScreenplayTextLoader.hpp ]
  - symbol: AllegroFlare::Logger
    headers: [ AllegroFlare/Logger.hpp ]
  - symbol: AllegroFlare::UsefulPHP
    headers: [ AllegroFlare/UsefulPHP.hpp ]
  - symbol: AllegroFlare::DialogTree::Nodes::ExitDialog
    headers: [ AllegroFlare/DialogTree/Nodes/ExitDialog.hpp ]
  - symbol: AllegroFlare::DialogTree::Nodes::ExitProgram
    headers: [ AllegroFlare/DialogTree/Nodes/ExitProgram.hpp ]
  - symbol: AllegroFlare::DialogTree::Nodes::ChapterTitle
    headers: [ AllegroFlare/DialogTree/Nodes/ChapterTitle.hpp ]
  - symbol: AllegroFlare::DialogTree::Nodes::RawScriptLine
    headers: [ AllegroFlare/DialogTree/Nodes/RawScriptLine.hpp ]
  - symbol: AllegroFlare::DialogTree::Nodes::EmitGameEvent
    headers: [ AllegroFlare/DialogTree/Nodes/EmitGameEvent.hpp ]
  - symbol: AllegroFlare::Elements::DialogRoll
    headers: [ AllegroFlare/Elements/DialogRoll.hpp ]
  - symbol: AllegroFlare::DialogTree::Nodes::Wait
    headers: [ AllegroFlare/DialogTree/Nodes/Wait.hpp ]
  - symbol: AllegroFlare::DialogSystemDrivers::Base
    headers: [ AllegroFlare/DialogSystemDrivers/Base.hpp ]
  - symbol: AllegroFlare::Elements::DialogBoxes::CharacterFeature
    headers: [ AllegroFlare/Elements/DialogBoxes/CharacterFeature.hpp ]


