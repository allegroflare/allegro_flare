properties:


  - name: bitmap_bin
    type: AllegroFlare::BitmapBin*
    init_with: nullptr
    constructor_arg: true
    setter: explicit

  - name: font_bin
    type: AllegroFlare::FontBin*
    init_with: nullptr
    constructor_arg: true
    setter: explicit

  - name: event_emitter
    type: AllegroFlare::EventEmitter*
    init_with: nullptr
    constructor_arg: true
    setter: explicit

  - name: dialog_node_bank
    type: AllegroFlare::DialogTree::NodeBank
    init_with: '{}'
    getter: true

  - name: active_dialog_box
    type: AllegroFlare::Elements::DialogBoxes::Base*
    init_with: nullptr

  - name: selection_cursor_box
    type: AllegroFlare::Elements::SelectionCursorBox
    init_with: '{}'

  - name: active_dialog_node
    type: AllegroFlare::DialogTree::Nodes::Base*
    init_with: nullptr

  - name: active_dialog_node_name
    type: std::string
    init_with: '"[unset-active_dialog_node_name]"'
    getter: true

  - name: switched_in
    type: bool
    init_with: false
    getter: true

  - name: standard_dialog_box_font_name
    type: std::string
    init_with: DEFAULT_STANDARD_DIALOG_BOX_FONT_NAME
    getter: true
    setter: true

  - name: standard_dialog_box_font_size
    type: int
    init_with: DEFAULT_STANDARD_DIALOG_BOX_FONT_SIZE
    getter: true
    setter: true

  - name: initialized
    type: bool
    init_with: false

  - name: DEFAULT_STANDARD_DIALOG_BOX_FONT_NAME
    type: char*
    constexpr: true
    const: true
    static: true
    init_with: '(char*)"Inter-Regular.ttf"'

  - name: DEFAULT_STANDARD_DIALOG_BOX_FONT_SIZE
    type: int
    constexpr: true
    const: true
    static: true
    init_with: -36


documentation:


  - next_steps:
     - modify process_dialog_event to branch based on the ALLEGRO_FLARE_EVENT_DIALOG_* event
     - consider if you need to make GameEventDatas for each of the different types of events
     - review overall the integrety of the system, Add lots of tests, make it so "anybody can emit a dialog event"


methods:


  - name: set_bitmap_bin
    parameters:
      - name: bitmap_bin
        type: AllegroFlare::BitmapBin*
        default_argument: nullptr
    guards: [ (!initialized) ]
    body: |
      this->bitmap_bin = bitmap_bin;


  - name: set_font_bin
    parameters:
      - name: font_bin
        type: AllegroFlare::FontBin*
        default_argument: nullptr
    guards: [ (!initialized) ]
    body: |
      this->font_bin = font_bin;


  - name: set_event_emitter
    parameters:
      - name: event_emitter
        type: AllegroFlare::EventEmitter*
        default_argument: nullptr
    guards: [ (!initialized) ]
    body: |
      this->event_emitter = event_emitter;


  - name: load_dialog_node_bank_from_file
    parameters:
      - name: filename
        type: std::string
        default_argument: '"[unset-filename]"'
    guards: [ 'std::filesystem::exists(filename)' ]
    body: |
      // TODO: Validate a dialog is not currently running (or something)
      AllegroFlare::DialogTree::YAMLLoader yaml_loader;
      yaml_loader.load_file(filename);
      dialog_node_bank = yaml_loader.get_node_bank();
      return;
    body_dependency_symbols:
      - std::filesystem::exists
      - AllegroFlare::DialogTree::YAMLLoader


  - name: initialize
    guards:
       - (!initialized)
       - al_is_system_installed()
       - al_is_primitives_addon_initialized()
       - al_is_font_addon_initialized()
       - bitmap_bin
       - font_bin
       - event_emitter
    body: |
      initialized = true;
      return;
    body_dependency_symbols:
      - al_is_primitives_addon_initialized


  - name: switch_in
    guards: [ (!switched_in) ]
    body: |
      switched_in = true;
      return;


  - name: switch_out
    guards: [ (switched_in) ]
    body: |
      switched_in = false;
      return;


  - name: spawn_dialog_by_name
    parameters:
      - name: dialog_name
        type: std::string
        default_argument: '"[unset-dialog_name]"'
    body: |
      active_dialog_node = dialog_node_bank.find_node_by_name(dialog_name);
      active_dialog_node_name = dialog_name;

      // NOTE: The branching below is not needed because find_node_by_name will throw if not found
      //if (!active_dialog_node)
      //{
         //throw std::runtime_error(
            //"DialogSystem::spawn_dialog_by_name: error: no dialog exists with the name \"" + dialog_name + "\""
         //);
      //}
      //else
      //{
      if (active_dialog_node->is_type(AllegroFlare::DialogTree::Nodes::MultipageWithOptions::TYPE))
      {
         AllegroFlare::DialogTree::Nodes::MultipageWithOptions *as_multipage_with_options =
            static_cast<AllegroFlare::DialogTree::Nodes::MultipageWithOptions*>(active_dialog_node);

         std::string node_pages_speaker = as_multipage_with_options->get_speaker();
         std::vector<std::string> node_pages = as_multipage_with_options->get_pages();
         std::vector<std::string> node_options_as_text = as_multipage_with_options->build_options_as_text();

         if (node_options_as_text.empty())
         {
            throw std::runtime_error(
               "DialogSystem::spawn_dialog_by_name: error: Expecting 1 or many options for node named \""
                  + dialog_name + "\" but there are no options."
            );
         }
         else if (node_options_as_text.size() == 1)
         {
            // If dialog has only one option, spawn a basic dialog
            spawn_basic_dialog(node_pages);
         }
         else // (node_options_as_text.size() > 1)
         {
            // TODO: Here, if dialog has multiple options, spawn a "choice" dialog
            if (node_pages.size() != 1)
            {
               throw std::runtime_error(
                  "DialogSystem::spawn_dialog_by_name: error: Expecting only 1 page for dialog node \""
                     + dialog_name + "\" (because it is going to be used to build a Choice dialog, "
                     "but there are \"" + std::to_string(node_pages.size()) + "\" pages."
               );
            }
            spawn_choice_dialog(node_pages[0], node_options_as_text);
         }
      }
      else
      {
         throw std::runtime_error(
            "DialogSystem::spawn_dialog_by_name: error: Unable to spawn dialog *box* for dialog *node* type \""
               + active_dialog_node->get_type() + "\". A condition is not provided to handle this type."
         );
      }
      return;
    body_dependency_symbols:
     - AllegroFlare::DialogTree::Nodes::MultipageWithOptions


  - name: spawn_basic_dialog
    parameters:
      - name: pages
        type: std::vector<std::string>
        default_argument: '{}'
    body: |
      bool a_dialog_existed_before = a_dialog_is_active();
      if (active_dialog_box) delete active_dialog_box; // TODO: address concern that this could clobber an active dialog
                                                       // And/or address concerns that derived dialog be deleted proper

      AllegroFlare::Elements::DialogBoxFactory dialog_box_factory;
      active_dialog_box = dialog_box_factory.create_basic_dialog(pages);

      // TODO: Address when and where a switch_in should occur
      bool a_new_dialog_was_created_and_dialog_system_is_now_active = !a_dialog_existed_before;
      if (a_new_dialog_was_created_and_dialog_system_is_now_active)
      {
         switch_in();
         event_emitter->emit_dialog_switch_in_event();
      }
      return;
    body_dependency_symbols:
      - AllegroFlare::Elements::DialogBoxFactory


  - name: spawn_choice_dialog
    parameters:
      - name: prompt
        type: std::string
        default_argument: '"[unset-prompt]"'
      - name: options
        type: std::vector<std::string>
        default_argument: '{}'
    body: |
      bool a_dialog_existed_before = a_dialog_is_active();
      if (active_dialog_box) delete active_dialog_box; // TODO: address concern that this could clobber an active dialog

      // NOTE: In order to be compatable with "create_choice_dialog", we will fill with some dummy values.
      // For now, we use the cursor position of the choice dialog to pick the option. Consider revising or cleaning up
      std::vector<std::pair<std::string, std::string>> options_that_are_also_values;
      for (auto &option : options)
      {
         options_that_are_also_values.push_back({option, option});
      }

      AllegroFlare::Elements::DialogBoxFactory dialog_box_factory;
      AllegroFlare::Elements::DialogBoxes::Choice *choice_dialog_box =
            dialog_box_factory.create_choice_dialog(prompt, options_that_are_also_values);
      active_dialog_box = choice_dialog_box;


      // Set the cursor selection box position to this point
      AllegroFlare::Elements::DialogBoxRenderers::ChoiceRenderer choice_renderer_for_dimensions(
         font_bin,
         bitmap_bin,
         choice_dialog_box
      );

      std::tuple<float, float, float, float> selection_dimensions =
            choice_renderer_for_dimensions.calculate_dimensions_of_current_selection();
      choice_renderer_for_dimensions.helper__set_selection_cursor_box_dimensions_to(
            &selection_cursor_box,
            selection_dimensions
         );



      // TODO: Address when and where a switch_in should occur
      bool a_new_dialog_was_created_and_dialog_system_is_now_active = !a_dialog_existed_before;
      if (a_new_dialog_was_created_and_dialog_system_is_now_active)
      {
         switch_in();
         event_emitter->emit_dialog_switch_in_event();
      }
      return;
    body_dependency_symbols:
      - AllegroFlare::Elements::DialogBoxFactory
      - AllegroFlare::Elements::DialogBoxRenderers::ChoiceRenderer


  - name: update
    parameters:
      - name: time_now
        type: float
        default_argument: 0
    guards: [ initialized ]
    body: |
      // TODO: Ensure time_now does not accidentally become 0 by not being noticed as an argument
      // TODO: Ensure time_now is passed down to active dialog updates()
      if (active_dialog_box) active_dialog_box->update();
      selection_cursor_box.update();
      return;


  - name: render
    type: void
    guards: [ initialized ]
    body: |
      if (active_dialog_box)
      {
         AllegroFlare::Elements::DialogBoxRenderer dialog_box_renderer(
               font_bin,
               bitmap_bin,
               active_dialog_box,
               &selection_cursor_box
            );
         dialog_box_renderer.set_standard_dialog_box_font_name(standard_dialog_box_font_name);
         dialog_box_renderer.set_standard_dialog_box_font_size(standard_dialog_box_font_size);
         dialog_box_renderer.render();
      }
    body_dependency_symbols:
      - AllegroFlare::Elements::DialogBoxRenderer


  - name: a_dialog_is_active
    type: bool
    body: |
      return (active_dialog_box != nullptr);


  - name: dialog_advance
    guards: [ initialized, active_dialog_box ]
    body: |
      active_dialog_box->advance();
      if (active_dialog_box->get_finished())
      {
         if (active_dialog_node)
         {
            if (active_dialog_node->is_type(AllegroFlare::DialogTree::Nodes::MultipageWithOptions::TYPE))
            {
               AllegroFlare::DialogTree::Nodes::MultipageWithOptions *as_multipage_with_options =
                  static_cast<AllegroFlare::DialogTree::Nodes::MultipageWithOptions*>(active_dialog_node);

               if (as_multipage_with_options->num_options() == 0)
               {
                  // If this dialog node has no options, then proceed to a "shutdown" state

                  // TODO: Replace this throw with a shutdown
                  throw std::runtime_error(
                     "DialogSystem::dialog_advance: error: Expecting 1 or many options for node named \""
                        + active_dialog_node_name + "\" but there are no options."
                  );
               }
               else if (as_multipage_with_options->num_options() == 1)
               {
                  // If the dialog node has 1 option, "activate" it
                  int current_dialog_selection_choice = 0;
                  activate_dialog_option(current_dialog_selection_choice);
               }
               else // if (as_multipage_with_options.num_options() > 1)
               {
                  // If the dialog *node* has more than 1 option, correlate the dialog *box*'s current cursor position
                     // with the result and "activate" it
                  if (!active_dialog_box->is_type(AllegroFlare::Elements::DialogBoxes::Choice::TYPE))
                  {
                     throw std::runtime_error(
                        "DialogSystem::dialog_advance: error: Expecting active_dialog_box (with more than one option) "
                           "to be of type \"AllegroFlare::Elements::DialogBoxes::Choice::TYPE\", but it is of type \""
                           + active_dialog_box->get_type() + "\""
                     );
                  }
                  else
                  {
                     AllegroFlare::Elements::DialogBoxes::Choice *as_choice_dialog_box = 
                        static_cast<AllegroFlare::Elements::DialogBoxes::Choice*>(active_dialog_box);

                     int current_dialog_selection_choice = as_choice_dialog_box->get_cursor_position();
                     activate_dialog_option(current_dialog_selection_choice);
                  }
               }
            }
            else
            {
               throw std::runtime_error(
                  "DialogSystem::dialog_advance: error: Unable to handle case where dialog *box* is finished when "
                     "the dialog *node* type \""
                     + active_dialog_node->get_type() + "\". A condition is not provided to handle this type."
               );
            }
         }

         // TODO: Figure out what to do when the dialog is finished.
      }
      return;
    body_dependency_symbols:
      - AllegroFlare::Elements::DialogBoxes::Choice


  - name: activate_dialog_option
    type: void
    parameters:
      - name: selection_choice
        type: int
        default_argument: 0
    guards:
      - event_emitter
      - active_dialog_node
    body: |
      if (active_dialog_node->is_type(AllegroFlare::DialogTree::Nodes::MultipageWithOptions::TYPE))
      {

         AllegroFlare::DialogTree::Nodes::MultipageWithOptions *as_multipage_with_options =
            static_cast<AllegroFlare::DialogTree::Nodes::MultipageWithOptions*>(active_dialog_node);

         // TODO: Consider case where dialog node has no (empty) options
         if (!(selection_choice >= 0))
         {
            throw std::runtime_error(
               "DialogSystem::activate_dialog_option: error: selection_choice must be >= 0"
            );
         }
         if (!(selection_choice < as_multipage_with_options ->num_options()))
         {
            throw std::runtime_error(
               "DialogSystem::activate_dialog_option: error: selection_choice must be less than the num options"
            );
         }

         AllegroFlare::DialogTree::NodeOptions::Base* node_option =
            as_multipage_with_options->get_option_num(selection_choice).second;
         std::string node_option_type = node_option->get_type();
   
         std::map<std::string, std::function<void()>> types_map = {
            { AllegroFlare::DialogTree::NodeOptions::ExitDialog::TYPE, [this, node_option]() {
               AllegroFlare::DialogTree::NodeOptions::ExitDialog* as_exit_dialog_node_option =
                  static_cast<AllegroFlare::DialogTree::NodeOptions::ExitDialog*>(node_option);

               //event_emitter->emit_dialog_close_event();
               shutdown_dialog(); // TODO: See if this is a correct expectation for this event
            }},
            { AllegroFlare::DialogTree::NodeOptions::GoToNode::TYPE, [this, node_option]() {
               // TODO: Test this case
               AllegroFlare::DialogTree::NodeOptions::GoToNode* as_go_to_node_dialog_node_option =
                  static_cast<AllegroFlare::DialogTree::NodeOptions::GoToNode*>(node_option);
               std::string target_node_name = as_go_to_node_dialog_node_option->get_target_node_name();

               //event_emitter->emit_dialog_open_event(target_node_name);
               spawn_dialog_by_name(target_node_name);
            }},
         };

         // locate and call the function to handle the item
         if (types_map.count(node_option_type) == 0)
         {
            // item not found
            std::stringstream error_message;
            error_message << "[DialogTree::NodeOptionActivator::activate]: error: Cannot activate a node with the "
                          << "node_option_type \"" << node_option_type << "\", a handling for that type does not exist.";
            throw std::runtime_error(error_message.str());
         }
         else
         {
            // call the item
            types_map[node_option_type]();
         }
      }
      else
      {
         throw std::runtime_error(
            "DialogSystem::activate_dialog_option: error: Unable to handle case where dialog *node* is of type \""
               + active_dialog_node->get_type() + "\"."
         );
      }

      return;
    body_dependency_symbols:
      - std::function
      - AllegroFlare::DialogTree::NodeOptions::ExitDialog
      - AllegroFlare::DialogTree::NodeOptions::GoToNode


  - name: dialog_is_finished
    type: bool
    guards: [ initialized, active_dialog_box ]
    body: |
      return active_dialog_box->get_finished();


  - name: shutdown_dialog
    type: bool
    guards: [ initialized ]
    body: |
      if (!active_dialog_box) return false;
      delete active_dialog_box; // TODO: Consider a less intrusive soft delete (with cleanup during update)
      active_dialog_box = nullptr;

      active_dialog_node = nullptr;
      active_dialog_node_name = "";

      // NOTE: Note that active_dialog_node is not deleted, because any pointer to a dialog node is a pointer
      // to one that is static in the dialog_node_bank
      if (get_switched_in())
      {
         switch_out();
         event_emitter->emit_dialog_switch_out_event();
      }
      return true;


  - name: move_dialog_cursor_position_up
    guards: [ initialized ]
    body: |
      if (!active_dialog_box) return;
      active_dialog_box->move_cursor_position_up();
      if (active_dialog_box->is_type(AllegroFlare::Elements::DialogBoxes::Choice::TYPE))
      {
         AllegroFlare::Elements::DialogBoxes::Choice *as_choice_dialog_box =
               static_cast<AllegroFlare::Elements::DialogBoxes::Choice*>(active_dialog_box);

         // Set the cursor selection box position to this point
         AllegroFlare::Elements::DialogBoxRenderers::ChoiceRenderer choice_renderer_for_dimensions(
            font_bin,
            bitmap_bin,
            as_choice_dialog_box
         );

         std::tuple<float, float, float, float> selection_dimensions =
               choice_renderer_for_dimensions.calculate_dimensions_of_current_selection();
         choice_renderer_for_dimensions.helper__reposition_selection_cursor_box_dimensions_to(
               &selection_cursor_box,
               selection_dimensions
            );
      }
      return;


  - name: move_dialog_cursor_position_down
    guards: [ initialized ]
    body: |
      if (!active_dialog_box) return;
      active_dialog_box->move_cursor_position_down();
      // TODO: Reposition the cursor
      if (active_dialog_box->is_type(AllegroFlare::Elements::DialogBoxes::Choice::TYPE))
      {
         AllegroFlare::Elements::DialogBoxes::Choice *as_choice_dialog_box =
               static_cast<AllegroFlare::Elements::DialogBoxes::Choice*>(active_dialog_box);

         // Set the cursor selection box position to this point
         AllegroFlare::Elements::DialogBoxRenderers::ChoiceRenderer choice_renderer_for_dimensions(
            font_bin,
            bitmap_bin,
            as_choice_dialog_box
         );

         std::tuple<float, float, float, float> selection_dimensions =
               choice_renderer_for_dimensions.calculate_dimensions_of_current_selection();
         choice_renderer_for_dimensions.helper__reposition_selection_cursor_box_dimensions_to(
               &selection_cursor_box,
               selection_dimensions
            );
      }
      return;


dependencies:


  - symbol: al_is_primitives_addon_initialized
    headers: [ allegro5/allegro_primitives.h ]
  - symbol: AllegroFlare::FontBin
    headers: [ AllegroFlare/FontBin.hpp ]
  - symbol: AllegroFlare::EventNames
    headers: [ AllegroFlare/EventNames.hpp ]
  - symbol: AllegroFlare::DialogSystem::DialogEventDatas::CloseDialog
    headers: [ AllegroFlare/DialogSystem/DialogEventDatas/CloseDialog.hpp ]
  - symbol: AllegroFlare::Elements::DialogBoxes::YouGotEvidence
    headers: [ AllegroFlare/Elements/DialogBoxes/YouGotEvidence.hpp ]
  - symbol: AllegroFlare::Elements::DialogBoxes::Base
    headers: [ AllegroFlare/Elements/DialogBoxes/Base.hpp ]
  - symbol: AllegroFlare::Elements::DialogBoxes::Choice
    headers: [ AllegroFlare/Elements/DialogBoxes/Choice.hpp ]
  - symbol: AllegroFlare::GameEvent
    headers: [ AllegroFlare/GameEvent.hpp ]
  - symbol: AllegroFlare::GameEventDatas::Base
    headers: [ AllegroFlare/GameEventDatas/Base.hpp ]
  - symbol: AllegroFlare::Elements::DialogBoxRenderer
    headers: [ AllegroFlare/Elements/DialogBoxRenderer.hpp ]
  - symbol: AllegroFlare::BitmapBin
    headers: [ AllegroFlare/BitmapBin.hpp ]
  - symbol: AllegroFlare::Elements::DialogBoxes::Basic
    headers: [ AllegroFlare/Elements/DialogBoxes/Basic.hpp ]
  - symbol: AllegroFlare::Elements::DialogBoxes::YouGotAnItem
    headers: [ AllegroFlare/Elements/DialogBoxes/YouGotAnItem.hpp ]
  - symbol: AllegroFlare::Elements::DialogBoxes::YouGotAnItem
    headers: [ AllegroFlare/Elements/DialogBoxes/YouGotAnItem.hpp ]
  - symbol: AllegroFlare::InventoryDictionaryItems::WithAttributes
    headers: [ AllegroFlare/InventoryDictionaryItems/WithAttributes.hpp ]
  - symbol: AllegroFlare::Elements::DialogBoxFactory
    headers: [ AllegroFlare/Elements/DialogBoxFactory.hpp ]
  - symbol: AllegroFlare::DialogSystem::DialogEventDatas::CreateYouGotAnItemDialog
    headers: [ AllegroFlare/DialogSystem/DialogEventDatas/CreateYouGotAnItemDialog.hpp ]
  - symbol: AllegroFlare::DialogSystem::DialogEventDatas::CreateYouGotEvidenceDialog
    headers: [ AllegroFlare/DialogSystem/DialogEventDatas/CreateYouGotEvidenceDialog.hpp ]
  - symbol: AllegroFlare::EventEmitter
    headers: [ AllegroFlare/EventEmitter.hpp ]
  - symbol: AllegroFlare::DialogTree::NodeBank
    headers: [ AllegroFlare/DialogTree/NodeBank.hpp ]
  - symbol: AllegroFlare::DialogTree::Nodes::Base
    headers: [ AllegroFlare/DialogTree/Nodes/Base.hpp ]
  - symbol: std::filesystem::exists
    headers: [ filesystem ]
  - symbol: AllegroFlare::DialogTree::YAMLLoader
    headers: [ AllegroFlare/DialogTree/YAMLLoader.hpp ]
  - symbol: AllegroFlare::DialogTree::NodeOptions::GoToNode
    headers: [ AllegroFlare/DialogTree/NodeOptions/GoToNode.hpp ]
  - symbol: AllegroFlare::DialogTree::NodeOptions::ExitDialog
    headers: [ AllegroFlare/DialogTree/NodeOptions/ExitDialog.hpp ]
  - symbol: AllegroFlare::DialogTree::Nodes::MultipageWithOptions
    headers: [ AllegroFlare/DialogTree/Nodes/MultipageWithOptions.hpp ]
  - symbol: AllegroFlare::Elements::SelectionCursorBox
    headers: [ AllegroFlare/Elements/SelectionCursorBox.hpp ]
  - symbol: AllegroFlare::Elements::DialogBoxRenderers::ChoiceRenderer
    headers: [ AllegroFlare/Elements/DialogBoxRenderers/ChoiceRenderer.hpp ]


