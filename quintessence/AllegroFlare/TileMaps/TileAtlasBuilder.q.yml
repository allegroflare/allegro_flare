properties:


  - name: MIN_VALID_CREATE_PIXEL_PERFECT_SCALED_RENDER_SCALE_VALUE
    type: std::size_t
    init_with: 1
    static: true
    constexpr: true

  - name: MAX_VALID_CREATE_PIXEL_PERFECT_SCALED_RENDER_SCALE_VALUE
    type: std::size_t
    init_with: 6
    static: true
    constexpr: true


documentation:


  - notes:
      - create_extruded will create a new bitmap given bitmaps that already exist in a tile_index. The new bitmap will
        be an atlas bitmap that combines all the bitmaps to a single bitmap, with the eadges of each extruded. For this
        feature, all bitmaps that are in the tile_index must be the same dimensions.

  - todos:
      - Fix argument order in "create_scaled_and_extruded"
      - Consider renaming this? TileMeshAtlasBuilder?
      - Note this class could be used to combine arbitrary bitmaps into a single sheet with extrusions
        and pixel perfect scale.


methods:


  - name: create_extruded
    type: ALLEGRO_BITMAP*
    static: true
    parameters:
      - name: tile_index_
        type: std::vector<AllegroFlare::TileMaps::PrimMeshAtlasIndexRecord>*
        default_argument: nullptr
    guards:
       - tile_index_
       - (!tile_index_->empty())
       - validate_all_sub_bitmaps_in_tile_index_are_identical_sizes(tile_index_)
    body: |
      std::vector<AllegroFlare::TileMaps::PrimMeshAtlasIndexRecord> &tile_index = *tile_index_;

      // Get the dimensions of the tile_index bitmaps
      ALLEGRO_BITMAP *first_sub_bitmap = tile_index[0].get_sub_bitmap();
      if (!first_sub_bitmap)
      {
         // TODO: Test this
         AllegroFlare::Logger::throw_error(
            "AllegroFlare::TileMaps::TileAtlasBuilder::create_extruded",
            "Tile first element in the tile_index does not contain a sub_bitmap"
         );
      }
      int tile_width = al_get_bitmap_width(first_sub_bitmap);
      int tile_height = al_get_bitmap_height(first_sub_bitmap);
      int num_tiles_in_tile_index = tile_index.size();


      // Calculate the final width and height of the atlas bitmap (adding a 1px border)
      int effective_tile_width = tile_width + 2;
      int effective_tile_height = tile_height + 2;
      int tiles_per_row = std::ceil(std::sqrt(num_tiles_in_tile_index));
      int rows = std::ceil(static_cast<float>(num_tiles_in_tile_index) / tiles_per_row);
      int atlas_width = tiles_per_row * effective_tile_width;
      int atlas_height = rows * effective_tile_height;

      //
      // Render the tiles to the final bitmap
      //

      AllegroFlare::Logger::info_from(
         "AllegroFlare::TileMaps::TileAtlasBuilder::create_extruded",
         "Creating a surface of " + std::to_string(atlas_width) + "x" + std::to_string(atlas_height) + " to assemble "
            "a tile atlas for \"" + std::to_string(num_tiles_in_tile_index) + "\" tiles that are (" +
            std::to_string(tile_width) + "+2)x(" + std::to_string(tile_height) + "+2)."
      );

      // TODO: Consider: al_set_new_bitmap_flags(ALLEGRO_MIN_LINEAR | ALLEGRO_MAG_LINEAR | ALLEGRO_MIPMAP);
      ALLEGRO_STATE prev;
      al_store_state(&prev, ALLEGRO_STATE_TARGET_BITMAP);
      ALLEGRO_BITMAP *target = al_create_bitmap(atlas_width, atlas_height);
      al_set_target_bitmap(target);
      al_clear_to_color(al_map_rgba_f(0, 0, 0, 0));

      int step_x = tile_width + 2;
      int step_y = tile_height + 2;
      int num_rows = al_get_bitmap_height(target) / step_y;
      int num_cols = al_get_bitmap_width(target) / step_x;


      // Draw each tile onto the new tile_atlas bitmap, each with an extra padding of 1px
      for (int y=0; y<num_rows; y++)
      {
         for (int x=0; x<num_cols; x++)
         {
            int index_num = x + y*num_cols;
            if (index_num >= (int)tile_index.size()) goto tile_drawing_finished;

            int draw_x = x*step_x + 1;
            int draw_y = y*step_y + 1;

            al_draw_bitmap(tile_index[index_num].get_sub_bitmap(), draw_x, draw_y, 0);
         }
      }
      tile_drawing_finished:


      // Draw the extruded pixels on the edges of each tile
      for (int y=0; y<num_rows; y++)
      {
         for (int x=0; x<num_cols; x++)
         {
            int index_num = x + y*num_cols;
            if (index_num >= (int)tile_index.size()) goto edge_extruding_finished;

            int draw_x = x*step_x + 1;
            int draw_y = y*step_y + 1;


            // draw the top row of pixels
            al_set_clipping_rectangle(draw_x, draw_y-1, tile_width, 1);
            al_draw_bitmap(tile_index[index_num].get_sub_bitmap(), draw_x, draw_y-1, 0);

            // draw the bottom row of pixels
            al_set_clipping_rectangle(draw_x, draw_y+tile_height, tile_width, 1);
            al_draw_bitmap(tile_index[index_num].get_sub_bitmap(), draw_x, draw_y+1, 0);

            // draw the left row of pixels
            al_set_clipping_rectangle(draw_x-1, draw_y, 1, tile_height);
            al_draw_bitmap(tile_index[index_num].get_sub_bitmap(), draw_x-1, draw_y, 0);

            // draw the right row of pixels
            al_set_clipping_rectangle(draw_x+tile_width, draw_y, 1, tile_height);
            al_draw_bitmap(tile_index[index_num].get_sub_bitmap(), draw_x+1, draw_y, 0);


            // draw just the top-left pixel
            al_set_clipping_rectangle(draw_x-1, draw_y-1, 1, 1);
            al_draw_bitmap(tile_index[index_num].get_sub_bitmap(), draw_x-1, draw_y-1, 0);

            // draw just the bottom-left pixel
            al_set_clipping_rectangle(draw_x-1, draw_y+tile_height, 1, 1);
            al_draw_bitmap(tile_index[index_num].get_sub_bitmap(), draw_x-1, draw_y+1, 0);

            // draw just the top-right pixel
            al_set_clipping_rectangle(draw_x+tile_width, draw_y-1, 1, 1);
            al_draw_bitmap(tile_index[index_num].get_sub_bitmap(), draw_x+1, draw_y-1, 0);

            // draw just the top-right pixel
            al_set_clipping_rectangle(draw_x+tile_width, draw_y+tile_height, 1, 1);
            al_draw_bitmap(tile_index[index_num].get_sub_bitmap(), draw_x+1, draw_y+1, 0);
         }
      }
      edge_extruding_finished:

      //
      // Clean up
      //

      // Restore the clipping rectangle
      al_set_clipping_rectangle(0, 0, al_get_bitmap_width(target), al_get_bitmap_height(target));

      // Restore the target
      al_restore_state(&prev);

      //
      // Solve an odd bug, the bitmap will be cloned so that OPENGL will correctly create the mipmaps
      // TODO: Look into if this is still necessary
      //

      ALLEGRO_BITMAP *cloned = al_clone_bitmap(target);
      al_destroy_bitmap(target);
      target = cloned;

      return target;
    body_dependency_symbols:
      - std::ceil
      - std::sqrt


  - name: create_scaled_and_extruded
    type: ALLEGRO_BITMAP*
    static: true
    parameters:
      - name: original_bitmap
        type: ALLEGRO_BITMAP*
        default_argument: nullptr
      - name: scale
        type: int
        default_argument: 3
      - name: tile_width
        type: int
        default_argument: 16
      - name: tile_height
        type: int
        default_argument: 16
    guards: [ al_is_system_installed() ]
    body: |
      // TODO: Confirm the lifecycle of the created bitmaps
      ALLEGRO_BITMAP *scaled = TileAtlasBuilder::create_pixel_perfect_scaled_render(original_bitmap, scale);
      AllegroFlare::TileMaps::PrimMeshAtlas atlas;
      atlas.duplicate_bitmap_and_load(scaled, tile_width*scale, tile_height*scale, 0);
      al_destroy_bitmap(scaled);
      std::vector<AllegroFlare::TileMaps::PrimMeshAtlasIndexRecord> tile_index = atlas.get_tile_index();
      ALLEGRO_BITMAP *result = AllegroFlare::TileMaps::TileAtlasBuilder::create_extruded(&tile_index);
      atlas.destroy();
      return result;
    body_dependency_symbols:
      - al_is_system_installed
      - AllegroFlare::TileMaps::PrimMeshAtlas
      - AllegroFlare::Logger


  - name: create_pixel_perfect_scaled_render
    type: ALLEGRO_BITMAP*
    static: true
    parameters:
      - name: bitmap
        type: ALLEGRO_BITMAP*
        default_argument: nullptr
      - name: scale
        type: int
        default_argument: 3
    guards:
      - bitmap
      - (scale >= MIN_VALID_CREATE_PIXEL_PERFECT_SCALED_RENDER_SCALE_VALUE)
      - (scale <= MAX_VALID_CREATE_PIXEL_PERFECT_SCALED_RENDER_SCALE_VALUE)
    body: |
      AllegroFlare::ImageProcessing image_processing(bitmap);
      ALLEGRO_BITMAP *scaled = image_processing.create_pixel_perfect_scaled_render(scale);
      return scaled;
    body_dependency_symbols:
      - AllegroFlare::ImageProcessing


  - name: validate_all_sub_bitmaps_in_tile_index_are_identical_sizes
    type: bool
    static: true
    parameters:
      - name: tile_index_
        type: std::vector<AllegroFlare::TileMaps::PrimMeshAtlasIndexRecord>*
        default_argument: nullptr
    guards: [ tile_index_ ]
    body: |
      std::vector<AllegroFlare::TileMaps::PrimMeshAtlasIndexRecord> &tile_index = *tile_index_;
      
      // TODO: Test this
      if (tile_index.empty()) return true;

      ALLEGRO_BITMAP *sub_bitmap = tile_index[0].get_sub_bitmap();
      if (!sub_bitmap)
      {
         AllegroFlare::Logger::throw_error(
            "AllegroFlare::TileMaps::TileAtlasBuilder::validate_all_sub_bitmaps_in_tile_index_are_identical_sizes",
            "There is no sub_bitmap present on the first item in the tile_index."
         );
      }
      int baseline_width = al_get_bitmap_width(sub_bitmap);
      int baseline_height = al_get_bitmap_height(sub_bitmap);

      for (int i=0; i<tile_index.size(); i++)
      //for (auto &tile_index_record : tile_index)
      {
         auto &tile_index_record = tile_index[i];
         ALLEGRO_BITMAP *sub_bitmap = tile_index_record.get_sub_bitmap();
         if (!sub_bitmap)
         {
            AllegroFlare::Logger::throw_error(
               "AllegroFlare::TileMaps::TileAtlasBuilder::validate_all_sub_bitmaps_in_tile_index_are_identical_sizes",
               "There is no sub_bitmap present on item at index \"" + std::to_string(i) + "\" in the tile_index."
            );
         }
         int width = al_get_bitmap_width(sub_bitmap);
         int height = al_get_bitmap_height(sub_bitmap);

         if (width != baseline_width || height != baseline_height)
         {
            return false;
         }
      }
      return true;


dependencies:


  - symbol: AllegroFlare::TileMaps::PrimMeshAtlasIndexRecord
    headers: [ AllegroFlare/TileMaps/PrimMeshAtlasIndexRecord.hpp ]
  - symbol: ALLEGRO_BITMAP
    headers: [ allegro5/allegro.h ]
  - symbol: AllegroFlare::TileMaps::PrimMeshAtlas
    headers: [ AllegroFlare/TileMaps/PrimMeshAtlas.hpp ]
  - symbol: AllegroFlare::Logger
    headers: [ AllegroFlare/Logger.hpp ]
  - symbol: AllegroFlare::ImageProcessing
    headers: [ AllegroFlare/ImageProcessing.hpp ]
  - symbol: al_is_system_installed
    headers: [ allegro5/allegro.h ]
  - symbol: std::ceil
    headers: [ cmath ]
  - symbol: std::sqrt
    headers: [ cmath ]


