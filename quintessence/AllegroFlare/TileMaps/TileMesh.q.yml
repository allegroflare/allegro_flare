properties:


  - name: atlas
    type: AllegroFlare::TileMaps::PrimMeshAtlas*
    init_with: nullptr
    constructor_arg: true
    getter: true
    setter: true

  - name: vertices
    type: std::vector<ALLEGRO_VERTEX>
    init_with: ''
    getter_ref: true

  - name: vertex_buffer
    type: ALLEGRO_VERTEX_BUFFER*
    init_with: nullptr

  - name: index_buffer
    type: ALLEGRO_INDEX_BUFFER*
    init_with: nullptr

  - name: tile_ids
    type: std::vector<int>
    init_with: '{}'
    getter: true

  - name: index_vertices
    type: std::vector<int>
    init_with: '{}'
    getter: true

  - name: h_flipped_tiles
    type: std::set<std::pair<int, int>>
    init_with: '{}'
    getter: true

  - name: v_flipped_tiles
    type: std::set<std::pair<int, int>>
    init_with: '{}'
    getter: true

  - name: num_columns
    type: int
    init_with: 0
    constructor_arg: true
    getter: true
    setter: explicit

  - name: num_rows
    type: int
    init_with: 0
    constructor_arg: true
    getter: true
    setter: explicit

  - name: tile_width
    type: int
    init_with: 1
    constructor_arg: true
    getter: true
    setter: explicit

  - name: tile_height
    type: int
    init_with: 1
    constructor_arg: true
    getter: true
    setter: explicit

  - name: holding_vertex_buffer_update_until_refresh
    type: bool
    init_with: false
    getter: true

  - name: vertex_buffer_is_dirty
    type: bool
    init_with: false
    getter: true

  - name: yz_swapped
    type: bool
    init_with: false

  - name: initialized
    type: bool
    init_with: false
    getter: true
    setter: false


documentation:


  - notes:
     - This class is the evolutionary replacement for TileMaps/PrimMesh. It includes uses vertex_buffer and has features
       for postponing a vertex_buffer refresh. Feel free to optimize this!
  - todos:
     - Add a pruning feature (Make is to that "empty" tiles can be present in the tile_ids<>, but do not draw them)
        - Consider adding an index buffer so that empty tiles are not rendered
        - Consider *removing* empty tile vertices from the vertices<>.
     - Consider adding an index buffer feature, breaking the map into sections so that off-screen draws can be bypassed


methods:


  - name: initialize
    guards:
      - (!initialized)
      - al_is_system_installed()
      - al_is_primitives_addon_initialized()
    body: |
      initialized = true;
      resize(num_columns, num_rows);
      return;
    body_dependency_symbols:
      - al_is_system_installed
      - al_is_primitives_addon_initialized


  - name: set_num_rows
    parameters:
      - name: num_rows
        type: int
        default_argument: 0
    guards: [ (num_rows >= 0) ]
    body: |
      this->num_rows = num_rows;
      if (initialized) resize(num_columns, num_rows);


  - name: set_num_columns
    parameters:
      - name: num_columns
        type: int
        default_argument: 0
    guards: [ (num_columns >= 0) ]
    body: |
      this->num_columns = num_columns;
      if (initialized) resize(num_columns, num_rows);


  - name: remove_tile_xy_from_index
    type: int
    parameters:
      - name: tile_x
        type: int
        default_argument: 0
      - name: tile_y
        type: int
        default_argument: 0
    body: |
      return remove_vertices_from_index_vertices(vertex_indices_for_tile_xy(tile_x, tile_y));


  - name: remove_vertices_from_index_vertices
    type: int
    parameters:
      - name: vertices_to_remove
        type: std::vector<int>
        default_argument: '{}'
    body: |
      int num_removed = 0;

      for (int i=0; i<index_vertices.size(); i++)
      {
         bool vertices_found = false;

         if (std::find(vertices_to_remove.begin(), vertices_to_remove.end(), index_vertices[i]) == vertices_to_remove.end()) continue;

         index_vertices.erase(index_vertices.begin() + i);
         i--; // Adjust index since element was removed
         num_removed++;
      }

      // Completely rebuild the vertex indexes
      if (index_buffer) al_destroy_index_buffer(index_buffer);
      int num_index_vertices = index_vertices.size();
      int index_buffer_int_size = 4; // 4 is the size of a normal "int". If we were to use a "short int", then 2.
      index_buffer = al_create_index_buffer(
            index_buffer_int_size,
            &index_vertices[0],
            index_vertices.size(),
            ALLEGRO_PRIM_BUFFER_DYNAMIC
         );

      return num_removed;


  - name: vertex_indices_for_tile_xy
    type: std::vector<int>
    parameters:
      - name: tile_x
        type: int
        default_argument: 0
      - name: tile_y
        type: int
        default_argument: 0
    guards: [ (tile_x >= 0), (tile_x < num_columns), (tile_y >= 0), (tile_y < num_rows) ]
    body: |
      // TODO: Test and try using this method
      int first_vertex_index = (tile_x + tile_y * num_columns) * 6;
      return std::vector<int>{
         first_vertex_index+0,
         first_vertex_index+1,
         first_vertex_index+2,
         first_vertex_index+3,
         first_vertex_index+4,
         first_vertex_index+5,
      };


  - name: destroy
    body: |
      if (vertex_buffer) al_destroy_vertex_buffer(vertex_buffer);
      return;


  - name: enable_holding_vertex_buffer_update_until_refresh
    body: |
      holding_vertex_buffer_update_until_refresh = true;
      return;


  - name: resize
    parameters:
      - name: num_columns
        type: int
        default_argument: 0
      - name: num_rows
        type: int
        default_argument: 0
    guards: [ initialized ]
    body: |
      this->num_columns = num_columns;
      this->num_rows = num_rows;

      // resize the vertices vector
      vertices.clear();
      tile_ids.clear();
      vertices.resize(num_columns*num_rows*6);
      tile_ids.resize(num_columns*num_rows);
      index_vertices.clear();
      index_vertices.resize(vertices.size());
      h_flipped_tiles.clear();
      v_flipped_tiles.clear();
      if (vertex_buffer) al_destroy_vertex_buffer(vertex_buffer);
      if (index_buffer) al_destroy_index_buffer(index_buffer);

      // place the vertices in the mesh
      int num_vertices = num_columns*num_rows*6;
      for (int v=0; v<num_vertices; v+=6)
      {
         long tile_num = v / 6;

         int x1 = (tile_num % num_columns);
         int y1 = (tile_num / num_columns);
         int x2 = x1 + 1;
         int y2 = y1 + 1;

         vertices[v+0].x = x1;
         vertices[v+0].y = y1;
         vertices[v+1].x = x1;
         vertices[v+1].y = y2;
         vertices[v+2].x = x2;
         vertices[v+2].y = y2;
         vertices[v+3].x = x2;
         vertices[v+3].y = y2;
         vertices[v+4].x = x2;
         vertices[v+4].y = y1;
         vertices[v+5].x = x1;
         vertices[v+5].y = y1;
      }

      // Scale the vertices to the tile_w and tile_h and set other default values
      for (int v=0; v<num_vertices; v++)
      {
         vertices[v].x *= tile_width;
         vertices[v].y *= tile_height;
         vertices[v].z = 0;
         vertices[v].color = al_map_rgba_f(1, 1, 1, 1);
      }

      // Create the vertex buffer, duplicate the vertices into it
      vertex_buffer = al_create_vertex_buffer(NULL, &vertices[0], vertices.size(), ALLEGRO_PRIM_BUFFER_DYNAMIC);

      // Build the vertex indexes
      int num_index_vertices = index_vertices.size();
      for (int i=0; i<num_index_vertices; i++) index_vertices[i] = i;
      int index_buffer_int_size = 4; // 4 is the size of a normal "int". If we were to use a "short int", then 2.
      index_buffer = al_create_index_buffer(
            index_buffer_int_size,
            &index_vertices[0],
            index_vertices.size(),
            ALLEGRO_PRIM_BUFFER_DYNAMIC
         );

      vertex_buffer_is_dirty = false;

      if (yz_swapped)
      {
         swap_yz();
         yz_swapped = true; // NOTE: This is a bit of an akward way to re-assign yz_swapped
                            // simply because swap_yz() toggles the yz_swapped value.
      }
      return;


  - name: render
    parameters:
      - name: draw_outline
        type: bool
        default_argument: false
    guards: [ initialized, atlas, (!vertex_buffer_is_dirty) ]
    body: |
      al_draw_indexed_buffer(
         vertex_buffer,
         atlas->get_bitmap(),
         index_buffer,
         0,
         //vertices.size(),  // vertex_buffer? should be index_buffer?
         index_vertices.size(),  // vertex_buffer? should be index_buffer?
         ALLEGRO_PRIM_TRIANGLE_LIST
      );

      if (draw_outline)
      {
         al_draw_rectangle(0, 0, num_columns * tile_width, num_rows * tile_height, ALLEGRO_COLOR{1, 0, 1, 1}, 2.0);
      }
      return;


  - name: set_tile_id
    type: bool
    parameters:
      - name: tile_x
        type: int
        default_argument: 0
      - name: tile_y
        type: int
        default_argument: 0
      - name: tile_id
        type: int
        default_argument: 0
      - name: flip_h
        type: bool
        default_argument: false
      - name: flip_v
        type: bool
        default_argument: false
    guards: [ initialized, atlas ]
    body: |
      if (tile_id >= (int)atlas->get_tile_index_size()) return false;
      //if (!initialized) throw std::runtime_error("[AllegroFlare::PrimMesh::set_tile_id] error: must be initialized first");

      // if the tile_id is a negative number, use the number "0" instead
      // I'm not sure how/why this is the preferred approach.  I think negative numbers
      // should be allowed, any number should be allowed.  So this should be revisited
      if (tile_id < 0) tile_id = 0;

      int u1, v1, u2, v2;
      atlas->get_tile_uv(tile_id, &u1, &v1, &u2, &v2);

      if (flip_h)
      {
         h_flip_vertices(&u1, &v1, &u2, &v2);
         h_flipped_tiles.insert({tile_x, tile_y});
      }
      else
      {
         h_flipped_tiles.erase({tile_x, tile_y});
      }
      if (flip_v)
      {
         v_flip_vertices(&u1, &v1, &u2, &v2);
         v_flipped_tiles.insert({tile_x, tile_y});
      }
      else
      {
         v_flipped_tiles.erase({tile_x, tile_y});
      }

      set_tile_uv(tile_x, tile_y, u1, v1, u2, v2);

      tile_ids[tile_x + tile_y * num_columns] = tile_id;
      
      return true;


  - name: get_tile_id
    type: int
    parameters:
      - name: tile_x
        type: int
        default_argument: 0
      - name: tile_y
        type: int
        default_argument: 0
    body: |
      if (tile_x < 0) return 0;
      if (tile_x >= num_columns) return 0;
      if (tile_y < 0) return 0;
      if (tile_y >= num_rows) return 0;

      return tile_ids[tile_x + tile_y * num_columns];
      return 0;


  - name: get_tile_flip
    type: std::pair<bool, bool>
    parameters:
      - name: tile_x
        type: int
        default_argument: 0
      - name: tile_y
        type: int
        default_argument: 0
    body: |
      if (tile_x < 0) return { false, false };
      if (tile_x >= num_columns) return { false, false };
      if (tile_y < 0) return { false, false };
      if (tile_y >= num_rows) return { false, false };

      bool is_h_flipped = h_flipped_tiles.find({ tile_x, tile_y }) != h_flipped_tiles.end();
      bool is_v_flipped = v_flipped_tiles.find({ tile_x, tile_y }) != v_flipped_tiles.end();

      return { is_h_flipped, is_v_flipped };


  - name: h_flip_vertices
    private: true
    parameters:
      - name: u1
        type: int*
        default_argument: nullptr
      - name: v1
        type: int*
        default_argument: nullptr
      - name: u2
        type: int*
        default_argument: nullptr
      - name: v2
        type: int*
        default_argument: nullptr
    guards: [ u1, v1, u2, v2 ]
    body: |
      // NOTE: Should the uv coordinates be floats?
      int swap = *u1;
      *u1 = *u2;
      *u2 = swap;
      return;


  - name: v_flip_vertices
    private: true
    parameters:
      - name: u1
        type: int*
        default_argument: nullptr
      - name: v1
        type: int*
        default_argument: nullptr
      - name: u2
        type: int*
        default_argument: nullptr
      - name: v2
        type: int*
        default_argument: nullptr
    guards: [ u1, v1, u2, v2 ]
    body: |
      // NOTE: Should the uv coordinates be floats?
      int swap = *v1;
      *v1 = *v2;
      *v2 = swap;
      return;


  - name: set_tile_uv
    parameters:
      - name: tile_x
        type: int
        default_argument: 0
      - name: tile_y
        type: int
        default_argument: 0
      - name: u1
        type: int
        default_argument: 0
      - name: v1
        type: int
        default_argument: 0
      - name: u2
        type: int
        default_argument: 0
      - name: v2
        type: int
        default_argument: 0
    body: |
      // NOTE: Should the uv coordinates be floats?
      int tile_index_start = (tile_x * 6) + tile_y * (num_columns*6);
      int &i = tile_index_start;

      // Modify the vertex
      vertices[i+0].u = u1;
      vertices[i+0].v = v1;
      vertices[i+1].u = u1;
      vertices[i+1].v = v2;
      vertices[i+2].u = u2;
      vertices[i+2].v = v2;
      vertices[i+3].u = u2;
      vertices[i+3].v = v2;
      vertices[i+4].u = u2;
      vertices[i+4].v = v1;
      vertices[i+5].u = u1;
      vertices[i+5].v = v1;

      if (holding_vertex_buffer_update_until_refresh)
      {
         vertex_buffer_is_dirty = true;
      }
      else
      {
         // Upate the vertex in the vertex buffer
         // Consider only locking the region that needs the change
         refresh_vertex_buffer();
      }
      return;


  - name: refresh_vertex_buffer
    body: |
      int num_vertices = infer_num_vertices();
      ALLEGRO_VERTEX* vertex_buffer_start = (ALLEGRO_VERTEX*)al_lock_vertex_buffer(
         vertex_buffer,
         0,
         num_vertices,
         ALLEGRO_LOCK_WRITEONLY
      );

      for (int v=0; v<num_vertices; v++) vertex_buffer_start[v] = vertices[v];

      al_unlock_vertex_buffer(vertex_buffer);

      vertex_buffer_is_dirty = false;
      return;


  - name: infer_num_vertices
    type: int
    body: |
      return num_columns * num_rows * 6;


  - name: infer_num_tiles
    type: int
    body: |
      return num_rows * num_columns;


  - name: rescale_tile_dimensions_to
    parameters:
      - name: new_tile_width
        type: int
        default_argument: 0
      - name: new_tile_height
        type: int
        default_argument: 0
    body: |
      int old_tile_width = this->tile_width;
      int old_tile_height = this->tile_height;

      if (new_tile_width <= 0 || new_tile_height <= 0)
      {
         // TODO: test this assertion
         std::stringstream error_message;
         error_message << "AllegroFlare::TileMaps::PrimMesh::rescale_tile_dimensions_to: error: "
                       << "new_tile_width and/or new_tile_height cannot be less than or equal to zero.";
         throw std::runtime_error(error_message.str());
      }

      int num_vertices = infer_num_vertices();
      //ALLEGRO_VERTEX* vertex_buffer_start = (ALLEGRO_VERTEX*)al_lock_vertex_buffer(
         //vertex_buffer,
         //0,
         //num_vertices,
         //ALLEGRO_LOCK_WRITEONLY
      //);

      for (int v=0; v<num_vertices; v++)
      {
         vertices[v].x = vertices[v].x / old_tile_width * new_tile_width;
         vertices[v].y = vertices[v].y / old_tile_height * new_tile_height;
         vertices[v].z = vertices[v].z / old_tile_height * new_tile_height;

         //vertex_buffer_start[v] = vertices[v];
      }

      //al_unlock_vertex_buffer(vertex_buffer);

      if (holding_vertex_buffer_update_until_refresh) vertex_buffer_is_dirty = true;
      else refresh_vertex_buffer();

      this->tile_width = new_tile_width;
      this->tile_height = new_tile_height;
      return;


  - name: set_tile_width
    parameters:
      - name: new_tile_width
        type: int
        default_argument: 0
    body: |
      if (!initialized)
      {
         this->tile_width = new_tile_width;
      }
      else
      {
         rescale_tile_dimensions_to(new_tile_width, this->tile_height);
      }
      return;


  - name: set_tile_height
    parameters:
      - name: new_tile_height
        type: int
        default_argument: 0
    body: |
      if (!initialized)
      {
         this->tile_height = new_tile_height;
      }
      else
      {
         rescale_tile_dimensions_to(this->tile_width, new_tile_height);
      }
      return;


  - name: get_real_width
    type: int
    body: |
      // TODO: This should be a float?
      return num_columns * tile_width;
      return 0;


  - name: get_real_height
    type: int
    body: |
      // TODO: This should be a float?
      return num_rows * tile_height;
      return 0;


  - name: swap_yz
    body: |
      if (!initialized) throw std::runtime_error("[AllegroFlare::PrimMesh::swap_yz] error: must be initialized first");


      for (auto &vertex : vertices)
      {
         float swap = vertex.y;
         vertex.y = vertex.z;
         vertex.z = swap;
      }

      // Modify the vertex in the vertex buffer
      if (holding_vertex_buffer_update_until_refresh) vertex_buffer_is_dirty = true;
      else refresh_vertex_buffer();
      
      yz_swapped = !yz_swapped;
      return;


dependencies:


  - symbol: al_is_system_installed
    headers: [ allegro5/allegro.h ]
  - symbol: ALLEGRO_VERTEX
    headers: [ allegro5/allegro.h ]
  - symbol: al_is_primitives_addon_initialized
    headers: [ allegro5/allegro_primitives.h ]
  - symbol: ALLEGRO_INDEX_BUFFER
    headers: [ allegro5/allegro_primitives.h ]
  - symbol: ALLEGRO_VERTEX_BUFFER
    headers: [ allegro5/allegro_primitives.h ]
  - symbol: AllegroFlare::TileMaps::PrimMeshAtlas
    headers: [ AllegroFlare/TileMaps/PrimMeshAtlas.hpp ]


