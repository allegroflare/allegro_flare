properties:


  - name: event_emitter
    type: AllegroFlare::EventEmitter*
    constructor_arg: true
    init_with: nullptr
    getter: true
    setter: true

  - name: font_bin
    type: AllegroFlare::FontBin*
    constructor_arg: true
    init_with: nullptr
    getter: true
    setter: false

  - name: font_name
    type: std::string
    init_with: DEFAULT_FONT_NAME
    constructor_arg: true
    getter: true
    setter: true

  - name: font_size
    type: int
    init_with: -40
    constructor_arg: true
    getter: true
    setter: true

  - name: keys
    type: tsl::ordered_map<std::string, AllegroFlare::SoftwareKeyboard::KeyboardKey>
    init_with: '{}'
    getter_ref: true
    setter: false

  - name: cursor_pos
    type: int
    init_with: 0

  - name: cursor_destination
    type: AllegroFlare::Vec2D
    init_with: '{}'

  - name: cursor_size_destination
    type: AllegroFlare::Vec2D
    init_with: '80, 80'

  - name: cursor_reposition_multiplier
    type: float
    init_with: DEFAULT_CURSOR_REPOSITION_MULTIPLIER
    getter: true
    setter: false

  - name: show_rectangle_outline_on_keys
    type: bool
    init_with: false

  - name: keyboard_placement
    type: AllegroFlare::Placement2D
    init_with: '{}'

  - name: prompt_text
    type: std::string
    init_with: '"Enter your name"'
    getter: true
    setter: true

  - name: result_string
    type: std::string
    init_with: '{}'
    getter: true
    setter: true

  - name: num_permitted_chars
    type: std::size_t
    init_with: 12
    getter: true
    setter: true

  - name: event_to_emit_on_pressing_submit_key
    type: std::string
    init_with: DEFAULT_EVENT_TO_EMIT_ON_PRESSING_SUBMIT_KEY
    getter: true
    setter: true

  - name: on_submit_callback_func
    type: std::function<void(AllegroFlare::SoftwareKeyboard::SoftwareKeyboard*, void*)>
    init_with: ''
    getter: true
    setter: true

  - name: on_submit_callback_func_user_data
    type: void*
    init_with: nullptr
    getter: true
    setter: true

  - name: cursor_location
    type: AllegroFlare::Vec2D
    init_with: '{}'

  - name: cursor_size
    type: AllegroFlare::Vec2D
    init_with: '80, 80'

  - name: showing_input_error_frame
    type: bool
    init_with: false
    getter: true

  - name: input_error_frame_error_messages
    type: std::vector<std::string>
    init_with: '{}'
    getter: true
    setter: true

  - name: bonk_sound_effect_identifier
    type: std::string
    init_with: DEFAULT_BONK_SOUND_EFFECT_IDENTIFIER
    getter: true
    setter: true

  - name: key_click_sound_effect_identifier
    type: std::string
    init_with: DEFAULT_KEY_CLICK_SOUND_EFFECT_IDENTIFIER
    getter: true
    setter: true
   
  - name: erase_sound_effect_identifier
    type: std::string
    init_with: DEFAULT_ERASE_SOUND_EFFECT_IDENTIFIER
    getter: true
    setter: true

  - name: initialized
    type: bool
    init_with: false
    getter: true

  - name: DEFAULT_EVENT_TO_EMIT_ON_PRESSING_SUBMIT_KEY
    type: const char*
    constexpr: true
    static: true
    init_with: '(char*)"submit_software_keyboard"'

  - name: DEFAULT_BONK_SOUND_EFFECT_IDENTIFIER
    type: const char*
    constexpr: true
    static: true
    init_with: '(char*)"ui-input-bonk-01.ogg"'

  - name: DEFAULT_KEY_CLICK_SOUND_EFFECT_IDENTIFIER
    type: const char*
    constexpr: true
    static: true
    init_with: '(char*)"menu-click-01.ogg"'
   
  - name: DEFAULT_ERASE_SOUND_EFFECT_IDENTIFIER
    type: const char*
    constexpr: true
    static: true
    init_with: '(char*)"delete-item-01.ogg"'

  - name: DEFAULT_FONT_NAME
    type: const char*
    constexpr: true
    static: true
    init_with: '(char*)"Inter-Regular.ttf"'

  - name: DEFAULT_CURSOR_REPOSITION_MULTIPLIER
    type: float
    constexpr: true
    static: true
    init_with: 0.6f


documentation:


  - todos:
      - Find a more technically proper name for "cursor_reposition_multiplier", "DEFAULT_CURSOR_REPOSITION_MULTIPLIER"
      - Remove self listed as a dependency in dependencies
      - Consider differences between "hiding" error frame (animating its disappearance), and making it disappear
        instantly. Some cases (for example on reset()) may want it to disappear, while other cases (in use), may want
        it to animate its disappearance.


functions:


  - name: set_font_bin
    parameters:
      - name: font_bin
        type: AllegroFlare::FontBin*
        default_argument: nullptr
    guards: [ (!initialized) ]
    body: |
      this->font_bin = font_bin;
      return;


  - name: reset
    body: |
      reset_with_defaults("", "");
      return;


  - name: reset_with_defaults
    parameters:
      - name: initial_result_string
        type: std::string
        default_argument: '""'
      - name: initial_cursor_position_over_key_name
        type: std::string
        default_argument: '""'
    body: |
      // TODO: Test this method
      cursor_destination = AllegroFlare::Vec2D{0, 0};
      cursor_size_destination = AllegroFlare::Vec2D{80, 80};
      cursor_location = cursor_destination;
      cursor_size = cursor_size_destination;
      showing_input_error_frame = false;
      // TODO: add showing_input_error_frame_at and set to 0.0f here
      input_error_frame_error_messages.clear();
      // TODO: add input_error_frame_error_messages_at and set to 0.0f here
      cursor_pos = 0;
      // TODO: Modify this to position the cursor instantly and silently
      // TODO: Test this
      if (!initial_cursor_position_over_key_name.empty())
      {
         jump_cursor_pos_to_index_of_key_name(initial_cursor_position_over_key_name);
         update_cursor_destination();
         cursor_location = cursor_destination;
      }
      // TODO: test this clear
      result_string = initial_result_string;
      return;


  - name: set_cursor_reposition_multiplier
    parameters:
      - name: cursor_reposition_multiplier
        type: float
        default_argument: DEFAULT_CURSOR_REPOSITION_MULTIPLIER
    guards: [ (cursor_reposition_multiplier > 0.1f), (cursor_reposition_multiplier <= 1.0f) ]
    body: |
      this->cursor_reposition_multiplier = cursor_reposition_multiplier;
      return;


  - name: set_keys
    parameters:
      - name: keys
        type: tsl::ordered_map<std::string, AllegroFlare::SoftwareKeyboard::KeyboardKey>
        default_argument: '{}'
    body: |
      this->keys = keys;
      cursor_pos = 0;
      update_cursor_destination();
      return;


  - name: set_keyboard_dimensions
    parameters:
      - name: width
        type: float
        default_argument: 1
      - name: height
        type: float
        default_argument: 1
    body: |
      keyboard_placement.size.x = width;
      keyboard_placement.size.y = height;
      return;


  - name: set_keyboard_position
    parameters:
      - name: x
        type: float
        default_argument: 0
      - name: y
        type: float
        default_argument: 0
    body: |
      keyboard_placement.position.x = x;
      keyboard_placement.position.y = y;
      return;


  - name: initialize
    guards:
      - al_is_system_installed()
      - al_is_primitives_addon_initialized()
      - al_is_font_addon_initialized()
      - font_bin
      - event_emitter
    body: |
      keyboard_placement.position.x = 1920/2;
      keyboard_placement.position.y = 1080/2;
      initialized = true;
      return;
    body_dependency_symbols:
      - al_is_system_installed
      - al_is_primitives_addon_initialized
      - al_is_font_addon_initialized


  - name: press_key_under_cursor
    body: |
      if (keys.empty()) return;
      int i=0;
      for (auto &key_dictionary_element : keys)
      {
         if (cursor_pos == i)
         {
            press_key_by_name(key_dictionary_element.first);
            return;
         }
         i++;
      }
      return;
      return;


  - name: press_key_by_name
    parameters:
      - name: name
        type: std::string
        default_argument: '"[unset-name]"'
    guards: [ initialized ]
    body: |
      bool this_change_should_dismiss_the_input_error_frame = false;

      if (!key_exists(name))
      {
         // TODO: make this sound effect an option, or, output a warning
         emit_bonk_sound_effect();
         return;
      }
      AllegroFlare::SoftwareKeyboard::KeyboardKey &key = keys[name];

      std::string string_to_append = "";

      if (name == "SPACE")
      {
         if (result_string.empty())
         {
            // do nothing. E.g. do not allow starting a name with a space
            show_input_error_frame({ "cannot start with a space" });
            emit_bonk_sound_effect();
         }
         else if (result_string.back() == ' ')
         {
            // do nothing. E.g. do not allow multiple sequential spaces in a name
            show_input_error_frame({ "cannot have multiple spaces" });
            emit_bonk_sound_effect();
         }
         else
         {
            string_to_append = " ";
            this_change_should_dismiss_the_input_error_frame = true;
         }
      }
      else if (name == "BACKSPACE")
      {
         if (result_string.empty())
         {
            emit_bonk_sound_effect();
            this_change_should_dismiss_the_input_error_frame = true;
         }
         else
         {
            result_string.pop_back();
            emit_erase_sound_effect();
            this_change_should_dismiss_the_input_error_frame = true;
         }
      }
      else if (name == "SUBMIT")
      {
         // TODO: Work out logic to infer if the input error frame shoudl be dismissed or not
         //this_change_should_dismiss_the_input_error_frame = true;
         validate_and_submit_form(); // TODO: Split this into two functions
        // TODO: Emit keypress sound
      }
      else
      {
         // assume the "name" of the key is the same as the character we want to append
         this_change_should_dismiss_the_input_error_frame = true;
         string_to_append = name;
      }

      // append string, or bonk if at limit
      if (!string_to_append.empty())
      {
         if (result_string.size() >= num_permitted_chars)
         {
            emit_bonk_sound_effect();
            this_change_should_dismiss_the_input_error_frame = true;
         }
         else
         {
            // TODO: ensure concating "string_to_append" will not result in a result_string that is longer than limit
            result_string += string_to_append;
            emit_key_click_sound_effect();
            this_change_should_dismiss_the_input_error_frame = true;
         }
      }

      jump_cursor_pos_to_index_of_key_name(name);
      update_cursor_destination();
      key.set_last_pressed_at(al_get_time());
      if (this_change_should_dismiss_the_input_error_frame) clear_input_error_frame();
      return;
    body_dependency_symbols:
      - AllegroFlare::php::trim


  - name: show_input_error_frame
    parameters:
      - name: input_error_frame_error_messages
        type: std::vector<std::string>
        default_argument: '{}'
    body: |
      showing_input_error_frame = true;
      set_input_error_frame_error_messages(input_error_frame_error_messages);
      // TODO: add showing_input_error_frame_at and set here
      return;


  - name: clear_input_error_frame
    body: |
      showing_input_error_frame = false;
      clear_input_error_frame_error_messages();
      // TODO: add showing_input_error_frame_at and set to 0.0f here
      return;


  - name: clear_input_error_frame_error_messages
    body: |
      input_error_frame_error_messages.clear();
      return;


  - name: has_input_error_frame_error_messages
    type: bool
    body: |
      return (!input_error_frame_error_messages.empty());


  - name: validate_and_submit_form
    private: true
    body: |
      std::string sanitized_string = result_string;
      sanitized_string = AllegroFlare::php::trim(sanitized_string);
         
      if (sanitized_string.empty())
      {
         // TODO: show some error feedback that a name must be entered
         show_input_error_frame({ "cannot be blank" });
         emit_bonk_sound_effect();
      }
      else
      {
         // emit the event
         event_emitter->emit_game_event(AllegroFlare::GameEvent(event_to_emit_on_pressing_submit_key));

         // call the callback
         if (on_submit_callback_func) on_submit_callback_func(this, on_submit_callback_func_user_data);
      }

      return;


  - name: update_cursor_destination
    private: true
    body: |
      if (keys.empty()) return;
      int i=0;
      for (auto &key_dictionary_element : keys)
      {
         if (cursor_pos == i)
         {
            // NOTE: this key_dictionary_element is the current cursor selected key
            auto &key = key_dictionary_element.second;
            cursor_destination.x = key.get_x();
            cursor_destination.y = key.get_y();
            cursor_size_destination.x = key.get_width();
            cursor_size_destination.y = key.get_height();
            return;
         }
         i++;
      }
      return;


  - name: infer_current_key_name
    type: std::string
    private: true
    body: |
      if (keys.empty()) return "";
      int i=0;
      for (auto &key_dictionary_element : keys)
      {
         if (cursor_pos == i)
         {
            return key_dictionary_element.first;
         }
         i++;
      }
      return ""; // TODO: cout warning


  - name: jump_cursor_pos_to_index_of_key_name
    parameters:
      - name: name
        type: std::string
        default_argument: '"[unset-name]"'
    body: |
      // TODO: logic for this function
      int i=0;
      for (auto &key_dictionary_element : keys)
      {
         if (name == key_dictionary_element.first)
         {
            // NOTE: this key_dictionary_element is the named key we're looking for
            cursor_pos = i;
            return;
         }
         i++;
      }
      return;


  - name: increment_cursor_pos
    body: |
      if (keys.empty())
      {
         emit_bonk_sound_effect();
         return;
      }
      cursor_pos++;
      while (cursor_pos >= keys.size()) cursor_pos -= keys.size();
      update_cursor_destination();
      return;


  - name: decrement_cursor_pos
    body: |
      if (keys.empty())
      {
         emit_bonk_sound_effect();
         return;
      }
      cursor_pos--;
      while (cursor_pos < 0) cursor_pos += keys.size();
      update_cursor_destination();
      return;


  - name: draw_result_string_and_boxes
    private: true
    body: |
      float box_width = 50;
      float box_height = 90;
      float box_spacing_x = 10;
      float calculated_width = calculate_spaced_elements_width(num_permitted_chars, box_width, box_spacing_x);
      float x = 1920/2 - calculated_width / 2;
      float y = 1920/12*2 - 120;
      ALLEGRO_COLOR box_color = AllegroFlare::color::color(ALLEGRO_COLOR{0.25, 0.25, 0.25, 0.25}, 0.5);

      float x_cursor = x;
      ALLEGRO_FONT *result_text_font = obtain_result_text_font();
      float font_hline_height = al_get_font_line_height(result_text_font) * 0.5;
      for (int i=0; i<num_permitted_chars; i++)
      {
         // draw box
         al_draw_filled_rectangle(x_cursor, y, x_cursor+box_width, y+box_height, box_color);

         std::string this_char = " ";
         if (i < result_string.size())
         {
            this_char[0] = result_string[i];
            al_draw_text(
               result_text_font,
               ALLEGRO_COLOR{1, 1, 1, 1},
               x_cursor + box_width * 0.5,
               y + box_height*0.5 - font_hline_height,
               ALLEGRO_ALIGN_CENTER,
               this_char.c_str()
            );
         }

         if (i == result_string.size())
         {
            std::string current_key_name = infer_current_key_name();

            // draw the character that is currently selected by the cursor
            // TODO: Add this (show_currently_selected_character_in_the_input_box) as a configurable option
            // TODO: Add visual test for this option
            bool show_currently_selected_character_in_the_input_box = false;
            if (show_currently_selected_character_in_the_input_box)
            {
               if (current_key_name == "BACKSPACE") current_key_name = "<";
               if (current_key_name.size() == 1)
               {
                  ALLEGRO_COLOR cursor_color = build_cursor_color();
                  al_draw_text(
                     result_text_font,
                     cursor_color,
                     x_cursor + box_width * 0.5,
                     y + box_height*0.5 - font_hline_height,
                     ALLEGRO_ALIGN_CENTER,
                     current_key_name.c_str()
                  );
               }
            }

            // TODO: Add these (drawing_cursor_box, drawing_cursor_underline) as configurable options
            // TODO: Add visual test for these options
            bool drawing_cursor_box = false;
            bool drawing_cursor_underline = true;

            // TODO: remove this validation if (drawing_cursor_box, drawing_cursor_underline) are added as options
            if (drawing_cursor_box == drawing_cursor_underline)
            {
               throw std::runtime_error("cannot draw both or neither");
            }

            if (!(current_key_name == "SUBMIT" || current_key_name == "<"))
            {
               if (drawing_cursor_box)
               {
                  // draw the text input cursor (box)
                  draw_cursor_rectangle(x_cursor, y, box_width, box_height);
               }
               if (drawing_cursor_underline)
               {
                  // draw the text input cursor (underline)
                  draw_cursor_underline(x_cursor, y, box_width, box_height);
               }
            }
         }

         x_cursor += (box_width + box_spacing_x);
      }

      if (showing_input_error_frame)
      {
         float frame_padding = 12.0f;
         draw_input_error_frame(
            x-frame_padding,
            y-frame_padding,
            calculated_width+frame_padding*2,
            box_height+frame_padding*2
         );
      }

      return;


  - name: build_cursor_color
    private: true
    type: ALLEGRO_COLOR
    body: |
      ALLEGRO_COLOR color_a = al_color_name("aquamarine");
      ALLEGRO_COLOR color_b = AllegroFlare::color::transparent;
      float speed_multiplier = 0.9;
      float mix_factor = AllegroFlare::interpolator::slow_in(fmod(al_get_time() * speed_multiplier, 1.0));
      return AllegroFlare::color::mix(color_a, color_b, 0.7 * mix_factor);
    body_dependency_symbols:
      - fmod
      - AllegroFlare::Color
      - AllegroFlare::interpolator


  - name: build_input_error_frame_color
    private: true
    type: ALLEGRO_COLOR
    body: |
      ALLEGRO_COLOR color_a = al_color_name("crimson");
      ALLEGRO_COLOR color_b = al_color_name("darkred");
      float speed_multiplier = 0.9;
      float mix_factor = AllegroFlare::interpolator::slow_in(fmod(al_get_time() * speed_multiplier, 1.0));
      return AllegroFlare::color::mix(color_a, color_b, 0.7 * mix_factor);
    body_dependency_symbols:
      - fmod
      - AllegroFlare::Color
      - AllegroFlare::interpolator


  - name: draw_cursor_rectangle
    private: true
    parameters:
      - name: x
        type: float
        default_argument: 0.0f
      - name: y
        type: float
        default_argument: 0.0f
      - name: w
        type: float
        default_argument: 0.0f
      - name: h
        type: float
        default_argument: 0.0f
    body: |
      ALLEGRO_COLOR color = build_cursor_color();
      float roundness = 8;
      float thickness = 6.0;

      al_draw_rounded_rectangle(x, y, x + w, y + h, roundness, roundness, color, thickness);
      return;
    body_dependency_symbols:
      - al_draw_rounded_rectangle


  - name: draw_cursor_underline
    private: true
    parameters:
      - name: x
        type: float
        default_argument: 0.0f
      - name: y
        type: float
        default_argument: 0.0f
      - name: w
        type: float
        default_argument: 0.0f
      - name: h
        type: float
        default_argument: 0.0f
    body: |
      ALLEGRO_COLOR color = build_cursor_color();
      float thickness = 6.0;

      // TODO: Consider adding rounded line caps
      al_draw_line(x, y+h, x+w, y+h, color, thickness);
      return;
    body_dependency_symbols:
      - al_draw_rounded_rectangle


  - name: draw_input_error_frame
    private: true
    parameters:
      - name: x
        type: float
        default_argument: 0.0f
      - name: y
        type: float
        default_argument: 0.0f
      - name: w
        type: float
        default_argument: 0.0f
      - name: h
        type: float
        default_argument: 0.0f
    body: |
      ALLEGRO_COLOR color = build_input_error_frame_color();
      float roundness = 8;
      float thickness = 6.0;

      al_draw_rounded_rectangle(x, y, x + w, y + h, roundness, roundness, color, thickness);

      // Draw the messages
      bool there_are_error_messages = !input_error_frame_error_messages.empty();
      if (there_are_error_messages)
      {
         ALLEGRO_COLOR error_messages_text_color = al_color_name("crimson");
         ALLEGRO_FONT *error_messages_font = obtain_error_messages_font();
         std::string comma_joined_error_messages = join(input_error_frame_error_messages, ", ");
         al_draw_text(
            error_messages_font,
            error_messages_text_color,
            x+w,
            y+h,
            ALLEGRO_ALIGN_RIGHT,
            comma_joined_error_messages.c_str()
         );
      }

      return;
    body_dependency_symbols:
      - al_draw_rounded_rectangle


  - name: draw_cursor
    private: true
    body: |
      draw_cursor_rectangle(cursor_location.x, cursor_location.y, cursor_size.x, cursor_size.y);
      return;


  - name: render
    guards: [ initialized ]
    body: |
      // this is a soft "update" here to update the live-moving cursor location
      cursor_location = (cursor_destination - cursor_location) * cursor_reposition_multiplier + cursor_location;
      cursor_size = (cursor_size_destination - cursor_size) * cursor_reposition_multiplier + cursor_size;

      keyboard_placement.start_transform();

      // draw backfill and frame
      draw_keyboard_backfill_and_frame();

      // draw keys
      float time_now = al_get_time();
      ALLEGRO_FONT *font = obtain_keyboard_font();
      ALLEGRO_FONT *prompt_text_font = obtain_prompt_text_font();
      float font_hline_height = al_get_font_line_height(font) / 2;
      for (auto &key_dictionary_element : keys)
      {
         ALLEGRO_COLOR key_color = ALLEGRO_COLOR{1, 1, 1, 1};
         auto &key = key_dictionary_element.second;
         float pressed_age = time_now - key.get_last_pressed_at();
         float motion_duration = 0.6;
         float y_offset = 0.0f;
         if (pressed_age <= motion_duration)
         {
            float normalized_effect_time = pressed_age / motion_duration;
            float inv_normalized_effect_time = 1.0 - normalized_effect_time;
            float fast_curve = inv_normalized_effect_time * inv_normalized_effect_time;
            ALLEGRO_COLOR color_a = al_color_name("aquamarine");
            ALLEGRO_COLOR color_b = key_color;
            key_color = AllegroFlare::color::mix(color_a, color_b, 1.0 - fast_curve);
            y_offset = 8 * inv_normalized_effect_time * inv_normalized_effect_time;
         }

         if (show_rectangle_outline_on_keys)
         {
            al_draw_rectangle(
               key.get_x(),
               key.get_y(),
               key.get_x2(),
               key.get_y2(),
               ALLEGRO_COLOR{0.5, 0.5, 0.5, 0.5},
               1.0
            );
         }
         al_draw_text(
            font,
            key_color,
            key.get_center(),
            key.get_middle() - font_hline_height + y_offset,
            ALLEGRO_ALIGN_CENTER,
            key.get_label().c_str()
         );
      }

      // draw cursor
      draw_cursor();

      keyboard_placement.restore_transform();

      // draw the result string
      draw_result_string_and_boxes();

      // draw the prompt string
      al_draw_text(
         prompt_text_font,
         ALLEGRO_COLOR{1, 1, 1, 1},
         1920/2, // TODO: make this positioning dynamic
         1080/7*1-85, // TODO: make this positioning dynamic
         ALLEGRO_ALIGN_CENTER,
         prompt_text.c_str()
      );

      return;


  - name: draw_keyboard_backfill_and_frame
    private: true
    body: |
      ALLEGRO_COLOR backfill_color = AllegroFlare::color::color(al_color_html("303030"), 0.3);
      ALLEGRO_COLOR border_color = AllegroFlare::color::color(al_color_html("ffffff"), 0.8);
      float roundness = 6.0f;
      float border_thickness = 6.0f;
      float border_padding = border_thickness * 1.75f;
      float extra_padding_x = 60;
      float extra_padding_y = 40;

      al_draw_filled_rounded_rectangle(
         0 - extra_padding_x,
         0 - extra_padding_y,
         keyboard_placement.size.x + extra_padding_x,
         keyboard_placement.size.y + extra_padding_y,
         roundness,
         roundness,
         backfill_color
      );
      al_draw_rounded_rectangle(
         0 - border_padding - extra_padding_x,
         0 - border_padding - extra_padding_y,
         keyboard_placement.size.x + border_padding + extra_padding_x,
         keyboard_placement.size.y + border_padding + extra_padding_y,
         roundness,
         roundness,
         border_color,
         border_thickness
      );
      return;
    body_dependency_symbols:
      - AllegroFlare::Color


  - name: key_exists
    type: bool
    parameters:
      - name: identifier
        type: std::string
        default_argument: '"[unset-identifier]"'
    body: |
      return (keys.count(identifier) >= 1);


  - name: emit_bonk_sound_effect
    private: true
    guards: [ initialized ]
    body: |
      event_emitter->emit_play_sound_effect_event(bonk_sound_effect_identifier);
      return;


  - name: emit_key_click_sound_effect
    private: true
    guards: [ initialized ]
    body: |
      event_emitter->emit_play_sound_effect_event(key_click_sound_effect_identifier);
      return;


  - name: emit_erase_sound_effect
    private: true
    guards: [ initialized ]
    body: |
      event_emitter->emit_play_sound_effect_event(erase_sound_effect_identifier);
      return;


  - name: obtain_keyboard_font
    private: true
    type: ALLEGRO_FONT*
    guards: [ initialized ]
    body: |
      std::stringstream composite_font_str;
      composite_font_str << font_name << " " << font_size;
      return font_bin->auto_get(composite_font_str.str());


  - name: obtain_prompt_text_font
    private: true
    type: ALLEGRO_FONT*
    guards: [ initialized ]
    body: |
      std::stringstream composite_font_str;
      composite_font_str << font_name << " " << (font_size - 23);
      return font_bin->auto_get(composite_font_str.str());


  - name: obtain_result_text_font
    private: true
    type: ALLEGRO_FONT*
    guards: [ initialized ]
    body: |
      std::stringstream composite_font_str;
      composite_font_str << font_name << " " << (font_size - 20);
      return font_bin->auto_get(composite_font_str.str());


  - name: obtain_error_messages_font
    private: true
    type: ALLEGRO_FONT*
    guards: [ initialized ]
    body: |
      std::stringstream composite_font_str;
      composite_font_str << font_name << " " << (font_size);
      return font_bin->auto_get(composite_font_str.str());


  - name: calculate_boilerplate_keyboard_dimensions
    static: true
    type: AllegroFlare::Vec2D
    body: |
      float x_spacing = 65;
      float y_spacing = 70;
      float column_spacing = 450;
      return AllegroFlare::Vec2D(column_spacing * 2 + x_spacing * 6, 500);


  - name: move_cursor_down
    body: |
       if (keys.empty()) return;

       std::map<std::string, std::string> up_move_destination_exceptions = {

          // row 1

          { "A", "G" },
          { "B", "H" },
          { "C", "I" },
          { "D", "J" },
          { "E", "K" },
          { "F", "L" },

          { "a", "g" },
          { "b", "h" },
          { "c", "i" },
          { "d", "j" },
          { "e", "k" },
          { "f", "l" },

          { "0", "6" },
          { "1", "7" },
          { "2", "8" },
          { "3", "9" },
          { "4", "." },
          { "5", "-" },

          // row 2

          { "G", "M" },
          { "H", "N" },
          { "I", "O" },
          { "J", "P" },
          { "K", "Q" },
          { "L", "R" },

          { "g", "m" },
          { "h", "n" },
          { "i", "o" },
          { "j", "p" },
          { "k", "q" },
          { "l", "r" },

          { "6", "BACKSPACE" },
          { "7", "BACKSPACE" },
          { "8", "BACKSPACE" },
          { "9", "SUBMIT" },
          { ".", "SUBMIT" },
          { "-", "SUBMIT" },

          // row 3

          { "M", "S" },
          { "N", "T" },
          { "O", "U" },
          { "P", "V" },
          { "Q", "W" },
          { "R", "X" },
              
          { "m", "s" },
          { "n", "t" },
          { "o", "u" },
          { "p", "v" },
          { "q", "w" },
          { "r", "x" },

          //{ "X", "X" },
          //{ "X", "X" },
          //{ "X", "X" },
          //{ "X", "X" },
          //{ "X", "X" },
          //{ "X", "X" },

          // row 4

          { "S", "Y" },
          { "T", "Z" },
          { "U", "C" },
          { "V", "D" },
          { "W", "E" },
          { "X", "F" },
              
          { "s", "y" },
          { "t", "z" },
          { "u", "SPACE" },
          { "v", "SPACE" },
          { "w", "SPACE" },
          { "x", "BACKSPACE" },

          //{ "X", "X" },
          //{ "X", "X" },
          //{ "X", "X" },
          //{ "X", "X" },
          //{ "X", "X" },
          //{ "X", "X" },

          // row 5

          { "Y", "A" },
          { "Z", "B" },
          //{ "X", "X" },
          //{ "X", "X" },
          //{ "X", "X" },
          //{ "X", "X" },

          { "y", "SPACE" },
          { "z", "SPACE" },
          //{ "X", "X" },
          //{ "X", "X" },
          //{ "X", "X" },
          //{ "X", "X" },

          //{ "X", "X" },
          //{ "X", "X" },
          //{ "X", "X" },
          //{ "X", "X" },
          //{ "X", "X" },
          //{ "X", "X" },

          // bottom row

          { "BACKSPACE", "0" },
          { "SPACE", "a" },
          { "SUBMIT", "4" },
       };

       std::string current_key_name = infer_current_key_name();
       if (current_key_name.empty()) return;

       if (keys.count(current_key_name) >= 1)
       {
          // key is found in the exception dictionary
          std::string key_name_to_move_to = up_move_destination_exceptions[current_key_name];
          if (keys.count(key_name_to_move_to) <= 0)
          {
             // TODO: test this condition
             std::stringstream error_message;
             error_message << "[AllegroFlare::SoftwareKeyboard::SoftwareKeyboard::move_cursor_to_pos]: WARNING: "
                           << "Attempting to move cursor to key named \"" << key_name_to_move_to << "\" but it does "
                           << "not exist.";
             std::cout << error_message.str() << std::endl;
             return;
          }

          // move to the destination key and return
          jump_cursor_pos_to_index_of_key_name(key_name_to_move_to);
          update_cursor_destination();
          
          return;
       }


       return;


  - name: move_cursor_up
    body: |
       if (keys.empty()) return;

       std::map<std::string, std::string> up_move_destination_exceptions = {

          // row 1

          { "A", "Y" },
          { "B", "Z" },
          { "C", "U", },
          { "D", "V", },
          { "E", "W", },
          { "F", "X", },

          { "a", "SPACE" },
          { "b", "SPACE" },
          { "c", "SPACE" },
          { "d", "SPACE" },
          { "e", "SPACE" },
          { "f", "BACKSPACE" },

          { "0", "BACKSPACE" },
          { "1", "BACKSPACE" },
          { "2", "BACKSPACE" },
          { "3", "BACKSPACE" },
          { "4", "SUBMIT" },
          { "5", "SUBMIT" },

          // row 2

          { "G", "A", },
          { "H", "B", },
          { "I", "C", },
          { "J", "D", },
          { "K", "E", },
          { "L", "F", },
               
          { "g", "a", },
          { "h", "b", },
          { "i", "c", },
          { "j", "d", },
          { "k", "e", },
          { "l", "f", },
               
          { "6", "0", },
          { "7", "1", },
          { "8", "2", },
          { "9", "3", },
          { ".", "4", },
          { "-", "5", },

          // row 3

          { "M", "G", },
          { "N", "H", },
          { "O", "I", },
          { "P", "J", },
          { "Q", "K", },
          { "R", "L", },
               
          { "m", "g", },
          { "n", "h", },
          { "o", "i", },
          { "p", "j", },
          { "q", "k", },
          { "r", "l", },
               
          //{ "*", "6", },
          //{ "*", "7", },
          //{ "*", "8", },
          //{ "*", "9", },
          //{ "*", ".", },
          //{ "*", "-", },

          // row 4

          { "S", "M", },
          { "T", "N", },
          { "U", "O", },
          { "V", "P", },
          { "W", "Q", },
          { "X", "R", },
                  
          { "s", "m", },
          { "t", "n", },
          { "u", "o", },
          { "v", "p", },
          { "w", "q", },
          { "x", "r", },

          //{ "X", "X" },
          //{ "X", "X" },
          //{ "X", "X" },
          //{ "X", "X" },
          //{ "X", "X" },
          //{ "X", "X" },

          // row 5

          { "Y", "S", },
          { "Z", "T", },
          //{ "C", "X" },
          //{ "D", "X" },
          //{ "E", "X" },
          //{ "F", "X" },
                   
          { "y", "s", },
          { "z", "t", },
          //{ "*", "u", },
          //{ "*", "v", },
          //{ "*", "w", },
          //{ "*", "x", },

          //{ "X", "X" },
          //{ "X", "X" },
          //{ "X", "X" },
          //{ "X", "X" },
          //{ "X", "X" },
          //{ "X", "X" },

          // bottom row

          { "BACKSPACE", "6" },
          { "SPACE", "y" },
          { "SUBMIT", "." },
       };

       std::string current_key_name = infer_current_key_name();
       if (current_key_name.empty()) return;

       if (keys.count(current_key_name) >= 1)
       {
          // key is found in the exception dictionary
          std::string key_name_to_move_to = up_move_destination_exceptions[current_key_name];
          if (keys.count(key_name_to_move_to) <= 0)
          {
             // TODO: test this condition
             std::stringstream error_message;
             error_message << "[AllegroFlare::SoftwareKeyboard::SoftwareKeyboard::move_cursor_to_pos]: WARNING: "
                           << "Attempting to move cursor to key named \"" << key_name_to_move_to << "\" but it does "
                           << "not exist.";
             std::cout << error_message.str() << std::endl;
             return;
          }

          // move to the destination key and return
          jump_cursor_pos_to_index_of_key_name(key_name_to_move_to);
          update_cursor_destination();
          
          return;
       }

       return;
    body_dependency_symbols:
      - std::map


  - name: build_boilerplate_keyboard_keys
    static: true
    type: tsl::ordered_map<std::string, AllegroFlare::SoftwareKeyboard::KeyboardKey>
    body: |
      float x_spacing = 65;
      float y_spacing = 70;
      float column_spacing = 450;
      AllegroFlare::Vec2D calculated_dimensions = calculate_boilerplate_keyboard_dimensions();

      float space_key_width = 330;
      float backspace_key_width = 330;
      float submit_key_width = 140;
      float right_edge = calculated_dimensions.x;

      tsl::ordered_map<std::string, AllegroFlare::SoftwareKeyboard::KeyboardKey> result = {
        // row 1

        { "A", { "A", x_spacing*0,                  y_spacing*0, 80, 80 } },
        { "B", { "B", x_spacing*1,                  y_spacing*0, 80, 80 } },
        { "C", { "C", x_spacing*2,                  y_spacing*0, 80, 80 } },
        { "D", { "D", x_spacing*3,                  y_spacing*0, 80, 80 } },
        { "E", { "E", x_spacing*4,                  y_spacing*0, 80, 80 } },
        { "F", { "F", x_spacing*5,                  y_spacing*0, 80, 80 } },

        { "a", { "a", column_spacing*1+x_spacing*0, y_spacing*0, 80, 80 } },
        { "b", { "b", column_spacing*1+x_spacing*1, y_spacing*0, 80, 80 } },
        { "c", { "c", column_spacing*1+x_spacing*2, y_spacing*0, 80, 80 } },
        { "d", { "d", column_spacing*1+x_spacing*3, y_spacing*0, 80, 80 } },
        { "e", { "e", column_spacing*1+x_spacing*4, y_spacing*0, 80, 80 } },
        { "f", { "f", column_spacing*1+x_spacing*5, y_spacing*0, 80, 80 } },

        { "0", { "0", column_spacing*2+x_spacing*0, y_spacing*0, 80, 80 } },
        { "1", { "1", column_spacing*2+x_spacing*1, y_spacing*0, 80, 80 } },
        { "2", { "2", column_spacing*2+x_spacing*2, y_spacing*0, 80, 80 } },
        { "3", { "3", column_spacing*2+x_spacing*3, y_spacing*0, 80, 80 } },
        { "4", { "4", column_spacing*2+x_spacing*4, y_spacing*0, 80, 80 } },
        { "5", { "5", column_spacing*2+x_spacing*5, y_spacing*0, 80, 80 } },

        // row 2

        { "G", { "G", x_spacing*0,                  y_spacing*1, 80, 80 } },
        { "H", { "H", x_spacing*1,                  y_spacing*1, 80, 80 } },
        { "I", { "I", x_spacing*2,                  y_spacing*1, 80, 80 } },
        { "J", { "J", x_spacing*3,                  y_spacing*1, 80, 80 } },
        { "K", { "K", x_spacing*4,                  y_spacing*1, 80, 80 } },
        { "L", { "L", x_spacing*5,                  y_spacing*1, 80, 80 } },

        { "g", { "g", column_spacing*1+x_spacing*0, y_spacing*1, 80, 80 } },
        { "h", { "h", column_spacing*1+x_spacing*1, y_spacing*1, 80, 80 } },
        { "i", { "i", column_spacing*1+x_spacing*2, y_spacing*1, 80, 80 } },
        { "j", { "j", column_spacing*1+x_spacing*3, y_spacing*1, 80, 80 } },
        { "k", { "k", column_spacing*1+x_spacing*4, y_spacing*1, 80, 80 } },
        { "l", { "l", column_spacing*1+x_spacing*5, y_spacing*1, 80, 80 } },

        { "6", { "6", column_spacing*2+x_spacing*0, y_spacing*1, 80, 80 } },
        { "7", { "7", column_spacing*2+x_spacing*1, y_spacing*1, 80, 80 } },
        { "8", { "8", column_spacing*2+x_spacing*2, y_spacing*1, 80, 80 } },
        { "9", { "9", column_spacing*2+x_spacing*3, y_spacing*1, 80, 80 } },
        { ".", { ".", column_spacing*2+x_spacing*4, y_spacing*1, 80, 80 } },
        { "-", { "-", column_spacing*2+x_spacing*5, y_spacing*1, 80, 80 } },

        // row 3

        { "M", { "M", x_spacing*0,                  y_spacing*2, 80, 80 } },
        { "N", { "N", x_spacing*1,                  y_spacing*2, 80, 80 } },
        { "O", { "O", x_spacing*2,                  y_spacing*2, 80, 80 } },
        { "P", { "P", x_spacing*3,                  y_spacing*2, 80, 80 } },
        { "Q", { "Q", x_spacing*4,                  y_spacing*2, 80, 80 } },
        { "R", { "R", x_spacing*5,                  y_spacing*2, 80, 80 } },

        { "m", { "m", column_spacing*1+x_spacing*0, y_spacing*2, 80, 80 } },
        { "n", { "n", column_spacing*1+x_spacing*1, y_spacing*2, 80, 80 } },
        { "o", { "o", column_spacing*1+x_spacing*2, y_spacing*2, 80, 80 } },
        { "p", { "p", column_spacing*1+x_spacing*3, y_spacing*2, 80, 80 } },
        { "q", { "q", column_spacing*1+x_spacing*4, y_spacing*2, 80, 80 } },
        { "r", { "r", column_spacing*1+x_spacing*5, y_spacing*2, 80, 80 } },

        //{ "~", { "~", column_spacing*2+x_spacing*0, y_spacing*2, 80, 80 } },
        //{ "~", { "~", column_spacing*2+x_spacing*1, y_spacing*2, 80, 80 } },
        //{ "~", { "~", column_spacing*2+x_spacing*2, y_spacing*2, 80, 80 } },
        //{ "~", { "~", column_spacing*2+x_spacing*3, y_spacing*2, 80, 80 } },
        //{ "~", { "~", column_spacing*2+x_spacing*4, y_spacing*2, 80, 80 } },
        //{ "~", { "~", column_spacing*2+x_spacing*5, y_spacing*2, 80, 80 } },

        // row 4

        { "S", { "S", x_spacing*0,                  y_spacing*3, 80, 80 } },
        { "T", { "T", x_spacing*1,                  y_spacing*3, 80, 80 } },
        { "U", { "U", x_spacing*2,                  y_spacing*3, 80, 80 } },
        { "V", { "V", x_spacing*3,                  y_spacing*3, 80, 80 } },
        { "W", { "W", x_spacing*4,                  y_spacing*3, 80, 80 } },
        { "X", { "X", x_spacing*5,                  y_spacing*3, 80, 80 } },

        { "s", { "s", column_spacing*1+x_spacing*0, y_spacing*3, 80, 80 } },
        { "t", { "t", column_spacing*1+x_spacing*1, y_spacing*3, 80, 80 } },
        { "u", { "u", column_spacing*1+x_spacing*2, y_spacing*3, 80, 80 } },
        { "v", { "v", column_spacing*1+x_spacing*3, y_spacing*3, 80, 80 } },
        { "w", { "w", column_spacing*1+x_spacing*4, y_spacing*3, 80, 80 } },
        { "x", { "x", column_spacing*1+x_spacing*5, y_spacing*3, 80, 80 } },

        //{ "x", { "x", column_spacing*2+x_spacing*0, y_spacing*3, 80, 80 } },
        //{ "x", { "x", column_spacing*2+x_spacing*1, y_spacing*3, 80, 80 } },
        //{ "x", { "x", column_spacing*2+x_spacing*2, y_spacing*3, 80, 80 } },
        //{ "x", { "x", column_spacing*2+x_spacing*3, y_spacing*3, 80, 80 } },
        //{ "x", { "x", column_spacing*2+x_spacing*4, y_spacing*3, 80, 80 } },
        //{ "x", { "x", column_spacing*2+x_spacing*5, y_spacing*3, 80, 80 } },

        // row 5

        { "Y", { "Y", x_spacing*0,                    y_spacing*4, 80, 80 } },
        { "Z", { "Z", x_spacing*1,                    y_spacing*4, 80, 80 } },
        //{ " ", { " ", x_spacing*2,                  y_spacing*4, 80, 80 } },
        //{ " ", { " ", x_spacing*3,                  y_spacing*4, 80, 80 } },
        //{ " ", { " ", x_spacing*4,                  y_spacing*4, 80, 80 } },
        //{ " ", { " ", x_spacing*5,                  y_spacing*4, 80, 80 } },

        { "y", { "y", column_spacing*1+x_spacing*0,  y_spacing*4, 80, 80 } },
        { "z", { "z", column_spacing*1+x_spacing*1,  y_spacing*4, 80, 80 } },
        //{ " ", { " ", column_spacing*1+x_spacing*2, y_spacing*4, 80, 80 } },
        //{ " ", { " ", column_spacing*1+x_spacing*3, y_spacing*4, 80, 80 } },
        //{ " ", { " ", column_spacing*1+x_spacing*4, y_spacing*4, 80, 80 } },
        //{ " ", { " ", column_spacing*1+x_spacing*5, y_spacing*4, 80, 80 } },

        //{ "x", { "x", column_spacing*2+x_spacing*0, y_spacing*3, 80, 80 } },
        //{ "x", { "x", column_spacing*2+x_spacing*1, y_spacing*3, 80, 80 } },
        //{ "x", { "x", column_spacing*2+x_spacing*2, y_spacing*3, 80, 80 } },
        //{ "x", { "x", column_spacing*2+x_spacing*3, y_spacing*3, 80, 80 } },
        //{ "x", { "x", column_spacing*2+x_spacing*4, y_spacing*3, 80, 80 } },
        //{ "x", { "x", column_spacing*2+x_spacing*5, y_spacing*3, 80, 80 } },

        // bottom row

        { "SPACE",     { "Space", right_edge - 900, calculated_dimensions.y-80, space_key_width, 80 } },
        { "BACKSPACE", { "Backspace", right_edge - (140+330+50), calculated_dimensions.y-80, backspace_key_width, 80 } },
        { "SUBMIT",    { "OK", right_edge - 140, calculated_dimensions.y-80, submit_key_width, 80 } },

      };
      return result;


  - name: calculate_spaced_elements_width
    type: float
    static: true
    parameters:
      - name: num_elements
        type: int
        default_argument: 0
      - name: element_width
        type: float
        default_argument: 0.0f
      - name: element_spacing
        type: float
        default_argument: 0.0f
    guards: [ (num_elements >= 0) ]
    body: |
      // TODO: Test this function
      // TODO: Include this function in a new class that specializes in working with layouts

      // When there are no elements, return 0
      if (num_elements == 0) return 0;

      // Calculate the total width of the boxes and spacing
      float total_width = (num_elements * element_width) + ((num_elements - 1) * element_spacing);
      return total_width;


  - name: join
    type: std::string
    private: true
    parameters:
      - name: tokens
        type: std::vector<std::string>
        default_argument: '{}'
      - name: delimiter
        type: std::string
        default_argument: '", "'
    body: |
      std::stringstream result;
      bool last = false;

      for (unsigned i=0; i<tokens.size(); i++)
      {
         result << tokens[i];
         if (i == tokens.size()-1) last = true;
         if (!last) result << delimiter;
      }

      return result.str();
    body_dependency_symbols:
      - std::stringstream


dependencies:


  - symbol: tsl::ordered_map
    headers: [ lib/tsl/ordered_map.h ]
  - symbol: AllegroFlare::SoftwareKeyboard::KeyboardKey
    headers: [ AllegroFlare/SoftwareKeyboard/KeyboardKey.hpp ]
  - symbol: AllegroFlare::Vec2D
    headers: [ AllegroFlare/Vec2D.hpp ]
  - symbol: AllegroFlare::FontBin
    headers: [ AllegroFlare/FontBin.hpp ]
  - symbol: al_is_system_installed
    headers: [ allegro5/allegro.h ]
  - symbol: al_is_primitives_addon_initialized
    headers: [ allegro5/allegro_primitives.h ]
  - symbol: al_is_font_addon_initialized
    headers: [ allegro5/allegro_font.h ]
  - symbol: ALLEGRO_FONT
    headers: [ allegro5/allegro_font.h ]
  - symbol: AllegroFlare::Placement2D
    headers: [ AllegroFlare/Placement2D.hpp ]
  - symbol: AllegroFlare::Color
    headers: [ AllegroFlare/Color.hpp ]
  - symbol: fmod
    headers: [ cmath ]
  - symbol: AllegroFlare::interpolator
    headers: [ AllegroFlare/Interpolators.hpp ]
  - symbol: AllegroFlare::EventEmitter
    headers: [ AllegroFlare/EventEmitter.hpp ]
  - symbol: std::size_t
    headers: [ cstddef ]
  - symbol: AllegroFlare::php::trim
    headers: [ AllegroFlare/UsefulPHP.hpp ]
  - symbol: ALLEGRO_COLOR
    headers: [ allegro5/allegro.h ]
  - symbol: AllegroFlare::SoftwareKeyboard::SoftwareKeyboard
    headers: [ AllegroFlare/SoftwareKeyboard/SoftwareKeyboard.hpp ]
  - symbol: al_draw_rounded_rectangle
    headers: [ allegro5/allegro_primitives.h ]


