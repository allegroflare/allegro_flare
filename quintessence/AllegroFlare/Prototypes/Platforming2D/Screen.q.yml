parent_classes:


  - class: AllegroFlare::Screens::Base
    scope: public
    init_with: '"Prototypes::Platforming2D::Screen"'


properties:


  - name: bitmap_bin
    type: AllegroFlare::BitmapBin*
    constructor_arg: true
    init_with: nullptr
    getter: true
    setter: false

  - name: display
    type: AllegroFlare::Display*
    init_with: nullptr
    constructor_arg: true
    setter: false

  - name: event_emitter
    type: AllegroFlare::EventEmitter*
    init_with: nullptr
    constructor_arg: true
    setter: false

  - name: native_display_resolution_width
    type: int
    init_with: 1920

  - name: native_display_resolution_height
    type: int
    init_with: 1080

  - name: initialized
    type: bool 
    init_with: false

  - name: currently_active_map
    type: WickedDemos::TileMaps::Basic2D*
    init_with: nullptr

  - name: currently_active_map_name
    type: std::string
    init_with: '"[currently-active-map-name-unset]"'

  - name: entity_pool
    type: std::vector<Wicked::Entities::Basic2D*>
    init_with: '{}'
    setter: true

  - name: map_dictionary
    type: std::map<std::string, std::string>
    init_with: '{}'
    getter: true
    setter: false

  - name: gravity
    type: float
    init_with: 0.25f

  - name: gravity_reversed
    type: bool
    init_with: false

  - name: camera
    type: AllegroFlare::Camera2D
    init_with: ''

  - name: player_controlled_entity
    type: Wicked::Entities::Basic2D*
    init_with: nullptr
    getter: true
    setter: true

  - name: show_tile_mesh
    type: bool
    init_with: true
    getter: true
    setter: true

  - name: show_collision_tile_mesh
    type: bool
    init_with: false
    getter: true
    setter: true

  - name: player_controls
    type: AllegroFlare::VirtualControls
    init_with: ''

  - name: camera_control_strategy
    type: Wicked::CameraControlStrategies2D::Base*
    init_with: nullptr

  - name: backbuffer_sub_bitmap
    type: ALLEGRO_BITMAP*
    init_with: nullptr


functions:


  - name: set_map_dictionary
    parameters:
      - name: map_dictionary
        type: std::map<std::string, std::string>
        default_argument: '{}'
    guards: [ (!initialized) ]
    body: |
      this->map_dictionary = map_dictionary;
      // TODO: allow this to be set after initialization
      return;


  - name: set_display
    parameters:
      - name: display
        type: AllegroFlare::Display*
        default_argument: nullptr
    guards: [ (!initialized) ]
    body: |
      this->display = display;
      return;


  - name: set_event_emitter
    parameters:
      - name: event_emitter
        type: AllegroFlare::EventEmitter*
        default_argument: nullptr
    guards: [ (!initialized) ]
    body: |
      this->event_emitter = event_emitter;
      return;


  - name: set_bitmap_bin
    parameters:
      - name: bitmap_bin
        type: AllegroFlare::BitmapBin*
        default_argument: nullptr
    guards: [ (!initialized) ]
    body: |
      this->bitmap_bin = bitmap_bin;
      return;


  - name: set_currently_active_map
    parameters:
      - name: name
        type: std::string
        default_argument: '"[unset-current-map-name-to-use]"'
    body: |
      currently_active_map = find_map_by_name(name);
      if (!currently_active_map) throw std::runtime_error("Bruh, no map");
      currently_active_map_name = name;
      return;


  - name: find_map_by_name
    type: WickedDemos::TileMaps::Basic2D*
    parameters:
      - name: name
        type: std::string
        default_argument: '"[unset-map-name]"'
    body: |
      Wicked::Entities::CollectionHelper collection_helper(&entity_pool);
      WickedDemos::TileMaps::Basic2D *found_map = collection_helper.find_map_by_name(name);
      if (!found_map)
      {
         std::stringstream error_message;
         error_message << "map named \"" << name << "\" does not exist.";
         throw std::runtime_error(error_message.str());

      }

      return found_map;


  - name: on_activate
    virtual: true
    override: true
    guards: [ initialized ]
    body: |
      // nothing here
      return;


  - name: on_deactivate
    virtual: true
    override: true
    guards: [ initialized ]
    body: |
      // nothing here
      return;


  - name: initialize_maps
    body: |
      Wicked::Entities::Basic2DFactory factory(bitmap_bin);
      Wicked::Entities::Basic2D *created_map = nullptr;

      // TODO: clean this up
      for (auto &map_dictionary_entry : map_dictionary)
      {
         std::string map_name = std::get<0>(map_dictionary_entry);
         std::string map_filename = std::get<1>(map_dictionary_entry);

         created_map = factory.create_tile_map(map_filename, map_name);

         if (!created_map)
         {
            std::cout << "ERROR: Could not create map \"" << map_filename << "\"" << std::endl;
         }
         else
         {
            std::cout << "NOTE: TMJ Tile map file \"" << map_filename << "\" loaded successfully." << std::endl;
         }

         WickedDemos::TileMaps::Basic2D* __created_map =
            static_cast<WickedDemos::TileMaps::Basic2D*>(created_map); // = nullptr;

         if (!__created_map->get_tile_mesh())
         {
            std::cout << "ERROR: could not create tile mesh on \"" << map_filename << "\"" << std::endl;
         }
         else
         {
            std::cout << "NOTE: TMJ Tile loaded tile mesh \"" << map_filename << "\" loaded successfully." << std::endl;
         }


         if (!__created_map->get_tile_mesh()->get_initialized())
         {
            std::cout << "ERROR: prim mesh not initialized on \"" << map_filename << "\"" << std::endl;
         }
         else
         {
            std::cout << "NOTE: prim mesh initialized on \"" << map_filename << "\" loaded successfully." << std::endl;
         }


         if (!__created_map->get_collision_tile_mesh())
         {
            std::cout << "ERROR: collision tile map not loaded on \"" << map_filename << "\"" << std::endl;
         }
         else
         {
            std::cout << "NOTE: collision tile map loaded on \"" << map_filename << "\" loaded successfully." << std::endl;
         }


         if (!__created_map->get_collision_tile_mesh())
         {
            std::cout << "ERROR: collision tile map not loaded on \"" << map_filename << "\"" << std::endl;
         }
         else
         {
            std::cout << "NOTE: collision tile map loaded on \"" << map_filename << "\" loaded successfully." << std::endl;
         }


         entity_pool.push_back(created_map);
      }

      set_currently_active_map("map_a");

      return;


  - name: add_entity_to_pool
    type: void
    parameters:
      - name: entity
        type: Wicked::Entities::Basic2D*
        default_argument: nullptr
    body: |
      entity_pool.push_back(entity);
      return;


  - name: initialize_camera_control
    type: void
    body: |
      float assumed_tile_width = 16.0f;
      float assumed_tile_height = 16.0f;
      float room_width = assumed_tile_width * 25; // tile_mesh->get_real_width();
      float room_height = assumed_tile_height * 15; //tile_mesh->get_real_height();

      Wicked::CameraControlStrategies2D::SmoothSnap *camera_control =
         new Wicked::CameraControlStrategies2D::SmoothSnap(room_width, room_height);
      //Wicked::CameraControlStrategies2D::HorizontalRail *camera_control =
         //new Wicked::CameraControlStrategies2D::HorizontalRail; //(room_width, room_height);
      camera_control->set_camera(&camera);
      camera_control->set_entity_to_follow(player_controlled_entity);
      camera_control->initialize();
      camera_control_strategy = camera_control;
      return;
    body_dependency_symbols:
      - Wicked::CameraControlStrategies2D::Snap
      - Wicked::CameraControlStrategies2D::SmoothSnap
      - Wicked::CameraControlStrategies2D::HorizontalRail


  - name: initialize_player_controls
    body: |
      player_controls.clear();
      return;


  - name: initialize_backbuffer_sub_bitmap
    body: |
      ALLEGRO_BITMAP *backbuffer = al_get_backbuffer(al_get_current_display());
      backbuffer_sub_bitmap = al_create_sub_bitmap(
         backbuffer,
         0,
         0,
         al_get_bitmap_width(backbuffer),
         al_get_bitmap_height(backbuffer)
      );

      if (!backbuffer_sub_bitmap)
      {
         std::stringstream error_message;
         error_message << "AllegroFlare::Prototypes::Platforming2D::Screen::initialize() error: "
                       << "could not create backbuffer_sub_bitmap";
         throw std::runtime_error(error_message.str());
      }
      return;


  - name: initialize
    type: void
    guards:
      - bitmap_bin
      - al_get_current_display()
    body: |
      initialize_camera_control();
      initialize_player_controls();
      initialize_backbuffer_sub_bitmap();
      initialize_camera();
      initialized = true;
      return;


  - name: initialize_camera
    private: true
    guards: [ currently_active_map, currently_active_map->get_tile_atlas(), currently_active_map->get_tile_mesh() ]
    body: |
      //camera.size = { 1920.0f, 1080.0f };
      camera.size = AllegroFlare::vec2d(1920.0f, 1080.0f);
      camera.align = AllegroFlare::vec2d(0.5, 0.5);
 
      //float width = tile_mesh->get_real_width();
      //float height = tile_mesh->get_real_height();

      float room_width = currently_active_map->get_tile_mesh()->get_tile_width() * 25; // tile_mesh->get_real_width();
      float room_height = currently_active_map->get_tile_mesh()->get_tile_height() * 15; //tile_mesh->get_real_height();

      // note that Shovel Knight has 4.5x4.5 sized pixels (actually 4.8 x 4.5)
         // this means:
         //     - a virtual resolution of 400x240
         //     = a native display resolution of 1920x1080 (HD)
         //     - 25 tiles x 15 tiles to fill the virtual resolution
         //     - 16x16 pixel tiles
         // see https://www.yachtclubgames.com/blog/breaking-the-nes

      camera.scale = AllegroFlare::vec2d(1.0 / 4.8, 1.0 / 4.5);
      camera.position = {room_width/2, room_height/2};

      return;


  - name: unset_player_controlled_entity_vertical_velocity
    body: |
      if (!player_controlled_entity) return;
      player_controlled_entity->get_velocity_ref().position.y = 0;
      return;


  - name: unset_player_controlled_entity_horizontal_velocity
    body: |
      if (!player_controlled_entity) return;
      player_controlled_entity->get_velocity_ref().position.x = 0;
      return;


  - name: set_player_controlled_entity_jump
    body: |
      if (!player_controlled_entity) return;
      if (player_controlled_entity->exists(ADJACENT_TO_FLOOR))
      {
         player_controlled_entity->get_velocity_ref().position.y -= 4.25;
      }
      else if (player_controlled_entity->exists(ADJACENT_TO_LEFT_WALL))
      {
         player_controlled_entity->get_velocity_ref().position.y = -3.5;
         player_controlled_entity->get_velocity_ref().position.x = 3.0;
      }
      else if (player_controlled_entity->exists(ADJACENT_TO_RIGHT_WALL))
      {
         player_controlled_entity->get_velocity_ref().position.y = -3.5;
         player_controlled_entity->get_velocity_ref().position.x = -3.0;
      }
      return;


  - name: player_emit_projectile
    parameters:
      - name: magnitude
        type: float
        default_argument: 3.0f
    body: |
      AllegroFlare::vec2d player_pos = player_controlled_entity->get_place_ref().position;
      //AllegroFlare::vec2d player_center_pos = player_pos;
      //AllegroFlare::vec2d aim_dir = player_controls.get_primary_stick_position(); //.normalized();
      AllegroFlare::vec2d aim_pos = player_controls.get_primary_stick_position(); //.normalized();

      if ((aim_pos.x < 0.00001) && (aim_pos.x > -0.00001))
      if ((aim_pos.y < 0.00001) && (aim_pos.y > -0.00001))
      {
         aim_pos = {1, 0};
      }


      std::string on_map_name = player_controlled_entity->get(ON_MAP_NAME);


      Wicked::Entities::Basic2DFactory factory(bitmap_bin);
      Wicked::Entities::Basic2D* projectile = factory.create_player_projectile(
         on_map_name,
         player_pos.x,
         player_pos.y,
         8-1,
         8-1,
         aim_pos,
         magnitude
      );
      entity_pool.push_back(projectile);


      // HERE
      return;
    body_dependency_symbols:
      - Wicked::Entities::Basic2DFactory


  - name: reverse_gravity
    body: gravity_reversed = !gravity_reversed;


  - name: update_entities
    guards: [ initialized, currently_active_map ]
    body: |
      // apply gravity
      for (auto &entity : get_current_map_entities())
      {
         if (entity->exists(NOT_AFFECTED_BY_GRAVITY)) continue;
         AllegroFlare::Placement2D &velocity = entity->get_velocity_ref();
         velocity.position.y += (gravity_reversed ? -gravity : gravity);
      }

      // update the entities (typically includes movement strategies)
      for (auto &entity : get_current_map_entities())
      {
         entity->update();
      }

      // step each entity
      for (auto &entity : get_current_map_entities())
      {
         AllegroFlare::Placement2D &place = entity->get_place_ref();
         AllegroFlare::Placement2D &velocity = entity->get_velocity_ref();

         // handle case where entity does not interact with world tile mesh
         if (entity->exists(DOES_NOT_COLLIDE_WITH_WORLD))
         {
            place.position.x += velocity.position.x;
            place.position.y += velocity.position.y;
            continue;
         }

         // create a "simulated aabb2d" of the entity and run it through the collision stepper
         Wicked::Physics::AABB2D aabb2d(
            place.position.x - place.size.x * place.align.x,
            place.position.y - place.size.y * place.align.y,
            place.size.x,
            place.size.y,
            velocity.position.x,
            velocity.position.y
         );
         float tile_width = 16.0f;
         float tile_height = 16.0f;
         Wicked::Physics::TileMapCollisionStepper collision_stepper(
            currently_active_map->get_collision_tile_mesh(),
            &aabb2d,
            tile_width,
            tile_height
         );
         collision_stepper.step();

         // supplant our entity's position and velocity values with the "simulated aabb2d"'s values
         place.position.x = aabb2d.get_x() + place.size.x * place.align.x;
         place.position.y = aabb2d.get_y() + place.size.y * place.align.y;
         velocity.position.x = aabb2d.get_velocity_x();
         velocity.position.y = aabb2d.get_velocity_y();

         // add positioning flags
         if (collision_stepper.adjacent_to_bottom_edge(tile_width, tile_height)) entity->set(ADJACENT_TO_FLOOR);
         else entity->remove(ADJACENT_TO_FLOOR);

         if (collision_stepper.adjacent_to_top_edge(tile_width, tile_height)) entity->set(ADJACENT_TO_CEILING);
         else entity->remove(ADJACENT_TO_CEILING);

         if (collision_stepper.adjacent_to_left_edge(tile_width, tile_height)) entity->set(ADJACENT_TO_LEFT_WALL);
         else entity->remove(ADJACENT_TO_LEFT_WALL);

         if (collision_stepper.adjacent_to_right_edge(tile_width, tile_height)) entity->set(ADJACENT_TO_RIGHT_WALL);
         else entity->remove(ADJACENT_TO_RIGHT_WALL);
      }

      // update the collectables
      update_player_collisions_with_collectables();

      // update the player colliding on the goalposts
      update_player_collisions_with_goalposts();

      // update the player colliding on the doors
      //check_player_collisions_with_doors(); // this is now done by pressing 'UP' when over a door

      // delete entities flagged to be deleted
      cleanup_entities_flagged_for_deletion();

      // update camera
      if (camera_control_strategy) camera_control_strategy->update();

      return;
    body_dependency_symbols:
      - Wicked::EntityFlagNames
      - Wicked::Physics::AABB2D
      - Wicked::Physics::TileMapCollisionStepper
      - Wicked::Entities::CollectionHelper


  - name: cleanup_entities_flagged_for_deletion
    private: true
    body: |
      for (int i=0; i<entity_pool.size(); i++)
      {
         if (entity_pool[i]->exists(PLEASE_DELETE))
         {
            std::cout << "NOTICE: deleting entity." << std::endl;
            delete entity_pool[i];
            entity_pool.erase(entity_pool.begin() + i);
            i--;
         }
      }
      return;


  - name: check_player_collisions_with_doors
    private: true
    guards: [ player_controlled_entity, event_emitter ]
    body: |
      std::vector<Wicked::Entities::Basic2D*> _entities = get_current_map_entities();

      Wicked::Entities::CollectionHelper collection_helper(&_entities);
      float player_x = player_controlled_entity->get_place_ref().position.x;
      float player_y = player_controlled_entity->get_place_ref().position.y + 16;

      for (auto &entity : collection_helper.select_doors())
      {
         if (entity->get_place_ref().collide(player_x, player_y, 4, 4, 4, 4))
         {
            Wicked::Entities::Doors::Basic2D *door = static_cast<Wicked::Entities::Doors::Basic2D*>(entity);

            std::string game_event_name_to_emit = door->get_game_event_name_to_emit();
            bool this_door_emits_game_event = !game_event_name_to_emit.empty();
            if (this_door_emits_game_event)
            {
               event_emitter->emit_game_event(AllegroFlare::GameEvent(game_event_name_to_emit));
            }
            else // will door travel to another map or place on the current map
            {
               std::string map_target_name = door->get_target_map_name();
               float target_spawn_x = door->get_target_spawn_x();
               float target_spawn_y = door->get_target_spawn_y();

               // find the target map
               WickedDemos::TileMaps::Basic2D* target_map = find_map_by_name(map_target_name);

               // reposition player in map
               player_controlled_entity->set(ON_MAP_NAME, map_target_name);
               player_controlled_entity->get_place_ref().position.x = target_spawn_x;
               player_controlled_entity->get_place_ref().position.y = target_spawn_y;

               // set current map
               set_currently_active_map(map_target_name);
            }
            
            return;
         }
      }
      return;
    body_dependency_symbols:
      - Wicked::Entities::Doors::Basic2D
      - std::find


  - name: update_player_collisions_with_collectables
    private: true
    guards: [ player_controlled_entity ]
    body: |
      std::vector<Wicked::Entities::Basic2D*> _entities = get_current_map_entities();
      Wicked::Entities::CollectionHelper collection_helper(&_entities);
      float player_x = player_controlled_entity->get_place_ref().position.x;
      float player_y = player_controlled_entity->get_place_ref().position.y + 16;

      for (auto &entity : collection_helper.select_collectable_by_player())
      {
         if (entity->get_place_ref().collide(player_x, player_y, 4, 4, 4, 4))
         {
            entity->set(PLEASE_DELETE);
            // NOTE: typically will do something here as a result of picking up the item
         }
      }
      return;


  - name: update_player_collisions_with_goalposts
    private: true
    guards: [ player_controlled_entity ]
    body: |
      std::vector<Wicked::Entities::Basic2D*> _entities = get_current_map_entities();
      Wicked::Entities::CollectionHelper collection_helper(&_entities);
      float player_x = player_controlled_entity->get_place_ref().position.x;
      float player_y = player_controlled_entity->get_place_ref().position.y + 16;

      for (auto &entity : collection_helper.select_goalposts())
      {
         if (entity->get_place_ref().collide(player_x, player_y, 8, 8, 8, 8))
         {
            // TODO: this logic requires injection of the event emitter
            //framework->shutdown_program = true;
         }
      }
      return;


  - name: draw_entities
    body: |
      for (auto &entity : get_current_map_entities())
      {
         if (!entity->exists(INVISIBLE)) entity->draw();
      }
      return;


  - name: update_player_controls_on_player_controlled_entity
    guards: [ player_controlled_entity ]
    body: |
      // if this block is active, the player cannot control themselves while in the air, only when on the ground:
      //if (player_controlled_entity->exists(ADJACENT_TO_FLOOR))
      //{
         //player_controlled_entity->get_velocity_ref().position.x = 0.0;
      //}

      if (player_controls.get_right_bumper_pressed())
      {
         player_controlled_entity->get_velocity_ref().position.x = 0.0;
      }
      else
      {
         // if this block is active, the player cannot control themselves while in the air, only when on the ground:
         if (player_controlled_entity->exists(ADJACENT_TO_FLOOR))
         {
            player_controlled_entity->get_velocity_ref().position.x = 0.0;
         }

            if (player_controls.get_right_button_pressed())
            {
               player_controlled_entity->get_velocity_ref().position.x = 1.5; //2.0;
            }
            if (player_controls.get_left_button_pressed())
            {
               player_controlled_entity->get_velocity_ref().position.x = -1.5; //-2.0;
            }
      }
      return;


  - name: update
    guards: [ initialized ]
    body: |
      //return;
      update_player_controls_on_player_controlled_entity();
      //return;
      update_entities();
      return;


  - name: draw
    guards: [ initialized, currently_active_map, get_tile_mesh() ]
    body: |
      camera.setup_dimentional_projection(backbuffer_sub_bitmap);

      ALLEGRO_STATE previous_target_bitmap;
      al_store_state(&previous_target_bitmap, ALLEGRO_STATE_TARGET_BITMAP);
      al_set_target_bitmap(backbuffer_sub_bitmap);
      camera.start_reverse_transform();
      //camera.start_transform();

      al_set_render_state(ALLEGRO_DEPTH_FUNCTION, ALLEGRO_RENDER_LESS_EQUAL); // less or equal allows 
                                                                              // subsequent renders at the same
                                                                              // z-level to overwrite. This 
                                                                              // mimics the rendering of typical
                                                                              // "traditional" drawing functions
      //draw_entities(); // entities are drawn before the tilemap so there is not collision with the
                         // zbuffer
      if (show_tile_mesh) get_tile_mesh()->render();
      draw_entities();
      if (show_collision_tile_mesh) render_collision_tile_mesh();

      camera.restore_transform();
      al_restore_state(&previous_target_bitmap);
      
      return;
    body_dependency_symbols:
      - al_color_name


  - name: toggle_show_collision_tile_mesh
    body: |
      show_collision_tile_mesh = !show_collision_tile_mesh;
      return;


  - name: toggle_show_tile_mesh
    body: |
      show_tile_mesh = !show_tile_mesh;
      return;


  - name: primary_timer_func
    virtual: true
    override: true
    body: |
      update();
      draw();
      return;


  - name: key_char_func
    virtual: true
    override: true
    parameters:
      - name: event
        type: ALLEGRO_EVENT*
        default_argument: nullptr
    guards: [ initialized, event ]
    body: |
      switch (event->keyboard.keycode)
      {
      case ALLEGRO_KEY_1:
         //toggle_show_collision_tile_mesh();
         break;
      case ALLEGRO_KEY_2:
         //toggle_show_tile_mesh();
         break;
      default:
         break;
      }
      return;


  - name: key_up_func
    virtual: true
    override: true
    parameters:
      - name: event
        type: ALLEGRO_EVENT*
        default_argument: nullptr
    guards: [ initialized, event ]
    body: |
      switch (event->keyboard.keycode)
      {
         case ALLEGRO_KEY_LEFT:
            player_controls.set_left_button_pressed(false);
         break;

         case ALLEGRO_KEY_RIGHT:
            player_controls.set_right_button_pressed(false);
         break;
      }
      return;


  - name: key_down_func
    virtual: true
    override: true
    parameters:
      - name: event
        type: ALLEGRO_EVENT*
        default_argument: nullptr
    guards: [ initialized, event ]
    body: |
      switch (event->keyboard.keycode)
      {
         case ALLEGRO_KEY_LEFT:
            player_controls.set_left_button_pressed(true);
         break;

         case ALLEGRO_KEY_RIGHT:
            player_controls.set_right_button_pressed(true);
         break;

         case ALLEGRO_KEY_UP:
            player_controls.set_up_button_pressed(true);
            check_player_collisions_with_doors();
         break;

         case ALLEGRO_KEY_SPACE:
            set_player_controlled_entity_jump();
         break;
      }
      return;


  - name: virtual_control_button_down_func
    parameters:
      - name: event
        type: ALLEGRO_EVENT*
        default_argument: nullptr
    body: |
      int button_num = event->user.data1;

      if (button_num == AllegroFlare::VirtualControls::BUTTON_B)
      {
         player_controls.set_a_button_pressed(true);
         set_player_controlled_entity_jump();
      }
      else if (button_num == AllegroFlare::VirtualControls::BUTTON_X)
      {
         reverse_gravity();
      }
      else if (button_num == AllegroFlare::VirtualControls::BUTTON_Y)
      {
         player_emit_projectile();
      }
      else if (button_num == AllegroFlare::VirtualControls::BUTTON_RIGHT)
      {
         player_controls.set_right_button_pressed(true);
      }
      else if (button_num == AllegroFlare::VirtualControls::BUTTON_LEFT)
      {
         player_controls.set_left_button_pressed(true);
      }
      else if (button_num == AllegroFlare::VirtualControls::BUTTON_UP)
      {
         player_controls.set_up_button_pressed(true);
         check_player_collisions_with_doors();
      }
      else if (button_num == AllegroFlare::VirtualControls::BUTTON_RIGHT_BUMPER)
      {
         player_controls.set_right_bumper_pressed(true);
      }
      return;


  - name: virtual_control_button_up_func
    parameters:
      - name: event
        type: ALLEGRO_EVENT*
        default_argument: nullptr
    body: |
      int button_num = event->user.data1;

      if (button_num == AllegroFlare::VirtualControls::BUTTON_B)
      {
         player_controls.set_a_button_pressed(false);
      }
      else if (button_num == AllegroFlare::VirtualControls::BUTTON_RIGHT)
      {
         player_controls.set_right_button_pressed(false);
      }
      else if (button_num == AllegroFlare::VirtualControls::BUTTON_LEFT)
      {
         player_controls.set_left_button_pressed(false);
      }
      else if (button_num == AllegroFlare::VirtualControls::BUTTON_RIGHT_BUMPER)
      {
         player_controls.set_right_bumper_pressed(false);
      }
      return;


  - name: virtual_control_axis_change_func
    parameters:
      - name: event
        type: ALLEGRO_EVENT*
        default_argument: nullptr
    body: |
      int stick = event->user.data1;
      int axis = event->user.data2;
      float position = event->user.data3 / 255.0f;

      if (stick == AllegroFlare::VirtualControls::PRIMARY_STICK)
      {
         if (axis == 0)
         {
            AllegroFlare::vec2d vec = player_controls.get_primary_stick_position();
            vec.x = position;
            player_controls.set_primary_stick_position(vec);
         }
         if (axis == 1)
         {
            AllegroFlare::vec2d vec = player_controls.get_primary_stick_position();
            vec.y = position;
            player_controls.set_primary_stick_position(vec);
         }
      }

      if (axis == 0 && position > 0.5) player_controls.set_right_button_pressed(true);
      if (axis == 0 && position < 0.5 && position > -0.5)
      {
         player_controls.set_right_button_pressed(false);
         player_controls.set_left_button_pressed(false);
      }
      if (axis == 0 && position < -0.5) player_controls.set_left_button_pressed(true);
      
      return;


  - name: user_event_func
    virtual: true
    override: true
    parameters:
      - name: event
        type: ALLEGRO_EVENT*
        default_argument: nullptr
    body: |
      switch(event->type)
      {
         case ALLEGRO_FLARE_EVENT_VIRTUAL_CONTROL_BUTTON_UP:
           virtual_control_button_up_func(event);
         break;

         case ALLEGRO_FLARE_EVENT_VIRTUAL_CONTROL_BUTTON_DOWN:
           virtual_control_button_down_func(event);
         break;

         case ALLEGRO_FLARE_EVENT_VIRTUAL_CONTROL_AXIS_CHANGE:
           virtual_control_axis_change_func(event);
         break;
      }

      return;
    body_dependency_symbols:
      - AllegroFlare::EventNames


  - name: render_collision_tile_mesh
    guards: [ currently_active_map ]
    body: |
      AllegroFlare::TileMaps::TileMap<int> *tile_map = currently_active_map->get_collision_tile_mesh();
      float tile_width=16.0f;
      float tile_height=16.0f;

      if (!al_is_primitives_addon_initialized()) throw std::runtime_error("render_tile_map: primitives must be init");

      for (int y=0; y<tile_map->get_num_rows(); y++)
         for (int x=0; x<tile_map->get_num_columns(); x++)
         {
            int tile_type = tile_map->get_tile(x, y);
            switch(tile_type)
            {
               case 0:
                 al_draw_rectangle(x * tile_width, y * tile_height, (x+1) * tile_width, (y+1) * tile_height, 
                    ALLEGRO_COLOR{0.2, 0.2, 0.21, 0.21}, 1.0);
               break;

               case 1:
                 al_draw_filled_rectangle(x * tile_width, y * tile_height, (x+1) * tile_width, (y+1) * tile_height, 
                    ALLEGRO_COLOR{0.65, 0.62, 0.6, 1.0});
               break;

               default:
                 al_draw_filled_rectangle(x * tile_width, y * tile_height, (x+1) * tile_width, (y+1) * tile_height, 
                    ALLEGRO_COLOR{0.8, 0.32, 0.4, 1.0});
               break;
            }
         }
      return;


  - name: get_tile_atlas
    guards: [ currently_active_map ]
    type: AllegroFlare::TileMaps::PrimMeshAtlas*
    body: |
      return currently_active_map->get_tile_atlas();


  - name: get_tile_mesh
    guards: [ currently_active_map ]
    type: AllegroFlare::TileMaps::PrimMesh*
    body: |
      return currently_active_map->get_tile_mesh();


  - name: get_collision_tile_mesh
    guards: [ currently_active_map ]
    type: AllegroFlare::TileMaps::TileMap<int>*
    body: |
      return currently_active_map->get_collision_tile_mesh();


  - name: get_current_map_entities_ref
    type: std::vector<Wicked::Entities::Basic2D*>&
    guards: [ currently_active_map ]
    body: |
      return entity_pool;


  - name: get_current_map_entities
    type: std::vector<Wicked::Entities::Basic2D*>
    guards: [ player_controlled_entity ]
    body: |
      Wicked::Entities::CollectionHelper collection_helper(&entity_pool);
      std::string on_map_name = currently_active_map_name;
      return collection_helper.select_on_map(on_map_name);
    body_dependency_symbols:
      - Wicked::Entities::CollectionHelper


dependencies:


  - symbol: AllegroFlare::BitmapBin
    headers: [ AllegroFlare/BitmapBin.hpp ]
  - symbol: al_color_name
    headers: [ allegro5/allegro_color.h ]
  - symbol: std::map<int, int>
    headers: [ map ]
  - symbol: AllegroFlare::VirtualControls
    headers: [ AllegroFlare/VirtualControls.hpp ]
  - symbol: AllegroFlare::VirtualControlsProcessor
    headers: [ AllegroFlare/VirtualControlsProcessor.hpp ]
  - symbol: AllegroFlare::TileMaps::PrimMeshAtlas
    headers: [ AllegroFlare/TileMaps/PrimMeshAtlas.hpp ]
  - symbol: AllegroFlare::EventNames
    headers: [ AllegroFlare/EventNames.hpp ]
  - symbol: Tileo::TMJMeshLoader
    headers: [ Tileo/TMJMeshLoader.hpp ]
  - symbol: Wicked::Entities::Basic2DFactory
    headers: [ Wicked/Entities/Basic2DFactory.hpp ]
  - symbol: AllegroFlare::Screen
    headers: [ AllegroFlare/Screen.hpp ]
  - symbol: AllegroFlare::Frameworks::Full
    headers: [ AllegroFlare/Frameworks/Full.hpp ]
  - symbol: AllegroFlare::Placement2D
    headers: [ AllegroFlare/Placement2D.hpp ]
  - symbol: AllegroFlare::vec2d
    headers: [ AllegroFlare/Vec2D.hpp ]
  - symbol: al_color_name
    headers: [ allegro5/allegro_color.h ]
  - symbol: Wicked::Physics::TileMapCollisionStepper
    headers: [ Wicked/Physics/TileMapCollisionStepper.hpp ]
  - symbol: Wicked::Physics::AABB2D
    headers: [ Wicked/Physics/AABB2D.hpp ]
  - symbol: Wicked::EntityFlagNames
    headers: [ Wicked/EntityFlagNames.hpp ]
  - symbol: Wicked::Weapons::DrawnBow
    headers: [ Wicked/Weapons/DrawnBow.hpp ]
  - symbol: Wicked::CameraControlStrategies2D::Snap
    headers: [ Wicked/CameraControlStrategies2D/Snap.hpp ]
  - symbol: Wicked::CameraControlStrategies2D::SmoothSnap
    headers: [ Wicked/CameraControlStrategies2D/SmoothSnap.hpp ]
  - symbol: Wicked::CameraControlStrategies2D::HorizontalRail
    headers: [ Wicked/CameraControlStrategies2D/HorizontalRail.hpp ]
  - symbol: Wicked::Entities::CollectionHelper
    headers: [ Wicked/Entities/CollectionHelper.hpp ]
  - symbol: WickedDemos::TileMaps::Basic2D
    headers: [ WickedDemos/TileMaps/Basic2D.hpp ]
  - symbol: Wicked::Entities::Doors::Basic2D
    headers: [ Wicked/Entities/Doors/Basic2D.hpp ]
  - symbol: std::find
    headers: [ algorithm ]
  - symbol: tan
    headers: [ cmath ]
  - symbol: AllegroFlare::TileMaps::PrimMesh
    headers: [ AllegroFlare/TileMaps/PrimMesh.hpp ]
  - symbol: AllegroFlare::TileMaps::TileMap
    headers: [ AllegroFlare/TileMaps/TileMap.hpp ]
  - symbol: ALLEGRO_EVENT
    headers: [ allegro5/allegro.h ]
  - symbol: AllegroFlare::Display
    headers: [ AllegroFlare/Display.hpp ]
  - symbol: Wicked::CameraControlStrategies2D::Base
    headers: [ Wicked/CameraControlStrategies2D/Base.hpp ]
  - symbol: Wicked::Entities::Basic2D
    headers: [ Wicked/Entities/Basic2D.hpp ]
  - symbol: AllegroFlare::EventEmitter
    headers: [ AllegroFlare/EventEmitter.hpp ]
  - symbol: AllegroFlare::Screens::Base
    headers: [ AllegroFlare/Screens/Base.hpp ]
  - symbol: AllegroFlare::Camera2D
    headers: [ AllegroFlare/Camera2D.hpp ]
  - symbol: ALLEGRO_BITMAP
    headers: [ allegro5/allegro.h ]


