parent_classes:


  - class: AllegroFlare::Screens::Gameplay
    scope: public
# was AllegroFlare::Prototypes::Platforming2D::Screen::TYPE, at the time of this writing Screens/Gameplay does not
# have a proper mechanism to pass down the TYPE of this class
    init_with: ''


properties:


  - name: bitmap_bin
    type: AllegroFlare::BitmapBin*
    constructor_arg: true
    init_with: nullptr
    getter: true
    setter: false

  - name: event_emitter
    type: AllegroFlare::EventEmitter*
    init_with: nullptr
    constructor_arg: true
    setter: false

  - name: currently_active_map
    type: AllegroFlare::Prototypes::Platforming2D::Entities::TileMaps::Basic2D*
    init_with: nullptr

  - name: currently_active_map_name
    type: std::string
    init_with: '"[currently-active-map-name-unset]"'

  - name: entity_pool
    type: std::vector<AllegroFlare::Prototypes::Platforming2D::Entities::Basic2D*>
    init_with: '{}'
    setter: true

  - name: map_dictionary
    type: std::map<std::string, std::string>
    init_with: '{}'
    getter: true
    setter: false

  - name: gravity
    type: float
    init_with: 0.25f

  - name: gravity_reversed
    type: bool
    init_with: false

  - name: camera
    type: AllegroFlare::Camera2D
    init_with: ''

  - name: camera_baseline_zoom
    type: AllegroFlare::Vec2D
    init_with: '{4.8f, 4.5f}'
    getter: true
    setter: true

  - name: player_controlled_entity
    type: AllegroFlare::Prototypes::Platforming2D::Entities::Basic2D*
    init_with: nullptr
    getter: true
    setter: true

  - name: show_tile_mesh
    type: bool
    init_with: true
    getter: true
    setter: true

  - name: show_collision_tile_mesh
    type: bool
    init_with: false
    getter: true
    setter: true

  - name: show_visual_hint_on_suspended_gameplay
    type: bool
    init_with: false
    getter: true
    setter: true

  - name: player_control_velocity
    type: AllegroFlare::Vec2D
    init_with: AllegroFlare::Vec2D()

  - name: player_controls
    type: AllegroFlare::VirtualController
    init_with: ''

  - name: camera_control_strategy
    type: AllegroFlare::CameraControlStrategies2D::Base*
    init_with: nullptr

  - name: initialized
    type: bool 
    init_with: false

  - name: maps_initialized
    type: bool 
    init_with: false

  - name: TYPE
    type: char*
    init_with: '(char*)"AllegroFlare/Prototypes/Platforming2D/Screen"'
    static: true
    constexpr: true


documentation:


  - todos:
     - Attention needs to be brought to "gameplay_suspended" managing (This could be used during a game
       pause, some active dialog, an opened inventory screen, a transition, etc.).  The consequences of a paused state
       remains unevaluated. Some concerns include...
         - some entities may rely on real-world clocks to update their states
         - user controls may become backlogged, need to be cleared or recaptured at unsuspend
         - other things not considered
         - possible re-collisions on unpause
         - audio (pausing in-environment and in-game sound effects)


methods:


  - name: set_map_dictionary
    parameters:
      - name: map_dictionary
        type: std::map<std::string, std::string>
        default_argument: '{}'
    guards: [ (!initialized) ]
    body: |
      this->map_dictionary = map_dictionary;
      // TODO: allow this to be set after initialization
      return;


  - name: set_event_emitter
    parameters:
      - name: event_emitter
        type: AllegroFlare::EventEmitter*
        default_argument: nullptr
    guards: [ (!initialized) ]
    body: |
      this->event_emitter = event_emitter;
      return;


  - name: set_bitmap_bin
    parameters:
      - name: bitmap_bin
        type: AllegroFlare::BitmapBin*
        default_argument: nullptr
    guards: [ (!initialized) ]
    body: |
      this->bitmap_bin = bitmap_bin;
      return;


  - name: set_currently_active_map
    parameters:
      - name: name
        type: std::string
        default_argument: '"[unset-current-map-name-to-use]"'
    body: |
      currently_active_map = find_map_by_name(name);
      if (!currently_active_map) throw std::runtime_error("Bruh, no map");
      currently_active_map_name = name;
      return;


  - name: find_map_by_name
    type: AllegroFlare::Prototypes::Platforming2D::Entities::TileMaps::Basic2D*
    parameters:
      - name: name
        type: std::string
        default_argument: '"[unset-map-name]"'
    body: |
      AllegroFlare::Prototypes::Platforming2D::EntityCollectionHelper collection_helper(&entity_pool);
      AllegroFlare::Prototypes::Platforming2D::Entities::TileMaps::Basic2D* found_map =
         collection_helper.find_map_by_name(name);
      if (!found_map)
      {
         std::stringstream error_message;
         error_message << "map named \"" << name << "\" does not exist.";
         throw std::runtime_error(error_message.str());

      }

      return found_map;


  - name: on_activate
    virtual: true
    override: true
    guards: [ initialized ]
    body: |
      // nothing here
      return;


  - name: on_deactivate
    virtual: true
    override: true
    guards: [ initialized ]
    body: |
      // nothing here
      return;


  - name: initialize_maps
    guards: [ (!maps_initialized), (!map_dictionary.empty()) ]
    body: |
      AllegroFlare::Prototypes::Platforming2D::Entities::Basic2DFactory factory(bitmap_bin);

      for (auto &map_dictionary_entry : map_dictionary)
      {
         std::string map_name = std::get<0>(map_dictionary_entry);
         std::string map_filename = std::get<1>(map_dictionary_entry);
         AllegroFlare::Prototypes::Platforming2D::Entities::TileMaps::Basic2D *created_map =
            factory.create_tile_map(map_filename, map_name);
         entity_pool.push_back(created_map);
      }

      maps_initialized = true;

      return;


  - name: initialize_camera_control
    guards: [ player_controlled_entity ]
    type: void
    body: |
      float assumed_tile_width = 16.0f;
      float assumed_tile_height = 16.0f;
      float room_width = assumed_tile_width * 25; // tile_mesh->get_real_width();
      float room_height = assumed_tile_height * 15; //tile_mesh->get_real_height();

      AllegroFlare::CameraControlStrategies2D::SmoothSnapWithZoomEffect *camera_control =
         new AllegroFlare::CameraControlStrategies2D::SmoothSnapWithZoomEffect(room_width, room_height);
      //AllegroFlare::CameraControlStrategies2D::HorizontalRail *camera_control =
         //new AllegroFlare::CameraControlStrategies2D::HorizontalRail; //(room_width, room_height);
      camera_control->set_camera(&camera);
      camera_control->set_entity_to_follow(player_controlled_entity);
      camera_control->initialize();

      camera_control_strategy = camera_control;
      return;
    body_dependency_symbols:
      - AllegroFlare::CameraControlStrategies2D::Snap
      - AllegroFlare::CameraControlStrategies2D::SmoothSnap
      - AllegroFlare::CameraControlStrategies2D::SmoothSnapWithZoomEffect
      - AllegroFlare::CameraControlStrategies2D::HorizontalRail


  - name: initialize_player_controls
    body: |
      player_controls.clear();
      return;


  - name: initialize_camera
    private: true
    guards: [ currently_active_map, currently_active_map->get_tile_atlas(), currently_active_map->get_tile_mesh() ]
    body: |
      //camera.size = { 1920.0f, 1080.0f };
      camera.size = AllegroFlare::vec2d(1920.0f, 1080.0f);
      camera.align = AllegroFlare::vec2d(0.5, 0.5);
 
      //float width = tile_mesh->get_real_width();
      //float height = tile_mesh->get_real_height();

      float room_width = currently_active_map->get_tile_mesh()->get_tile_width() * 25; // tile_mesh->get_real_width();
      float room_height = currently_active_map->get_tile_mesh()->get_tile_height() * 15; //tile_mesh->get_real_height();

      // note that Shovel Knight has 4.5x4.5 sized pixels (actually 4.8 x 4.5)
         // this means:
         //     - a virtual resolution of 400x240
         //     = a native display resolution of 1920x1080 (HD)
         //     - 25 tiles x 15 tiles to fill the virtual resolution
         //     - 16x16 pixel tiles
         // see https://www.yachtclubgames.com/blog/breaking-the-nes

      camera.set_zoom(camera_baseline_zoom);
      //AllegroFlare::vec2d(1.0 / 4.8, 1.0 / 4.5);
      camera.position = {room_width/2, room_height/2};

      return;


  - name: initialize
    type: void
    guards:
      - bitmap_bin
    body: |
      set_update_strategy(AllegroFlare::Screens::Base::UpdateStrategy::SEPARATE_UPDATE_AND_RENDER_FUNCS);
      initialize_camera_control();
      initialize_player_controls();
      initialize_camera();
      initialized = true;
      return;


  - name: add_entity_to_pool
    type: void
    parameters:
      - name: entity
        type: AllegroFlare::Prototypes::Platforming2D::Entities::Basic2D*
        default_argument: nullptr
    body: |
      entity_pool.push_back(entity);
      return;


  - name: unset_player_controlled_entity_vertical_velocity
    body: |
      if (!player_controlled_entity) return;
      player_controlled_entity->get_velocity_ref().position.y = 0;
      return;


  - name: unset_player_controlled_entity_horizontal_velocity
    body: |
      if (!player_controlled_entity) return;
      player_controlled_entity->get_velocity_ref().position.x = 0;
      return;


  - name: set_player_controlled_entity_jump
    guards: [ player_controlled_entity ]
    body: |
      using namespace AllegroFlare::Prototypes::Platforming2D::EntityFlagNames;

      if (!player_controlled_entity) return;
      if (player_controlled_entity->exists(ADJACENT_TO_FLOOR))
      {
         player_controlled_entity->get_velocity_ref().position.y -= 4.25;
      }
      else if (player_controlled_entity->exists(ADJACENT_TO_LEFT_WALL))
      {
         player_controlled_entity->get_velocity_ref().position.y = -3.5;
         player_controlled_entity->get_velocity_ref().position.x = 3.0;
      }
      else if (player_controlled_entity->exists(ADJACENT_TO_RIGHT_WALL))
      {
         player_controlled_entity->get_velocity_ref().position.y = -3.5;
         player_controlled_entity->get_velocity_ref().position.x = -3.0;
      }
      return;
    body_dependency_symbols:
      - AllegroFlare::Prototypes::Platforming2D::EntityFlagNames


  - name: player_emit_projectile
    parameters:
      - name: magnitude
        type: float
        default_argument: 3.0f
    body: |
      using namespace AllegroFlare::Prototypes::Platforming2D::EntityFlagNames;

      AllegroFlare::vec2d player_pos = player_controlled_entity->get_place_ref().position;
      //AllegroFlare::vec2d player_center_pos = player_pos;
      //AllegroFlare::vec2d aim_dir = player_controls.get_primary_stick_position(); //.normalized();
      AllegroFlare::vec2d aim_pos = player_controls.get_primary_stick_position(); //.normalized();

      if ((aim_pos.x < 0.00001) && (aim_pos.x > -0.00001))
      if ((aim_pos.y < 0.00001) && (aim_pos.y > -0.00001))
      {
         aim_pos = {1, 0};
      }


      std::string on_map_name = player_controlled_entity->get(ON_MAP_NAME);


      AllegroFlare::Prototypes::Platforming2D::Entities::Basic2DFactory factory(bitmap_bin);
      AllegroFlare::Prototypes::Platforming2D::Entities::Basic2D* projectile = factory.create_player_projectile(
         on_map_name,
         player_pos.x,
         player_pos.y,
         8-1,
         8-1,
         aim_pos,
         magnitude
      );
      entity_pool.push_back(projectile);


      // HERE
      return;
    body_dependency_symbols:
      - AllegroFlare::Prototypes::Platforming2D::Entities::Basic2DFactory
      - AllegroFlare::Prototypes::Platforming2D::EntityFlagNames


  - name: reverse_gravity
    body: gravity_reversed = !gravity_reversed;


  - name: update_entities
    guards: [ initialized, currently_active_map ]
    body: |
      using namespace AllegroFlare::Prototypes::Platforming2D::EntityFlagNames;

      // apply gravity
      for (auto &entity : get_current_map_entities())
      {
         if (entity->exists(NOT_AFFECTED_BY_GRAVITY)) continue;
         AllegroFlare::Placement2D &velocity = entity->get_velocity_ref();
         velocity.position.y += (gravity_reversed ? -gravity : gravity);
      }

      // update the entities (typically includes movement strategies)
      for (auto &entity : get_current_map_entities())
      {
         entity->update();
      }

      // step each entity
      for (auto &entity : get_current_map_entities())
      {
         AllegroFlare::Placement2D &place = entity->get_place_ref();
         AllegroFlare::Placement2D &velocity = entity->get_velocity_ref();

         // handle case where entity does not interact with world tile mesh
         if (entity->exists(DOES_NOT_COLLIDE_WITH_WORLD))
         {
            place.position.x += velocity.position.x;
            place.position.y += velocity.position.y;
            continue;
         }

         // create a "simulated aabb2d" of the entity and run it through the collision stepper
         AllegroFlare::Physics::AABB2D aabb2d(
            place.position.x - place.size.x * place.align.x,
            place.position.y - place.size.y * place.align.y,
            place.size.x,
            place.size.y,
            velocity.position.x,
            velocity.position.y
         );
         float tile_width = 16.0f;
         float tile_height = 16.0f;
         AllegroFlare::Physics::TileMapCollisionStepper collision_stepper(
            currently_active_map->get_collision_tile_mesh(),
            &aabb2d,
            tile_width,
            tile_height
         );
         collision_stepper.step();

         // supplant our entity's position and velocity values with the "simulated aabb2d"'s values
         place.position.x = aabb2d.get_x() + place.size.x * place.align.x;
         place.position.y = aabb2d.get_y() + place.size.y * place.align.y;
         velocity.position.x = aabb2d.get_velocity_x();
         velocity.position.y = aabb2d.get_velocity_y();

         // add positioning flags
         if (collision_stepper.adjacent_to_bottom_edge(tile_width, tile_height)) entity->set(ADJACENT_TO_FLOOR);
         else entity->remove(ADJACENT_TO_FLOOR);

         if (collision_stepper.adjacent_to_top_edge(tile_width, tile_height)) entity->set(ADJACENT_TO_CEILING);
         else entity->remove(ADJACENT_TO_CEILING);

         if (collision_stepper.adjacent_to_left_edge(tile_width, tile_height)) entity->set(ADJACENT_TO_LEFT_WALL);
         else entity->remove(ADJACENT_TO_LEFT_WALL);

         if (collision_stepper.adjacent_to_right_edge(tile_width, tile_height)) entity->set(ADJACENT_TO_RIGHT_WALL);
         else entity->remove(ADJACENT_TO_RIGHT_WALL);
      }

      // update the collectables
      // TODO: allow this function to run without being coupled with a "player_controlled_entity"
      if (player_controlled_entity) update_player_collisions_with_collectables();

      // update the player colliding on the goalposts
      // TODO: allow this function to run without being coupled with a "player_controlled_entity"
      if (player_controlled_entity) update_player_collisions_with_goalposts();

      // update the player colliding on the doors
      //check_player_collisions_with_doors(); // this is now done by pressing 'UP' when over a door

      // delete entities flagged to be deleted
      cleanup_entities_flagged_for_deletion();

      // update camera
      if (camera_control_strategy) camera_control_strategy->update();

      return;
    body_dependency_symbols:
      - AllegroFlare::Prototypes::Platforming2D::EntityFlagNames
      - AllegroFlare::Physics::AABB2D
      - AllegroFlare::Physics::TileMapCollisionStepper
      - AllegroFlare::Prototypes::Platforming2D::EntityCollectionHelper


  - name: cleanup_entities_flagged_for_deletion
    private: true
    body: |
      using namespace AllegroFlare::Prototypes::Platforming2D::EntityFlagNames;

      for (int i=0; i<entity_pool.size(); i++)
      {
         if (entity_pool[i]->exists(PLEASE_DELETE))
         {
            std::cout << "NOTICE: deleting entity." << std::endl;
            delete entity_pool[i];
            entity_pool.erase(entity_pool.begin() + i);
            i--;
         }
      }
      return;
    body_dependency_symbols:
      - AllegroFlare::Prototypes::Platforming2D::EntityFlagNames


  - name: check_player_collisions_with_doors
    private: true
    guards: [ player_controlled_entity, event_emitter ]
    body: |
      using namespace AllegroFlare::Prototypes::Platforming2D::EntityFlagNames;

      std::vector<AllegroFlare::Prototypes::Platforming2D::Entities::Basic2D*> _entities = get_current_map_entities();
      AllegroFlare::Prototypes::Platforming2D::EntityCollectionHelper collection_helper(&_entities);

      float player_x = player_controlled_entity->get_place_ref().position.x;
      float player_y = player_controlled_entity->get_place_ref().position.y + 16;

      for (auto &entity : collection_helper.select_doors())
      {
         if (entity->get_place_ref().collide(player_x, player_y, 4, 4, 4, 4))
         {
            AllegroFlare::Prototypes::Platforming2D::Entities::Doors::Basic2D *door =
               static_cast<AllegroFlare::Prototypes::Platforming2D::Entities::Doors::Basic2D*>(entity);

            std::string game_event_name_to_emit = door->get_game_event_name_to_emit();
            bool this_door_emits_game_event = !game_event_name_to_emit.empty();
            if (this_door_emits_game_event)
            {
               event_emitter->emit_game_event(AllegroFlare::GameEvent(game_event_name_to_emit));
            }
            else // will door travel to another map or place on the current map
            {
               std::string map_target_name = door->get_target_map_name();
               float target_spawn_x = door->get_target_spawn_x();
               float target_spawn_y = door->get_target_spawn_y();

               // find the target map
               AllegroFlare::Prototypes::Platforming2D::Entities::TileMaps::Basic2D* target_map =
                  find_map_by_name(map_target_name);

               // reposition player in map
               player_controlled_entity->set(ON_MAP_NAME, map_target_name);
               player_controlled_entity->get_place_ref().position.x = target_spawn_x;
               player_controlled_entity->get_place_ref().position.y = target_spawn_y;

               // set current map
               set_currently_active_map(map_target_name);
            }
            
            return;
         }
      }
      return;
    body_dependency_symbols:
      - AllegroFlare::Prototypes::Platforming2D::EntityFlagNames
      - AllegroFlare::Prototypes::Platforming2D::EntityCollectionHelper
      - AllegroFlare::Prototypes::Platforming2D::Entities::Doors::Basic2D
      - std::find


  - name: update_player_collisions_with_collectables
    private: true
    guards: [ player_controlled_entity ]
    body: |
      // TODO: allow this function to run without being coupled with a "player_controlled_entity"
      using namespace AllegroFlare::Prototypes::Platforming2D::EntityFlagNames;

      std::vector<AllegroFlare::Prototypes::Platforming2D::Entities::Basic2D*> _entities = get_current_map_entities();
      AllegroFlare::Prototypes::Platforming2D::EntityCollectionHelper collection_helper(&_entities);
      float player_x = player_controlled_entity->get_place_ref().position.x;
      float player_y = player_controlled_entity->get_place_ref().position.y + 16;

      for (auto &entity : collection_helper.select_collectable_by_player())
      {
         if (entity->get_place_ref().collide(player_x, player_y, 4, 4, 4, 4))
         {
            entity->set(PLEASE_DELETE);
            // NOTE: typically will do something here as a result of picking up the item
         }
      }
      return;
    body_dependency_symbols:
      - AllegroFlare::Prototypes::Platforming2D::EntityFlagNames
      - AllegroFlare::Prototypes::Platforming2D::EntityCollectionHelper


  - name: update_player_collisions_with_goalposts
    private: true
    guards: [ player_controlled_entity ]
    body: |
      // TODO: allow this function to run without being coupled with a "player_controlled_entity"
      std::vector<AllegroFlare::Prototypes::Platforming2D::Entities::Basic2D*> _entities = get_current_map_entities();
      AllegroFlare::Prototypes::Platforming2D::EntityCollectionHelper collection_helper(&_entities);

      float player_x = player_controlled_entity->get_place_ref().position.x;
      float player_y = player_controlled_entity->get_place_ref().position.y + 16;

      for (auto &entity : collection_helper.select_goalposts())
      {
         if (entity->get_place_ref().collide(player_x, player_y, 8, 8, 8, 8))
         {
            // TODO: this logic requires injection of the event emitter
            //framework->shutdown_program = true;
         }
      }
      return;
    body_dependency_symbols:
      - AllegroFlare::Prototypes::Platforming2D::EntityCollectionHelper


  - name: draw_entities
    body: |
      using namespace AllegroFlare::Prototypes::Platforming2D::EntityFlagNames;

      for (auto &entity : get_current_map_entities())
      {
         if (!entity->exists(INVISIBLE)) entity->draw();
      }
      return;
    body_dependency_symbols:
      - AllegroFlare::Prototypes::Platforming2D::EntityFlagNames


  - name: update_player_controls_on_player_controlled_entity
    guards: [ player_controlled_entity ]
    body: |
      using namespace AllegroFlare::Prototypes::Platforming2D::EntityFlagNames;

      // if this block is active, the player cannot control themselves while in the air, only when on the ground:
      //if (player_controlled_entity->exists(ADJACENT_TO_FLOOR))
      //{
         //player_controlled_entity->get_velocity_ref().position.x = 0.0;
      //}

      if (player_controls.get_right_bumper_pressed())
      {
         player_controlled_entity->get_velocity_ref().position.x = 0.0;
      }
      else
      {
         // if this block is active, the player cannot control themselves while in the air, only when on the ground:
         if (player_controlled_entity->exists(ADJACENT_TO_FLOOR))
         {
            player_control_velocity.x = 0.0;
            //player_controlled_entity->get_velocity_ref().position.x = 0.0;
         }

            if (player_controls.get_right_button_pressed())
            {
               //player_control_velocity.x = 1.0;
               player_control_velocity.x = 1.0;
               player_controlled_entity->set_bitmap_flip_h(false);
               //player_controlled_entity->get_velocity_ref().position.x = 1.5; //2.0;
            }
            if (player_controls.get_left_button_pressed())
            {
               //player_control_velocity.x = -1.0;
               player_control_velocity.x = -1.0;
               player_controlled_entity->set_bitmap_flip_h(true);
               //player_controlled_entity->get_velocity_ref().position.x = -1.5; //-2.0;
            }
      }


      float player_speed = 1.5;
      player_controlled_entity->get_velocity_ref().position.x = player_control_velocity.x * player_speed;


      return;
    body_dependency_symbols:
      - AllegroFlare::Prototypes::Platforming2D::EntityFlagNames


  - name: update
    guards: [ initialized ]
    body: |
      if (!get_gameplay_suspended())
      {
         if (player_controlled_entity) update_player_controls_on_player_controlled_entity();
         update_entities();
      }
      return;


  - name: draw
    guards: [ initialized, currently_active_map, get_tile_mesh() ]
    body: |
      //ALLEGRO_STATE previous_target_bitmap;

      ALLEGRO_BITMAP *target_bitmap = al_get_target_bitmap();
      camera.setup_dimensional_projection(target_bitmap);

      //ALLEGRO_STATE previous_target_bitmap;
      //al_store_state(&previous_target_bitmap, ALLEGRO_STATE_TARGET_BITMAP);
      //al_set_target_bitmap(target_bitmap);
      camera.start_reverse_transform();
      //camera.start_transform();

      al_set_render_state(ALLEGRO_DEPTH_FUNCTION, ALLEGRO_RENDER_LESS_EQUAL); // less or equal allows 
                                                                              // subsequent renders at the same
                                                                              // z-level to overwrite. This 
                                                                              // mimics the rendering of typical
                                                                              // "traditional" drawing functions
      //draw_entities(); // entities are drawn before the tilemap so there is not collision with the
                         // zbuffer
      if (show_tile_mesh) get_tile_mesh()->render();
      draw_entities();
      if (show_collision_tile_mesh) render_collision_tile_mesh();

      camera.restore_transform();

      // Indicate a hint on suspended gameplay
      if (get_gameplay_suspended() && show_visual_hint_on_suspended_gameplay)
      {
         float surface_width = al_get_bitmap_width(target_bitmap);
         float surface_height = al_get_bitmap_height(target_bitmap); //native_display_resolution_height;
         al_draw_filled_rectangle(100, 100, surface_width-100, surface_height-100, ALLEGRO_COLOR{0.0, 0.0, 0.0, 0.2});
      }

      //al_restore_state(&previous_target_bitmap);
      
      return;
    body_dependency_symbols:
      - al_color_name


  - name: toggle_show_collision_tile_mesh
    body: |
      show_collision_tile_mesh = !show_collision_tile_mesh;
      return;


  - name: toggle_show_tile_mesh
    body: |
      show_tile_mesh = !show_tile_mesh;
      return;


  - name: primary_update_func
    virtual: true
    override: true
    parameters:
      - name: time_now
        type: double
        default_argument: 0.0
      - name: delta_time
        type: double
        default_argument: 0.0
    body: |
      update();
      return;


  - name: primary_render_func
    virtual: true
    override: true
    body: |
      draw();
      return;


  - name: key_char_func
    virtual: true
    override: true
    parameters:
      - name: event
        type: ALLEGRO_EVENT*
        default_argument: nullptr
    guards: [ initialized, event ]
    body: |
      switch (event->keyboard.keycode)
      {
      case ALLEGRO_KEY_1:
         //toggle_show_collision_tile_mesh();
         break;
      case ALLEGRO_KEY_2:
         //toggle_show_tile_mesh();
         break;
      case ALLEGRO_KEY_PAD_PLUS:
         camera.set_zoom(camera.get_zoom() + AllegroFlare::Vec2D({0.1, 0.1}));
         break;
      case ALLEGRO_KEY_PAD_MINUS:
         camera.set_zoom(camera.get_zoom() - AllegroFlare::Vec2D({0.1, 0.1}));
         break;
      default:
         break;
      }
      return;


  - name: key_up_func
    virtual: true
    override: true
    parameters:
      - name: event
        type: ALLEGRO_EVENT*
        default_argument: nullptr
    guards: [ initialized, event ]
    body: |
      switch (event->keyboard.keycode)
      {
         case ALLEGRO_KEY_LEFT:
            //player_control_velocity.y = 0.0;
            player_controls.set_left_button_pressed(false);
         break;

         case ALLEGRO_KEY_RIGHT:
            //player_control_velocity.y = 0.0;
            player_controls.set_right_button_pressed(false);
         break;
      }
      return;


  - name: key_down_func
    virtual: true
    override: true
    parameters:
      - name: event
        type: ALLEGRO_EVENT*
        default_argument: nullptr
    guards: [ initialized, event ]
    body: |
      if (!get_gameplay_suspended())
      {
         switch (event->keyboard.keycode)
         {
            case ALLEGRO_KEY_LEFT:
               //player_control_velocity.x = 0.0;
               player_controls.set_left_button_pressed(true);
            break;

            case ALLEGRO_KEY_RIGHT:
               //player_control_velocity.x = 1.0;
               player_controls.set_right_button_pressed(true);
            break;

            case ALLEGRO_KEY_UP:
               //player_control_velocity.y = -1.0;
               player_controls.set_up_button_pressed(true);
               check_player_collisions_with_doors();
            break;

            case ALLEGRO_KEY_DOWN:
               //player_control_velocity.y = 1.0;
            break;

            case ALLEGRO_KEY_SPACE:
               set_player_controlled_entity_jump();
            break;
         }
      }

      switch (event->keyboard.keycode) // TODO: Add boolean option to disable this "manual" toggling of pause
      {
         case ALLEGRO_KEY_P:
            toggle_suspend_gameplay();
         break;
      }
      return;


  - name: virtual_control_button_down_func
    virtual: true
    override: true
    parameters:
      - name: player
        type: AllegroFlare::Player*
        default_argument: nullptr
      - name: virtual_controller
        type: AllegroFlare::VirtualControllers::Base*
        default_argument: nullptr
      - name: virtual_controller_button_num
        type: int
        default_argument: 0
      - name: is_repeat
        type: bool
        default_argument: false
    guards: [ initialized ]
    body: |
      //int virtual_controller_button_num = event->user.data1;

      // TODO: validate virtual controller type

      if (!get_gameplay_suspended())
      {
         // TODO: Investigate if there are some inputs that should be "active" at unpause (like staying crouched, 
         // continuing moving forward if paused mid-jump, etc)
         if (virtual_controller_button_num == AllegroFlare::VirtualControllers::GenericController::BUTTON_B)
         {
            player_controls.set_a_button_pressed(true);
            set_player_controlled_entity_jump();
         }
         else if (virtual_controller_button_num == AllegroFlare::VirtualControllers::GenericController::BUTTON_X)
         {
            reverse_gravity();
         }
         else if (virtual_controller_button_num == AllegroFlare::VirtualControllers::GenericController::BUTTON_Y)
         {
            player_emit_projectile();
         }
         else if (virtual_controller_button_num == AllegroFlare::VirtualControllers::GenericController::BUTTON_RIGHT)
         {
            player_controls.set_right_button_pressed(true);
         }
         else if (virtual_controller_button_num == AllegroFlare::VirtualControllers::GenericController::BUTTON_LEFT)
         {
            player_controls.set_left_button_pressed(true);
         }
         else if (virtual_controller_button_num == AllegroFlare::VirtualControllers::GenericController::BUTTON_UP)
         {
            player_controls.set_up_button_pressed(true);
            check_player_collisions_with_doors();
         }
         else if (virtual_controller_button_num == AllegroFlare::VirtualControllers::GenericController::BUTTON_RIGHT_BUMPER)
         {
            // TODO: block if gameplay is suspended
            player_controls.set_right_bumper_pressed(true);
         }
      }
      return;
    body_dependency_symbols:
      - AllegroFlare::VirtualControllers::GenericController


  - name: virtual_control_button_up_func
    virtual: true
    override: true
    parameters:
      - name: player
        type: AllegroFlare::Player*
        default_argument: nullptr
      - name: virtual_controller
        type: AllegroFlare::VirtualControllers::Base*
        default_argument: nullptr
      - name: virtual_controller_button_num
        type: int
        default_argument: 0
      - name: is_repeat
        type: bool
        default_argument: false
    guards: [ initialized ]
    body: |
      //int virtual_controller_button_num = event->user.data1;

      // TODO: validate virtual controller type

      if (!get_gameplay_suspended())
      {
         // TODO: Investigate if there are some inputs that should be "active" at unpause (like staying crouched, 
         // continuing moving forward if paused mid-jump, etc)
         if (virtual_controller_button_num == AllegroFlare::VirtualControllers::GenericController::BUTTON_B)
         {
            player_controls.set_a_button_pressed(false);
         }
         else if (virtual_controller_button_num == AllegroFlare::VirtualControllers::GenericController::BUTTON_RIGHT)
         {
            player_controls.set_right_button_pressed(false);
         }
         else if (virtual_controller_button_num == AllegroFlare::VirtualControllers::GenericController::BUTTON_LEFT)
         {
            player_controls.set_left_button_pressed(false);
         }
         else if (virtual_controller_button_num == AllegroFlare::VirtualControllers::GenericController::BUTTON_RIGHT_BUMPER)
         {
            player_controls.set_right_bumper_pressed(false);
         }
      }
      return;
    body_dependency_symbols:
      - AllegroFlare::VirtualControllers::GenericController


  - name: virtual_control_axis_change_func
    virtual: true
    override: true
    parameters:
      - name: event
        type: ALLEGRO_EVENT*
        default_argument: nullptr
    body: |
      int stick = event->user.data1;
      int axis = event->user.data2;
      float position = event->user.data3 / 255.0f;

      if (stick == AllegroFlare::VirtualControllers::GenericController::PRIMARY_STICK)
      {
         if (axis == 0)
         {
            AllegroFlare::vec2d vec = player_controls.get_primary_stick_position();
            vec.x = position;
            player_controls.set_primary_stick_position(vec);
         }
         if (axis == 1)
         {
            AllegroFlare::vec2d vec = player_controls.get_primary_stick_position();
            vec.y = position;
            player_controls.set_primary_stick_position(vec);
         }
      }

      if (axis == 0 && position > 0.5) player_controls.set_right_button_pressed(true);
      if (axis == 0 && position < 0.5 && position > -0.5)
      {
         player_controls.set_right_button_pressed(false);
         player_controls.set_left_button_pressed(false);
      }
      if (axis == 0 && position < -0.5) player_controls.set_left_button_pressed(true);
      
      return;


  - name: user_event_func
    virtual: true
    override: true
    parameters:
      - name: event
        type: ALLEGRO_EVENT*
        default_argument: nullptr
    body: |
      switch(event->type)
      {
         //case ALLEGRO_FLARE_EVENT_VIRTUAL_CONTROL_BUTTON_UP:
           //virtual_control_button_up_func(event);
         //break;

         //case ALLEGRO_FLARE_EVENT_VIRTUAL_CONTROL_BUTTON_DOWN:
           //virtual_control_button_down_func(event);
         //break;

         //case ALLEGRO_FLARE_EVENT_VIRTUAL_CONTROL_AXIS_CHANGE:
           //virtual_control_axis_change_func(event);
         //break;
      }

      return;
    body_dependency_symbols:
      - AllegroFlare::EventNames


  - name: render_collision_tile_mesh
    guards: [ currently_active_map ]
    body: |
      AllegroFlare::TileMaps::TileMap<int> *tile_map = currently_active_map->get_collision_tile_mesh();
      float tile_width=16.0f;
      float tile_height=16.0f;

      if (!al_is_primitives_addon_initialized()) throw std::runtime_error("render_tile_map: primitives must be init");

      for (int y=0; y<tile_map->get_num_rows(); y++)
         for (int x=0; x<tile_map->get_num_columns(); x++)
         {
            int tile_type = tile_map->get_tile(x, y);
            switch(tile_type)
            {
               case 0:
                 al_draw_rectangle(x * tile_width, y * tile_height, (x+1) * tile_width, (y+1) * tile_height, 
                    ALLEGRO_COLOR{0.2, 0.2, 0.21, 0.21}, 1.0);
               break;

               case 1:
                 al_draw_filled_rectangle(x * tile_width, y * tile_height, (x+1) * tile_width, (y+1) * tile_height, 
                    ALLEGRO_COLOR{0.65, 0.62, 0.6, 1.0});
               break;

               default:
                 al_draw_filled_rectangle(x * tile_width, y * tile_height, (x+1) * tile_width, (y+1) * tile_height, 
                    ALLEGRO_COLOR{0.8, 0.32, 0.4, 1.0});
               break;
            }
         }
      return;


  - name: get_tile_atlas
    guards: [ currently_active_map ]
    type: AllegroFlare::TileMaps::PrimMeshAtlas*
    body: |
      return currently_active_map->get_tile_atlas();


  - name: get_tile_mesh
    guards: [ currently_active_map ]
    type: AllegroFlare::TileMaps::PrimMesh*
    body: |
      return currently_active_map->get_tile_mesh();


  - name: get_collision_tile_mesh
    guards: [ currently_active_map ]
    type: AllegroFlare::TileMaps::TileMap<int>*
    body: |
      return currently_active_map->get_collision_tile_mesh();


  - name: get_current_map_entities
    type: std::vector<AllegroFlare::Prototypes::Platforming2D::Entities::Basic2D*>
    body: |
      AllegroFlare::Prototypes::Platforming2D::EntityCollectionHelper collection_helper(&entity_pool);
      std::string on_map_name = currently_active_map_name;
      return collection_helper.select_on_map(on_map_name);
    body_dependency_symbols:
      - AllegroFlare::Prototypes::Platforming2D::EntityCollectionHelper


dependencies:


  - symbol: AllegroFlare::BitmapBin
    headers: [ AllegroFlare/BitmapBin.hpp ]
  - symbol: al_color_name
    headers: [ allegro5/allegro_color.h ]
  - symbol: std::map<int, int>
    headers: [ map ]
  - symbol: AllegroFlare::VirtualController
    headers: [ AllegroFlare/VirtualController.hpp ]
  - symbol: AllegroFlare::VirtualControlsProcessor
    headers: [ AllegroFlare/VirtualControlsProcessor.hpp ]
  - symbol: AllegroFlare::TileMaps::PrimMeshAtlas
    headers: [ AllegroFlare/TileMaps/PrimMeshAtlas.hpp ]
  - symbol: AllegroFlare::EventNames
    headers: [ AllegroFlare/EventNames.hpp ]
  - symbol: AllegroFlare::Prototypes::Platforming2D::Entities::Basic2DFactory
    headers: [ AllegroFlare/Prototypes/Platforming2D/Entities/Basic2DFactory.hpp ]
  - symbol: AllegroFlare::Screen
    headers: [ AllegroFlare/Screen.hpp ]
  - symbol: AllegroFlare::Frameworks::Full
    headers: [ AllegroFlare/Frameworks/Full.hpp ]
  - symbol: AllegroFlare::Placement2D
    headers: [ AllegroFlare/Placement2D.hpp ]
  - symbol: AllegroFlare::vec2d
    headers: [ AllegroFlare/Vec2D.hpp ]
  - symbol: al_color_name
    headers: [ allegro5/allegro_color.h ]
  - symbol: AllegroFlare::Physics::TileMapCollisionStepper
    headers: [ AllegroFlare/Physics/TileMapCollisionStepper.hpp ]
  - symbol: AllegroFlare::Physics::AABB2D
    headers: [ AllegroFlare/Physics/AABB2D.hpp ]
  - symbol: AllegroFlare::Prototypes::Platforming2D::EntityFlagNames
    headers: [ AllegroFlare/Prototypes/Platforming2D/EntityFlagNames.hpp ]
  - symbol: AllegroFlare::CameraControlStrategies2D::Base
    headers: [ AllegroFlare/CameraControlStrategies2D/Base.hpp ]
  - symbol: AllegroFlare::CameraControlStrategies2D::Snap
    headers: [ AllegroFlare/CameraControlStrategies2D/Snap.hpp ]
  - symbol: AllegroFlare::CameraControlStrategies2D::SmoothSnap
    headers: [ AllegroFlare/CameraControlStrategies2D/SmoothSnap.hpp ]
  - symbol: AllegroFlare::CameraControlStrategies2D::SmoothSnapWithZoomEffect
    headers: [ AllegroFlare/CameraControlStrategies2D/SmoothSnapWithZoomEffect.hpp ]
  - symbol: AllegroFlare::CameraControlStrategies2D::HorizontalRail
    headers: [ AllegroFlare/CameraControlStrategies2D/HorizontalRail.hpp ]
  - symbol: AllegroFlare::Prototypes::Platforming2D::EntityCollectionHelper
    headers: [ AllegroFlare/Prototypes/Platforming2D/EntityCollectionHelper.hpp ]
  - symbol: AllegroFlare::Prototypes::Platforming2D::Entities::TileMaps::Basic2D
    headers: [ AllegroFlare/Prototypes/Platforming2D/Entities/TileMaps/Basic2D.hpp ]
  - symbol: AllegroFlare::Prototypes::Platforming2D::Entities::Doors::Basic2D
    headers: [ AllegroFlare/Prototypes/Platforming2D/Entities/Doors/Basic2D.hpp ]
  - symbol: std::find
    headers: [ algorithm ]
  - symbol: tan
    headers: [ cmath ]
  - symbol: AllegroFlare::TileMaps::PrimMesh
    headers: [ AllegroFlare/TileMaps/PrimMesh.hpp ]
  - symbol: AllegroFlare::TileMaps::TileMap
    headers: [ AllegroFlare/TileMaps/TileMap.hpp ]
  - symbol: ALLEGRO_EVENT
    headers: [ allegro5/allegro.h ]
  - symbol: AllegroFlare::Display
    headers: [ AllegroFlare/Display.hpp ]
  - symbol: AllegroFlare::Prototypes::Platforming2D::Entities::Basic2D
    headers: [ AllegroFlare/Prototypes/Platforming2D/Entities/Basic2D.hpp ]
  - symbol: AllegroFlare::EventEmitter
    headers: [ AllegroFlare/EventEmitter.hpp ]
  - symbol: AllegroFlare::Screens::Base
    headers: [ AllegroFlare/Screens/Base.hpp ]
  - symbol: AllegroFlare::Camera2D
    headers: [ AllegroFlare/Camera2D.hpp ]
  - symbol: ALLEGRO_BITMAP
    headers: [ allegro5/allegro.h ]
  - symbol: AllegroFlare::Vec2D
    headers: [ AllegroFlare/Vec2D.hpp ]
  - symbol: AllegroFlare::Player
    headers: [ AllegroFlare/Player.hpp ]
  - symbol: AllegroFlare::VirtualControllers::Base
    headers: [ AllegroFlare/VirtualControllers/Base.hpp ]
  - symbol: AllegroFlare::VirtualControllers::GenericController
    headers: [ AllegroFlare/VirtualControllers/GenericController.hpp ]
  - symbol: AllegroFlare::Screens::Gameplay
    headers: [ AllegroFlare/Screens/Gameplay.hpp ]


