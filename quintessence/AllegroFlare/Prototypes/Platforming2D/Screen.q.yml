parent_classes:


  - class: AllegroFlare::Screens::Gameplay
    scope: public
# was AllegroFlare::Prototypes::Platforming2D::Screen::TYPE, at the time of this writing Screens/Gameplay does not
# have a proper mechanism to pass down the TYPE of this class
    init_with: ''


properties:


  - name: data_folder_path
    type: std::string
    init_with: DEFAULT_DATA_FOLDER_PATH
    getter: true
    setter: true

  - name: bitmap_bin
    type: AllegroFlare::BitmapBin*
    constructor_arg: true
    init_with: nullptr
    getter: true
    setter: before_initialized

  - name: font_bin
    type: AllegroFlare::FontBin*
    constructor_arg: true
    init_with: nullptr
    getter: true
    setter: before_initialized

  - name: event_emitter
    type: AllegroFlare::EventEmitter*
    init_with: nullptr
    constructor_arg: true
    getter: true
    setter: before_initialized

  - name: tile_atlas_repository
    type: AllegroFlare::TileMaps::TileAtlasRepository
    init_with: ''
    getter_ref: true

  - name: currently_active_map
    type: AllegroFlare::Prototypes::Platforming2D::Entities::TileMaps::Basic2D*
    init_with: nullptr
    getter: true

  - name: currently_active_map_name
    type: std::string
    init_with: '"[currently-active-map-name-unset]"'
    getter: true

  - name: current_boss_zone
    type: AllegroFlare::Prototypes::Platforming2D::Entities::BossZone*
    init_with: nullptr
    getter: true

  - name: in_boss_zone
    type: bool
    init_with: false
    getter: true

  - name: entity_pool
    type: std::vector<AllegroFlare::Prototypes::Platforming2D::Entities::Basic2D*>
    init_with: '{}'
    setter: true
    getter_ref: true

  - name: map_dictionary
    type: std::map<std::string, AllegroFlare::Prototypes::Platforming2D::MapDictionaryListing>
    init_with: '{}'
    getter: true
    setter: explicit

  - name: gravity
    type: float
    init_with: 0.25f
    getter: true
    setter: true

  - name: gravity_reversed
    type: bool
    init_with: false

  - name: camera
    type: AllegroFlare::Camera2D
    init_with: ''
    getter_ref: true

  - name: camera_baseline_zoom
    type: AllegroFlare::Vec2D
    init_with: '{4.8f, 4.5f}'
    getter: true
    setter: true

  - name: player_controlled_entity
    type: AllegroFlare::Prototypes::Platforming2D::Entities::Basic2D*
    init_with: nullptr
    getter: true
    setter: explicit

  - name: last_activated_save_point
    type: AllegroFlare::Prototypes::Platforming2D::Entities::Basic2D*
    init_with: nullptr
    getter: true
    setter: true

  - name: show_tile_mesh
    type: bool
    init_with: true
    getter: true
    setter: true

  - name: show_background_tile_mesh
    type: bool
    init_with: true
    getter: true
    setter: true

  - name: show_collision_tile_mesh
    type: bool
    init_with: false
    getter: true
    setter: true

  - name: show_visual_hint_on_suspended_gameplay
    type: bool
    init_with: false
    getter: true
    setter: true

  - name: entity_control_connector
    type: AllegroFlare::Prototypes::Platforming2D::EntityControlConnectors::Base*
    init_with: nullptr
    getter: true
    setter: true

  - name: collision_stepper
    type: AllegroFlare::Physics::TileMapCollisionStepper
    init_with: '{}'
    getter_ref: true

  - name: camera_control_strategy
    type: AllegroFlare::CameraControlStrategies2D::Base*
    init_with: nullptr
    getter: true
    setter: explicit

  - name: create_entities_from_map_callback
    type: std::function<void(
           std::string,
           float,
           float,
           float,
           float,
           int,
           std::string,
           std::string,
           std::string,
           AllegroFlare::Prototypes::Platforming2D::TMJObjectLoaderObjectCustomProperties, 
           std::vector<AllegroFlare::Prototypes::Platforming2D::Entities::Basic2D*>*,
           AllegroFlare::Prototypes::Platforming2D::Entities::Basic2DFactory*,
           void*)
        >
    init_with: '{}'
    getter: true
    setter: true

  - name: create_entities_from_map_callback_user_data
    type: void*
    init_with: nullptr
    getter: true
    setter: true

  - name: show_debugging_info
    type: bool
    init_with: false
    getter: true
    setter: true

  - name: initialized
    type: bool 
    init_with: false
    getter: true

  - name: maps_loaded
    type: bool 
    init_with: false

  - name: TYPE
    type: char*
    init_with: '(char*)"AllegroFlare/Prototypes/Platforming2D/Screen"'
    static: true
    constexpr: true

  - name: DEFAULT_DATA_FOLDER_PATH
    type: char*
    init_with: '(char*)"[unset-data_folder_path]"'
    static: true
    constexpr: true


documentation:


  - todos:
     - Test the usage of "create_entities_from_map_callback" and "create_entities_from_map_callback_user_data" when
       loading a TMJ file.
     - Attention needs to be brought to "gameplay_suspended" managing (This could be used during a game
       pause, some active dialog, an opened inventory screen, a transition, etc.).  The consequences of a paused state
       remains unevaluated. Some concerns include...
         - some entities may rely on real-world clocks to update their states
         - user controls may become backlogged, need to be cleared or recaptured at unsuspend
         - other things not considered
         - possible re-collisions on unpause
         - audio (pausing in-environment and in-game sound effects)
         - animations should pause, animations could be on real-world clocks
     - Figure out when "last_activated_save_point" should be cleared (on level_load?)


methods:


  - name: clear
    virtual: true
    body: |
      // TODO: Be sure to call AllegroFlare::Prototypes::Platforming2D::Screen::clear in your class's override

      AllegroFlare::Logger::info_from(
         "AllegroFlare::Prototypes::Platforming2D::Screen::clear",
         "Deleting all entities in entity_pool."
      );

      for (auto &entity : entity_pool)
      {
         delete entity;
      }
      entity_pool.clear();

      // Clear our caches
      currently_active_map = nullptr;
      currently_active_map_name = "[unset-currently_active_map_name]";
      if (entity_control_connector) delete entity_control_connector;
      entity_control_connector = nullptr;
      player_controlled_entity = nullptr;
      last_activated_save_point = nullptr;
      current_boss_zone = nullptr;
      in_boss_zone = false;

      // Empty the map dictionary
      map_dictionary.clear();
      maps_loaded = false;

      AllegroFlare::Logger::info_from(
         "AllegroFlare::Prototypes::Platforming2D::Screen::clear",
         "Clear process concluded successfully."
      );

      return;


  - name: set_currently_active_map
    parameters:
      - name: name
        type: std::string
        default_argument: '"[unset-current-map-name-to-use]"'
    body: |
      currently_active_map = find_map_by_name(name);
      if (!currently_active_map) throw std::runtime_error("Bruh, no map");
      currently_active_map_name = name;
      return;


  - name: set_player_controlled_entity
    parameters:
      - name: entity
        type: AllegroFlare::Prototypes::Platforming2D::Entities::Basic2D*
        default_argument: nullptr
      - name: also_set_as_camera_tracked_object
        type: bool
        default_argument: true
      - name: also_setup_a_basic2d_entity_control_connector
        type: bool
        default_argument: true
    guards: [ '(also_set_as_camera_tracked_object ? (bool)camera_control_strategy : true)' ]
    body: |
      // Consider that player_controlled_entity could be nullptr
      // Set the player controlled entity
      this->player_controlled_entity = entity;

      // Set this entity as the entity for the camera to track
      if (also_set_as_camera_tracked_object && camera_control_strategy)
      {
         if (camera_control_strategy->is_type(AllegroFlare::CameraControlStrategies2D::SmoothSnapWithZoomEffect::TYPE))
         {
            auto camera_control_strategy_as = static_cast<
               AllegroFlare::CameraControlStrategies2D::SmoothSnapWithZoomEffect*>(camera_control_strategy);
            camera_control_strategy_as->set_entity_to_follow(player_controlled_entity);
         }
         else if (
               camera_control_strategy->is_type(AllegroFlare::CameraControlStrategies2D::HorizontalRail::TYPE)
            )
         {
            auto camera_control_strategy_as = static_cast<
               AllegroFlare::CameraControlStrategies2D::HorizontalRail*>(camera_control_strategy);
            camera_control_strategy_as->set_entity_to_follow(player_controlled_entity);
         }
         else
         {
            AllegroFlare::Logger::throw_error(
               "AllegroFlare::Prototypes::Platforming2D::Screen::set_player_controlled_entity",
               "Cannot set_entity_to_follow on unhandled camera type \"" + camera_control_strategy->get_type() + "\""
            );
         }
      }

      // Setup a control connector (for now, using a Basic2D connector)
      if (also_setup_a_basic2d_entity_control_connector)
      {
         if (entity_control_connector) delete entity_control_connector;
         auto control_connector = new AllegroFlare::Prototypes::Platforming2D::EntityControlConnectors::Basic2D();
         control_connector->set_basic_2d_entity(entity);

         entity_control_connector = control_connector;
      }
      return;
    body_dependency_symbols:
      - AllegroFlare::Prototypes::Platforming2D::EntityControlConnectors::Basic2D


  - name: set_camera_control_strategy
    parameters:
      - name: camera_control_strategy
        type: AllegroFlare::CameraControlStrategies2D::Base*
        default_argument: nullptr
    guards: [ (initialized) ]
    body: |
      // NOTE: Currently, the camera control strategy can only be set after initialization. This is because
      // the initialization will automatically create a camera control strategy to use.  This is just really for
      // convenience to have an automatic camera control strategy. Proabably, there should be
      // a Platforming2DScreenFactory where different stuff can be setup.
      // NOTE: If you are using this function to set a custom camera controller, you should delete any currently
      // present one before calling this function.
      this->camera_control_strategy = camera_control_strategy;
      return;


  - name: find_map_by_name
    type: AllegroFlare::Prototypes::Platforming2D::Entities::TileMaps::Basic2D*
    parameters:
      - name: name
        type: std::string
        default_argument: '"[unset-map-name]"'
    guards: [ maps_loaded ]
    body: |
      AllegroFlare::Prototypes::Platforming2D::EntityCollectionHelper collection_helper(&entity_pool);
      AllegroFlare::Prototypes::Platforming2D::Entities::TileMaps::Basic2D* found_map =
         collection_helper.find_map_by_name(name);
      if (!found_map)
      {
         std::stringstream error_message;
         error_message << "map named \"" << name << "\" does not exist.";
         throw std::runtime_error(error_message.str());

      }

      return found_map;


  - name: on_activate
    virtual: true
    override: true
    guards: [ initialized ]
    body: |
      // nothing here
      return;


  - name: on_deactivate
    virtual: true
    override: true
    guards: [ initialized ]
    body: |
      // nothing here
      return;


  - name: set_map_dictionary
    parameters:
      - name: map_dictionary
        type: std::map<std::string, AllegroFlare::Prototypes::Platforming2D::MapDictionaryListing>
        default_argument: '{}'
    body: |
      this->map_dictionary = map_dictionary;
      maps_loaded = false;
      // TODO: The maps need to be loaded
      return;


  - name: load_maps_in_dictionary
    note__name_was_previously: initialize_maps
    guards: [ (!maps_loaded), (!map_dictionary.empty()) ]
    body: |
      AllegroFlare::Prototypes::Platforming2D::Entities::Basic2DFactory factory;
      factory.set_bitmap_bin(bitmap_bin);
      factory.set_tile_atlas_repository(&tile_atlas_repository);

      // TODO: Unload the current map if any
      // TODO: Consider clearing the entity pool
      // TODO: Consider tile "room_size" may be altered for the camera. Check out "initialize_camera" to see how
      // tile_width and tile_height are used to calculate the room size.

      for (auto &map_dictionary_entry : map_dictionary)
      {
         std::string map_name = std::get<0>(map_dictionary_entry);
         //std::string map_filename = std::get<1>(map_dictionary_entry);
         AllegroFlare::Prototypes::Platforming2D::MapDictionaryListing map_dictionary_listing = 
         //std::string map_filename =
            std::get<1>(map_dictionary_entry);

         std::string map_filename = map_dictionary_listing.get_tmj_filename();
         std::string map_tile_atlas_bitmap_identifier = map_dictionary_listing.get_tile_atlas_bitmap_identifier();
         //std::string map_tile_atlas_bitmap_identifier = std::get<1>(map_dictionary_entry);

         std::cout << "Loading map named \"" << map_name << "\" from file \"" << map_filename << "\"." << std::endl;

         // Create the tile map, add it to the entity pool
         AllegroFlare::Prototypes::Platforming2D::Entities::TileMaps::Basic2D *created_map =
            factory.create_tile_map(
               map_name,
               map_filename,
               map_tile_atlas_bitmap_identifier
            );
         entity_pool.push_back(created_map);

         // Parse the tmj file and load entities
         std::vector<AllegroFlare::Prototypes::Platforming2D::Entities::Basic2D*> map_loaded_entity_pool =
            factory.create_entities_from_map(
               map_filename,
               map_name,
               create_entities_from_map_callback,
               create_entities_from_map_callback_user_data
            );

         // Add the map-loaded entities to the entity_pool
         entity_pool.insert(entity_pool.end(), map_loaded_entity_pool.begin(), map_loaded_entity_pool.end());
      }

      // Post-process the map
      post_process_loaded_maps();

      // Validate linked doors
      //AllegroFlare::Prototypes::Platforming2D::EntityCollectionHelper collection_helper(&entity_pool);
      //for (auto &primary_door : collection_helper.select_doors())
      //{
         //int other_door = primary_door->exists(;
         //for (auto &primary_main : collection_helper.select_doors())
         //{
         //}
      //}

      maps_loaded = true;

      return;


  - name: post_process_loaded_maps
    virtual: true
    parameters:
      - name: entity_pool
        type: std::vector<AllegroFlare::Prototypes::Platforming2D::Entities::Basic2D*>*
        default_argument: nullptr
    body: |
      // TODO: Add a default behavior here in this method

      //AllegroFlare::Prototypes::Platforming2D::EntityCollectionHelper collection_helper(&entity_pool);
      //for (auto &primary_door : collection_helper.select_doors())
      //{
         //int other_door = primary_door->exists(;
         //for (auto &primary_main : collection_helper.select_doors())
         //{
         //}
      //}
      return;


  - name: initialize_camera_control
    type: void
    body: |
      float assumed_tile_width = 16.0f;
      float assumed_tile_height = 16.0f;
      float room_width = assumed_tile_width * 25; // tile_mesh->get_real_width();
      float room_height = assumed_tile_height * 15; //tile_mesh->get_real_height();

      //AllegroFlare::CameraControlStrategies2D::SmoothSnapWithZoomEffect *camera_control =
         //new AllegroFlare::CameraControlStrategies2D::SmoothSnapWithZoomEffect(room_width, room_height);
      AllegroFlare::CameraControlStrategies2D::HorizontalRail *camera_control =
         new AllegroFlare::CameraControlStrategies2D::HorizontalRail; //(room_width, room_height);
      camera_control->set_camera(&camera);
      //camera_control->set_entity_to_follow(player_controlled_entity);
      camera_control->initialize();

      camera_control_strategy = camera_control;
      return;
    body_dependency_symbols:
      - AllegroFlare::CameraControlStrategies2D::Snap
      - AllegroFlare::CameraControlStrategies2D::SmoothSnap
      - AllegroFlare::CameraControlStrategies2D::SmoothSnapWithZoomEffect
      - AllegroFlare::CameraControlStrategies2D::HorizontalRail


  - name: initialize_camera
    private: true
    body: |
      //camera.size = { 1920.0f, 1080.0f };
      camera.size = AllegroFlare::vec2d(1920.0f, 1080.0f);
      camera.align = AllegroFlare::vec2d(0.5, 0.5);
 
      //float width = tile_mesh->get_real_width();
      //float height = tile_mesh->get_real_height();

      int tile_width = 16; // TODO: Note that this tile_width could change based on the map, for now, we're going
                           // to set a standard of 16x16 as the tile size. Note that this might need to be changed
                           // when the currently_active_map is changed
      int tile_height = 16; // TODO: Note that this tile_width could change based on the map, for now, we're going
                           // to set a standard of 16x16 as the tile size. Note that this might need to be changed
                           // when the currently_active_map is changed

      //float room_width = currently_active_map->get_tile_mesh()->get_tile_width() * 25; // tile_mesh->get_real_width();
      //float room_height = currently_active_map->get_tile_mesh()->get_tile_height() * 15; //tile_mesh->get_real_height();

      float room_width = tile_width * 25;
      float room_height = tile_height * 15;

      // note that Shovel Knight has 4.5x4.5 sized pixels (actually 4.8 x 4.5)
         // this means:
         //     - a virtual resolution of 400x240
         //     = a native display resolution of 1920x1080 (HD)
         //     - 25 tiles x 15 tiles to fill the virtual resolution
         //     - 16x16 pixel tiles
         // see https://www.yachtclubgames.com/blog/breaking-the-nes

      camera.set_zoom(camera_baseline_zoom);
      //AllegroFlare::vec2d(1.0 / 4.8, 1.0 / 4.5);
      camera.position = {room_width/2, room_height/2};

      return;


  - name: initialize
    virtual: true
    type: void
    guards:
      - bitmap_bin
      - (data_folder_path != DEFAULT_DATA_FOLDER_PATH)
    body: |
      set_update_strategy(AllegroFlare::Screens::Base::UpdateStrategy::SEPARATE_UPDATE_AND_RENDER_FUNCS);
      initialize_camera_control();
      initialize_camera();

      // Initialize the collision stepper
      collision_stepper.set_tile_width(16.0f);
      collision_stepper.set_tile_height(16.0f);
      collision_stepper.set_reposition_offset(
            AllegroFlare::Physics::TileMapCollisionStepper::DEFAULT_REPOSITION_OFFSET
         );

      // Setup the tile_atlas_repository
      tile_atlas_repository.set_data_path(data_folder_path);
      tile_atlas_repository.initialize();

      initialized = true;
      return;


  - name: add_entity_to_pool
    type: void
    parameters:
      - name: entity
        type: AllegroFlare::Prototypes::Platforming2D::Entities::Basic2D*
        default_argument: nullptr
    body: |
      entity_pool.push_back(entity);
      return;


  - name: player_emit_projectile
    parameters:
      - name: magnitude
        type: float
        default_argument: 3.0f
    guards: [ player_controlled_entity ]
    body: |
      using namespace AllegroFlare::Prototypes::Platforming2D::EntityFlagNames;

      AllegroFlare::vec2d player_pos = player_controlled_entity->get_place_ref().position;
      //AllegroFlare::vec2d player_center_pos = player_pos;
      //AllegroFlare::vec2d aim_dir = player_controls.get_primary_stick_position(); //.normalized();
      AllegroFlare::vec2d aim_pos = { 1.0, 0.0 }; //player_controls.get_primary_stick_position(); //.normalized();
      //AllegroFlare::vec2d aim_pos = { 1.0, 0.0 }; //player_controls.get_primary_stick_position(); //.normalized();

      if ((aim_pos.x < 0.00001) && (aim_pos.x > -0.00001))
      if ((aim_pos.y < 0.00001) && (aim_pos.y > -0.00001))
      {
         aim_pos = {1, 0};
      }


      std::string on_map_name = player_controlled_entity->get(ON_MAP_NAME);


      AllegroFlare::Prototypes::Platforming2D::Entities::Basic2DFactory factory(bitmap_bin);
      factory.set_init_entities_drawing_debug(true);
      AllegroFlare::Prototypes::Platforming2D::Entities::Basic2D* projectile = factory.create_player_projectile(
         on_map_name,
         player_pos.x,
         player_pos.y,
         8-1,
         8-1,
         aim_pos,
         magnitude
      );
      entity_pool.push_back(projectile);


      return;
    body_dependency_symbols:
      - AllegroFlare::Prototypes::Platforming2D::Entities::Basic2DFactory
      - AllegroFlare::Prototypes::Platforming2D::EntityFlagNames


  - name: reverse_gravity
    body: gravity_reversed = !gravity_reversed;


  - name: on_entity_environment_collision_step
    virtual: true
    parameters:
      - name: entity
        type: AllegroFlare::Prototypes::Platforming2D::Entities::Basic2D*
        default_argument: nullptr
      - name: collision_step_results
        type: std::vector<AllegroFlare::Physics::TileMapCollisionStepperCollisionInfo>*
        default_argument: nullptr
    guards: [ entity, collision_step_results ]
    body: |
      return;
    body_dependency_symbols:
      - AllegroFlare::Physics::TileMapCollisionStepperCollisionInfo


  - name: update_entities
    guards: [ initialized, currently_active_map ]
    body: |
      using namespace AllegroFlare::Prototypes::Platforming2D::EntityFlagNames;

      // Apply gravity
      for (auto &entity : get_current_map_entities())
      {
         if (entity->exists(NOT_AFFECTED_BY_GRAVITY)) continue;
         AllegroFlare::Placement2D &velocity = entity->get_velocity_ref();
         velocity.position.y += (gravity_reversed ? -gravity : gravity);
      }

      // Update the player_controlled_entity first and in isolation.
      if (player_controlled_entity) player_controlled_entity->update();

      // Update the entities (typically includes movement strategies, velocity updates based on state, etc)
      // NOTE: This stage does not include the player_controlled_character, which is udpated before the rest
      // of the entities
      for (auto &entity : get_current_map_entities())
      {
         if (entity == player_controlled_entity) continue;

         // If the entity is tracking the player_controlled_entity, update the tracking position on the entity.
         if (entity->exists(TRACKS_PLAYER_CHARACTER_XY))
         {
            if (!player_controlled_entity) // There is no player_controlled_entity to track
            {
               entity->remove("player_character_x");
               entity->remove("player_character_y");
               AllegroFlare::Logger::warn_from_once(
                  "AllegroFlare::Prototypes::Platforming2D::Screen::update_entities",
                  "Entity is tagged with TRACKS_PLAYER_CHARACTER_XY tag, but on refreshing the value, there is no "
                     "player_controlled_entity"
               );
            }
            else
            {
               entity->set("player_character_x", player_controlled_entity->get_place_ref().position.x);
               entity->set("player_character_y", player_controlled_entity->get_place_ref().position.y);
            }
         }
         entity->update();
      }

      // Update the entities against the collision tile mesh by doing collision stepping one-by-one on each entity
      AllegroFlare::Vec2D previous_place_position;
      AllegroFlare::Vec2D previous_velocity_position;
      AllegroFlare::Vec2D now_place_position;
      AllegroFlare::Vec2D now_velocity_position;

      // Set the collision stepper to use the "currently_active_map"
      collision_stepper.set_collision_tile_map(currently_active_map->get_collision_tile_mesh());

      // Loop through each entity that is in the current map
      for (auto &entity : get_current_map_entities())
      {
         //
         // Calculate the consequential collision values in this step
         //

         AllegroFlare::Placement2D &place = entity->get_place_ref();
         AllegroFlare::Placement2D &velocity = entity->get_velocity_ref();

         // Handle the case where entity does not interact with world tile mesh
         // TODO: Consider scenario where does not collide, but entity still receives info about block collisions
         if (entity->exists(DOES_NOT_COLLIDE_WITH_WORLD))
         {
            place.position.x += velocity.position.x;
            place.position.y += velocity.position.y;
            continue;
         }

         // Store the before-collision info
         previous_place_position = place.position;
         previous_velocity_position = velocity.position;

         // Create a "simulated aabb2d" of the entity and run it through the collision stepper
         float tile_width = 16.0f;
         float tile_height = 16.0f;

         AllegroFlare::Physics::AABB2D aabb2d(
            place.position.x - place.size.x * place.align.x,
            place.position.y - place.size.y * place.align.y,
            place.size.x,
            place.size.y,
            velocity.position.x,
            velocity.position.y
         );

         // Use the aabb2d for this entity
         collision_stepper.set_aabb2d(&aabb2d);

         // Perform the collision step and return the collision info
         std::vector<AllegroFlare::Physics::TileMapCollisionStepperCollisionInfo> collision_step_results =
            collision_stepper.step();

         // Collect inferences about ajacency to walls
         bool is_currently_adjacent_to_floor = collision_stepper.adjacent_to_bottom_edge(tile_width, tile_height);
         bool is_currently_adjacent_to_ceiling = collision_stepper.adjacent_to_top_edge(tile_width, tile_height);
         bool is_currently_adjacent_to_left_wall = collision_stepper.adjacent_to_left_edge(tile_width, tile_height);
         bool is_currently_adjacent_to_right_wall = collision_stepper.adjacent_to_right_edge(tile_width, tile_height);

         // Build the result positioning info related to this collision
         now_place_position.x = aabb2d.get_x() + place.size.x * place.align.x;
         now_place_position.y = aabb2d.get_y() + place.size.y * place.align.y;
         now_velocity_position.x = aabb2d.get_velocity_x();
         now_velocity_position.y = aabb2d.get_velocity_y();

         //
         // Assign the result calculations to the entity
         //

         // Set our actual entity's position and velocity values to the ones used by the "simulated aabb2d"
         place.position = now_place_position;
         velocity.position = now_velocity_position;

         // Call the collision update function on the entity
         entity->on_collision_update(
            previous_place_position,
            previous_velocity_position,
            now_place_position,
            now_velocity_position,
            &collision_step_results,
            is_currently_adjacent_to_ceiling, // TODO: Confirm these
            is_currently_adjacent_to_right_wall, // TODO: Confirm these
            is_currently_adjacent_to_floor,
            is_currently_adjacent_to_left_wall // TODO: Confirm these
         );

         // Call the screens' collision callback function on the entity
         // TODO: Consider performance implications of this callback (is it excessive, should it be called only on
         // entities that are flagged for this callback?)
         // TODO: Consider adding more arguments to this callback
         on_entity_environment_collision_step(
            entity,
            &collision_step_results
         );

         // debugging:
         bool cout_collision_debugging = false;
         if (cout_collision_debugging)
         {
            for (auto &collision_step_result : collision_step_results)
            {
               if (
                     collision_step_result.get_stopped_by_this_collision()
                     && collision_step_result.collided_block_edge_is_left_edge()
                  )
               {
                  std::string ORG = "\033[1;33m";
                  std::string NEU = "\033[0m";

                  if (now_place_position.x == previous_place_position.x)
                  {
                     ORG = "";
                     NEU = "";
                  }
 
                  std::cout.precision(std::numeric_limits<float>::max_digits10);
                  //std::cout.std::showpoint

                  std::cout << "collided against: ["
                            << std::fixed << std::showpoint
                            << collision_step_result.get_collided_tile_coordinate().get_x() << ", "
                            << collision_step_result.get_collided_tile_coordinate().get_y() << "]" << std::endl
                            << "  - result (position_before): " << ORG << "[" << previous_place_position.x << ", "
                                                                 << previous_place_position.y << "]" << NEU << std::endl
                            << "            (position_after): " << ORG << "[" << now_place_position.x << ", "
                                                                 << now_place_position.y << "]" << NEU << std::endl
                            << "           (velocity_before): [" << previous_velocity_position.x << ", "
                                                                 << previous_velocity_position.y << "]" << std::endl
                            << "            (velocity_after): [" << now_velocity_position.x << ", "
                                                                 << now_velocity_position.y << "]" << std::endl
                            << std::endl << std::flush;
               }
            }
         }
      }

      // Evaluate entity collisions. This applies for player and non-player.
      update_entity_collisions_with_damage_zones();

      // Evaluate player collisions on collectables
      // TODO: allow this function to run without being coupled with a "player_controlled_entity"
      if (player_controlled_entity) update_player_collisions_with_collectables();

      // Evaluate player collisions on the goalposts
      // TODO: allow this function to run without being coupled with a "player_controlled_entity"
      if (player_controlled_entity) update_player_collisions_with_goalposts();

      // Evaluate player collisions on save_points
      // TODO: allow this function to run without being coupled with a "player_controlled_entity"
      if (player_controlled_entity) update_player_collisions_with_save_points();

      // Evaluate player collisions on boss_zones
      // TODO: allow this function to run without being coupled with a "player_controlled_entity"
      if (player_controlled_entity) update_player_collisions_with_boss_zones();

      // Evaluate player collisions on entities tagged with COLLIDES_WITH_PLAYER
      // TODO: allow this function to run without being coupled with a "player_controlled_entity"
      if (player_controlled_entity) update_player_collisions_with_COLLIDES_WITH_PLAYER();

      // Evaluate damage zones on player
      //if (player_controlled_entity) update_player_collisions_with_damage_zones();

      // Delete entities flagged to be deleted
      cleanup_entities_flagged_for_deletion();

      // Update the camera
      if (!camera_control_strategy && player_controlled_entity)
      {
         camera.position.x = player_controlled_entity->x;
         camera.position.y = player_controlled_entity->y;
      }
      if (camera_control_strategy) camera_control_strategy->update();

      // Check for player death
      if (player_controlled_entity) check_and_respond_if_player_death();

      return;
    body_dependency_symbols:
      - AllegroFlare::Prototypes::Platforming2D::EntityFlagNames
      - AllegroFlare::Physics::AABB2D
      - AllegroFlare::Physics::TileMapCollisionStepper
      - AllegroFlare::Prototypes::Platforming2D::EntityCollectionHelper
      - std::numeric_limits
      - std::fixed


  - name: check_and_respond_if_player_death
    guards: [ player_controlled_entity ]
    body: |
      using namespace AllegroFlare::Prototypes::Platforming2D::EntityFlagNames;

      if (player_controlled_entity->exists(AllegroFlare::Prototypes::Platforming2D::EntityFlagNames::DEAD))
      {
         event_emitter->emit_game_event(AllegroFlare::GameEvent("player_has_died"));
      }

      return;


  - name: cleanup_entities_flagged_for_deletion
    private: true
    body: |
      using namespace AllegroFlare::Prototypes::Platforming2D::EntityFlagNames;

      for (int i=0; i<entity_pool.size(); i++)
      {
         if (entity_pool[i]->exists(PLEASE_DELETE))
         {
            std::cout << "NOTICE: deleting entity." << std::endl;
            delete entity_pool[i];
            entity_pool.erase(entity_pool.begin() + i);
            i--;
         }
      }
      return;
    body_dependency_symbols:
      - AllegroFlare::Prototypes::Platforming2D::EntityFlagNames


  - name: position_entity_bottom_most_edge
    static: true
    parameters:
      - name: entity
        type: AllegroFlare::Prototypes::Platforming2D::Entities::Basic2D*
        default_argument: nullptr
      - name: map_name
        type: std::string
        default_argument: '"[unset-map_name]"'
      - name: x
        type: float
        default_argument: 0.0f
      - name: y
        type: float
        default_argument: 0.0f
      - name: y_offset
        type: float
        default_argument: 0.01f
    guards: [ entity ]
    body: |
      // TODO: Test this
      using namespace AllegroFlare::Prototypes::Platforming2D::EntityFlagNames;

      entity->set(ON_MAP_NAME, map_name);
      entity->x = x;
      entity->get_place_ref().set_bottommost_coordinate(y-y_offset);
      return;
    body_dependency_symbols:
      - AllegroFlare::Prototypes::Platforming2D::EntityFlagNames


  - name: on_enter_door
    virtual: true
    parameters:
      - name: door
        type: AllegroFlare::Prototypes::Platforming2D::Entities::Doors::Basic2D*
        default_argument: nullptr
    guards: [ door, player_controlled_entity ]
    body: |
      if (door->get_is_locked())
      {
         // TODO: Consider emitting an event, message, or sounde effect to indicate the door is locked
         std::cout << "AllegroFlare::Prototypes::Platforming2D::Screen::on_enter_door: "
                   "info: door is locked." << std::endl;
      }
      else
      {
         reposition_player_controlled_entity_to_door_destination(door);
      }
      return;


  - name: reposition_player_controlled_entity_to_door_destination
    parameters:
      - name: door
        type: AllegroFlare::Prototypes::Platforming2D::Entities::Doors::Basic2D*
        default_argument: nullptr
    guards: [ door, player_controlled_entity ]
    body: |
      std::string map_target_name = door->get_target_map_name();
      float target_spawn_x = door->get_target_spawn_x();
      float target_spawn_y = door->get_target_spawn_y();

      // find the target map
      // TODO: Is this step necessary?
      AllegroFlare::Prototypes::Platforming2D::Entities::TileMaps::Basic2D* target_map =
         find_map_by_name(map_target_name);

      // reposition player in map
      position_entity_bottom_most_edge(
            player_controlled_entity,
            map_target_name,
            target_spawn_x,
            target_spawn_y
         );

      // set current map
      set_currently_active_map(map_target_name);
      return;


  - name: check_player_collisions_with_doors
    private: true
    guards: [ player_controlled_entity, event_emitter ]
    body: |
      using namespace AllegroFlare::Prototypes::Platforming2D::EntityFlagNames;

      std::vector<AllegroFlare::Prototypes::Platforming2D::Entities::Basic2D*> _entities = get_current_map_entities();
      AllegroFlare::Prototypes::Platforming2D::EntityCollectionHelper collection_helper(&_entities);
      AllegroFlare::Placement2D &player_placement = player_controlled_entity->get_place_ref();

      //float player_x = player_controlled_entity->get_place_ref().position.x;
      //float player_y = player_controlled_entity->get_place_ref().position.y + 16;

      for (auto &entity : collection_helper.select_doors())
      {
         if (entity->get_place_ref().collide(player_placement)) //player_x, player_y, 4, 4, 4, 4))
         {
            AllegroFlare::Prototypes::Platforming2D::Entities::Doors::Basic2D *door =
               static_cast<AllegroFlare::Prototypes::Platforming2D::Entities::Doors::Basic2D*>(entity);

            if (door->get_is_locked())
            {
               // Cannot open this door, it's locked
               // Call the callback
               on_enter_door(door);
            }
            else
            {
               // TODO: Consider removing an emitted event as a door option. This should be included in the callback
               // if anything
               std::string game_event_name_to_emit = door->get_game_event_name_to_emit();
               bool this_door_emits_game_event = !game_event_name_to_emit.empty();
               if (this_door_emits_game_event)
               {
                  event_emitter->emit_game_event(AllegroFlare::GameEvent(game_event_name_to_emit));
               }
               else
               {
                  // Will door travel to another map
                  on_enter_door(door);
               }
            }
            
            return;
         }
      }
      return;
    body_dependency_symbols:
      - AllegroFlare::Prototypes::Platforming2D::EntityFlagNames
      - AllegroFlare::Prototypes::Platforming2D::EntityCollectionHelper
      - AllegroFlare::Prototypes::Platforming2D::Entities::Doors::Basic2D
      - std::find


  - name: on_player_controlled_entity_collision_with_entity
    private: true
    virtual: true
    parameters:
      - name: player_controlled_entity
        type: AllegroFlare::Prototypes::Platforming2D::Entities::Basic2D*
        default_argument: nullptr
      - name: entity
        type: AllegroFlare::Prototypes::Platforming2D::Entities::Basic2D*
        default_argument: nullptr
    guards: [ player_controlled_entity, entity ]
    body: |
      return;


  - name: on_enter_player_controlled_entity_collision_with_entity
    private: true
    virtual: true
    parameters:
      - name: player_controlled_entity
        type: AllegroFlare::Prototypes::Platforming2D::Entities::Basic2D*
        default_argument: nullptr
      - name: entity
        type: AllegroFlare::Prototypes::Platforming2D::Entities::Basic2D*
        default_argument: nullptr
    guards: [ player_controlled_entity, entity ]
    body: |
      return;


  - name: on_exit_player_controlled_entity_collision_with_entity
    private: true
    virtual: true
    parameters:
      - name: player_controlled_entity
        type: AllegroFlare::Prototypes::Platforming2D::Entities::Basic2D*
        default_argument: nullptr
      - name: entity
        type: AllegroFlare::Prototypes::Platforming2D::Entities::Basic2D*
        default_argument: nullptr
    guards: [ player_controlled_entity, entity ]
    body: |
      return;


  - name: on_hold_player_controlled_entity_collision_with_entity
    private: true
    virtual: true
    parameters:
      - name: player_controlled_entity
        type: AllegroFlare::Prototypes::Platforming2D::Entities::Basic2D*
        default_argument: nullptr
      - name: entity
        type: AllegroFlare::Prototypes::Platforming2D::Entities::Basic2D*
        default_argument: nullptr
      - name: duration
        type: float
        default_argument: 0.0f
    guards: [ player_controlled_entity, entity ]
    body: |
      return;


  - name: on_hold_player_controlled_entity_non_collision_with_entity
    private: true
    virtual: true
    parameters:
      - name: player_controlled_entity
        type: AllegroFlare::Prototypes::Platforming2D::Entities::Basic2D*
        default_argument: nullptr
      - name: entity
        type: AllegroFlare::Prototypes::Platforming2D::Entities::Basic2D*
        default_argument: nullptr
      - name: duration
        type: float
        default_argument: 0.0f
    guards: [ player_controlled_entity, entity ]
    body: |
      return;


  - name: update_player_collisions_with_COLLIDES_WITH_PLAYER
    private: true
    virtual: true
    guards: [ player_controlled_entity ]
    body: |
      using namespace AllegroFlare::Prototypes::Platforming2D::EntityFlagNames;
      std::vector<AllegroFlare::Prototypes::Platforming2D::Entities::Basic2D*> _entities = get_current_map_entities();
      AllegroFlare::Prototypes::Platforming2D::EntityCollectionHelper collection_helper(&_entities);

      float player_x = player_controlled_entity->x;
      float player_y = player_controlled_entity->y;
      AllegroFlare::Placement2D &player_placement = player_controlled_entity->get_place_ref();

      // NOTE: This technique only accounts for *one* player controled entity. If the player controlled entity is
      // swapped with another entity, or, if there are multiple player_controlled_entities, this technique will require
      // review and possibly revision.

      for (auto &entity : collection_helper.select_collides_with_player())
      {
         // TODO: Be alert that multiple collisions could cause multiple callbacks and some potentially undefined
         // result state
         //if (entity->get_place_ref().collide(&pla->get_placement_ref())); //player_x, player_y, 0, 0, 0, 0))
         if (entity->get_place_ref().collide(player_placement)) //player_x, player_y, 0, 0, 0, 0))
         {
            entity->on_collides_with_player(player_controlled_entity);
            on_player_controlled_entity_collision_with_entity(player_controlled_entity, entity);

            if (!entity->exists(CURRENTLY_COLLIDING_WITH_PLAYER))
            {
               // Set colliding with player
               entity->set(CURRENTLY_COLLIDING_WITH_PLAYER, al_get_time());

               // On-enter collision
               entity->on_enter_collision_with_player(player_controlled_entity);
               on_enter_player_controlled_entity_collision_with_entity(player_controlled_entity, entity);
            }
            else
            {
               float duration = al_get_time() - entity->get_as_float(CURRENTLY_COLLIDING_WITH_PLAYER);

               // On-holding collision with player
               entity->on_hold_collision_with_player(player_controlled_entity, duration);
               on_hold_player_controlled_entity_collision_with_entity(player_controlled_entity, entity, duration);
            }
         }
         else // Non-collision
         {
            //entity->on_collides_with_player(player_controlled_entity);
            //on_player_controlled_entity_collision_with_entity(player_controlled_entity, entity);

            if (entity->exists(CURRENTLY_COLLIDING_WITH_PLAYER))
            {
               // Set colliding with player
               entity->remove(CURRENTLY_COLLIDING_WITH_PLAYER); //, al_get_time());

               // On-exit collision
               entity->on_exit_collision_with_player(player_controlled_entity);
               on_exit_player_controlled_entity_collision_with_entity(player_controlled_entity, entity);
            }
            else
            {
               // On-holding non collision with player

               //float duration = al_get_time() - entity->get_as_float(CURRENTLY_COLLIDING_WITH_PLAYER);

               // TODO: Find a way to store non-collision duration, which there currently isn't
               float duration = 0.0f;

               // On-holding non-collision with player
               entity->on_hold_non_collision_with_player(player_controlled_entity, duration);
               on_hold_player_controlled_entity_non_collision_with_entity(player_controlled_entity, entity, duration);
            }
         }
      }

      

      return;
    body_dependency_symbols:
      - AllegroFlare::Prototypes::Platforming2D::EntityFlagNames
      - AllegroFlare::Prototypes::Platforming2D::EntityCollectionHelper


  - name: spawn_player_emitted_damage_zone
    parameters:
      - name: map_name
        type: std::string
        default_argument: '"[unset-map_name]"'
      - name: x
        type: float
        default_argument: 0.0f
      - name: y
        type: float
        default_argument: 0.0f
      - name: width
        type: float
        default_argument: 16.0f
      - name: height
        type: float
        default_argument: 16.0f
    body: |
      AllegroFlare::Prototypes::Platforming2D::Entities::Basic2DFactory factory(bitmap_bin);
      factory.set_init_entities_drawing_debug(true);
      AllegroFlare::Prototypes::Platforming2D::Entities::Basic2D* damage_zone =
            factory.create_player_emitted_damage_zone(
               map_name,
               x, //player_pos.x,
               y, //player_pos.y,
               width, //8-1,
               height //8-1
            );
      entity_pool.push_back(damage_zone);

      //std::string on_map_name = player_controlled_entity->get(ON_MAP_NAME);

      //AllegroFlare::Prototypes::Platforming2D::Entities::Basic2DFactory factory(bitmap_bin);
      //factory.set_init_entities_drawing_debug(true);

      return;


  - name: update_player_collisions_with_collectables
    virtual: true
    private: true
    guards: [ player_controlled_entity ]
    body: |
      // TODO: allow this function to run without being coupled with a "player_controlled_entity"
      using namespace AllegroFlare::Prototypes::Platforming2D::EntityFlagNames;

      std::vector<AllegroFlare::Prototypes::Platforming2D::Entities::Basic2D*> _entities = get_current_map_entities();
      AllegroFlare::Prototypes::Platforming2D::EntityCollectionHelper collection_helper(&_entities);
      AllegroFlare::Placement2D &player_placement = player_controlled_entity->get_place_ref();
         //if (entity->get_place_ref().collide(player_placement))
      //float player_x = player_controlled_entity->get_place_ref().position.x;
      //float player_y = player_controlled_entity->get_place_ref().position.y + 16; // TODO: Replace this with
                                                                                  // player center position

      for (auto &entity : collection_helper.select_collectable_by_player())
      {
         if (entity->get_place_ref().collide(player_placement))
         //if (entity->get_place_ref().collide(player_x, player_y, 4, 4, 4, 4))
         {
            entity->set(PLEASE_DELETE);
            // NOTE: typically will do something here as a result of picking up the item
         }
      }
      return;
    body_dependency_symbols:
      - AllegroFlare::Prototypes::Platforming2D::EntityFlagNames
      - AllegroFlare::Prototypes::Platforming2D::EntityCollectionHelper


  - name: update_entity_collisions_with_damage_zones
    virtual: true
    private: true
    body: |
      // TODO: Consider adding some default behavior for this method. Note that at the time of this writing, a
      // PlayerDamageZone is in JourneyOfTheCat (and is scoped in AllegroFlare). This class should probably be moved
      // into AllegroFlare and handled in an expected way. Also, consider that a damage zone might damage enemies,
      // a player, both, have some kind of black/white list. This method may not be exclusive to PlayerDamageZone

      // NOTE: Previous usage looked like:
      //using namespace AllegroFlare::Prototypes::Platforming2D::EntityFlagNames;

      //std::vector<AllegroFlare::Prototypes::Platforming2D::Entities::Basic2D*> _entities = get_current_map_entities();
      //AllegroFlare::Prototypes::Platforming2D::EntityCollectionHelper collection_helper(&_entities);
      //float player_x = player_controlled_entity->get_place_ref().position.x;
      //float player_y = player_controlled_entity->get_place_ref().position.y + 16; // TODO: Replace this with
                                                                                  // player center position

      //for (auto &entity : collection_helper.select_collectable_by_player())
      //{
         //if (entity->get_place_ref().collide(player_x, player_y, 4, 4, 4, 4))
         //{
            //entity->set(PLEASE_DELETE);
            //// NOTE: typically will do something here as a result of picking up the item
         //}
      //}
      return;


  - name: update_player_collisions_with_save_points
    virtual: true
    private: true
    guards: [ player_controlled_entity ]
    body: |
      // TODO: allow this function to run without being coupled with a "player_controlled_entity"
      using namespace AllegroFlare::Prototypes::Platforming2D::EntityFlagNames;

      std::vector<AllegroFlare::Prototypes::Platforming2D::Entities::Basic2D*> _entities = get_current_map_entities();
      AllegroFlare::Prototypes::Platforming2D::EntityCollectionHelper collection_helper(&_entities);
      AllegroFlare::Placement2D &player_placement = player_controlled_entity->get_place_ref();
         //if (entity->get_place_ref().collide(player_placement))
      //float player_x = player_controlled_entity->get_place_ref().position.x;
      //float player_y = player_controlled_entity->get_place_ref().position.y + 16; // TODO: Replace this with
                                                                                  // player center position
      //AllegroFlare::Placement2D &player_placement = player_controlled_entity->get_place_ref();

      for (auto &entity : collection_helper.select_save_points())
      {
         if (entity->get_place_ref().collide(player_placement))
         //if (entity->get_place_ref().collide(player_x, player_y, 4, 4, 4, 4))
         {
            last_activated_save_point = entity;
            //entity->set(PLEASE_DELETE);
            // NOTE: typically will do something here as a result of picking up the item
         }
      }
      return;
    body_dependency_symbols:
      - AllegroFlare::Prototypes::Platforming2D::EntityFlagNames
      - AllegroFlare::Prototypes::Platforming2D::EntityCollectionHelper


  - name: on_enter_boss_zone
    virtual: true
    parameters:
      - name: boss_zone
        type: AllegroFlare::Prototypes::Platforming2D::Entities::BossZone*
        default_argument: nullptr
    body: |
      return;


  - name: on_exit_boss_zone
    virtual: true
    parameters:
      - name: boss_zone
        type: AllegroFlare::Prototypes::Platforming2D::Entities::BossZone*
        default_argument: nullptr
    body: |
      return;


  - name: update_player_collisions_with_boss_zones
    virtual: true
    private: true
    guards: [ player_controlled_entity ]
    body: |
      // TODO: allow this function to run without being coupled with a "player_controlled_entity"
      using namespace AllegroFlare::Prototypes::Platforming2D::EntityFlagNames;

      std::vector<AllegroFlare::Prototypes::Platforming2D::Entities::Basic2D*> _entities = get_current_map_entities();
      AllegroFlare::Prototypes::Platforming2D::EntityCollectionHelper collection_helper(&_entities);
      //float player_x = player_controlled_entity->get_place_ref().position.x;
      //float player_y = player_controlled_entity->get_place_ref().position.y; // TODO: Replace this with
                                                                             // player center position

      AllegroFlare::Placement2D &player_placement = player_controlled_entity->get_place_ref();
      //for (auto &entity : collection_helper.select_boss_zones())
      //{
         // TODO: Determine what a good default action would be here, consider "entering" and "exiting" the zone
         // as well

         //if (entity->get_place_ref().collide(player_x, player_y, 4, 4, 4, 4))
         //{
            //last_activated_save_point = entity;
            // NOTE: typically will do something here as a result of picking up the item
         //}
      //}

      AllegroFlare::Prototypes::Platforming2D::Entities::BossZone* first_collided_boss_zone = nullptr;

      for (auto &entity : collection_helper.select_boss_zones())
      {
         if (entity->get_place_ref().collide(player_placement)) // Consider an alternative to this collision
         //if (entity->get_place_ref().collide(player_x, player_y)) // Consider an alternative to this collision
         {
            first_collided_boss_zone =
                  static_cast<AllegroFlare::Prototypes::Platforming2D::Entities::BossZone*>(entity);
            break;
         }
      }

      if (first_collided_boss_zone != current_boss_zone) // There was a change to the boss_zone
      {
         // TODO: Consider *exiting* current_boss_zone (if it is not a nullptr)

         if (current_boss_zone != nullptr) on_exit_boss_zone(current_boss_zone);
         current_boss_zone = first_collided_boss_zone;

         if (current_boss_zone == nullptr)
         {
            in_boss_zone = false;
            //on_enter_boss_zone();
            // Exited a boss mode
         }
         else // (current_boss_zone != nullptr)
         {
            on_enter_boss_zone(current_boss_zone);
            in_boss_zone = true;
            // Entered a boss mode
         }
      }


      return;
    body_dependency_symbols:
      - AllegroFlare::Prototypes::Platforming2D::Entities::BossZone
      - AllegroFlare::Prototypes::Platforming2D::EntityFlagNames
      - AllegroFlare::Prototypes::Platforming2D::EntityCollectionHelper


  - name: update_player_collisions_with_goalposts
    virtual: true
    guards: [ player_controlled_entity ]
    body: |
      // TODO: allow this function to run without being coupled with a "player_controlled_entity"
      std::vector<AllegroFlare::Prototypes::Platforming2D::Entities::Basic2D*> _entities = get_current_map_entities();
      AllegroFlare::Prototypes::Platforming2D::EntityCollectionHelper collection_helper(&_entities);

      AllegroFlare::Placement2D &player_placement = player_controlled_entity->get_place_ref();
      // TODO: Change this collision to the player_controlled_entity's center, OR, make it configurable
      //float player_x = player_controlled_entity->get_place_ref().position.x;
      //float player_y = player_controlled_entity->get_place_ref().position.y + 16; // TODO: Replace this with
                                                                                  // player center position

      for (auto &entity : collection_helper.select_goalposts())
      {
         if (entity->get_place_ref().collide(player_placement))
         //if (entity->get_place_ref().collide(player_x, player_y, 8, 8, 8, 8))
         {
            // TODO: Consider what default behavior would be good here
         }
      }
      return;
    body_dependency_symbols:
      - AllegroFlare::Prototypes::Platforming2D::EntityCollectionHelper


  - name: draw_entities_sorted_by_render_order
    body: |
      using namespace AllegroFlare::Prototypes::Platforming2D::EntityFlagNames;

      //std::vector<AllegroFlare::Prototypes::Platforming2D::Entities::Basic2D*> _entities = get_current_map_entities();

      // Build list sorted by render order
      std::multimap<std::pair<int, float>, AllegroFlare::Prototypes::Platforming2D::Entities::Basic2D*>
         entities_in_render_order;

      for (auto &entity : get_current_map_entities())
      {
         if (entity->exists(INVISIBLE)) continue;

         std::pair<int, float> key = std::make_pair(entity->get_render_order_group(), entity->get_render_order_z());
         entities_in_render_order.insert(std::make_pair(key, entity));
      }

      // Draw the entities in render order
      for (auto &entity : entities_in_render_order) entity.second->draw();

      return;
    body_dependency_symbols:
      - AllegroFlare::Prototypes::Platforming2D::EntityFlagNames


  - name: update
    virtual: true
    guards: [ initialized ]
    body: |
      if (!get_gameplay_suspended())
      {
         //if (player_controlled_entity)
         //{
            //update_player_controls_on_player_controlled_entity();
         //}
         if (player_controlled_entity && entity_control_connector)
         {
            entity_control_connector->update_player_controls_on_player_controlled_entity();
         }
         update_entities();
      }
      return;


  - name: draw_hud
    virtual: true
    body: |
      return;
 

  - name: draw
    guards: [ initialized, currently_active_map, get_tile_mesh() ]
    body: |
      //ALLEGRO_STATE previous_target_bitmap;

      ALLEGRO_BITMAP *target_bitmap = al_get_target_bitmap();
      camera.setup_dimensional_projection(target_bitmap);

      //ALLEGRO_STATE previous_target_bitmap;
      //al_store_state(&previous_target_bitmap, ALLEGRO_STATE_TARGET_BITMAP);
      //al_set_target_bitmap(target_bitmap);
      camera.start_reverse_transform();
      //camera.start_transform();

      al_set_render_state(ALLEGRO_DEPTH_FUNCTION, ALLEGRO_RENDER_LESS_EQUAL); // less or equal allows 
                                                                              // subsequent renders at the same
                                                                              // z-level to overwrite. This 
                                                                              // mimics the rendering of typical
                                                                              // "traditional" drawing functions
      // TODO: Figure out how to include tile mesh with entities, including "draw_order_z" and "draw_order_group"
      if (show_background_tile_mesh && background_tile_mesh_exists())
      {
         get_background_tile_mesh()->render();
      }
      if (show_tile_mesh)
      {
         get_tile_mesh()->render();
      }
      draw_entities_sorted_by_render_order();
      if (show_collision_tile_mesh) render_collision_tile_mesh();

      camera.restore_transform();

      // Indicate a hint on suspended gameplay
      if (get_gameplay_suspended() && show_visual_hint_on_suspended_gameplay)
      {
         float surface_width = al_get_bitmap_width(target_bitmap);
         float surface_height = al_get_bitmap_height(target_bitmap); //native_display_resolution_height;
         al_draw_filled_rectangle(100, 100, surface_width-100, surface_height-100, ALLEGRO_COLOR{0.0, 0.0, 0.0, 0.2});
      }

      //al_restore_state(&previous_target_bitmap);
      
      return;
    body_dependency_symbols:
      - al_color_name


  - name: draw_debugging
    body: |
      //bool draw_debugging_info = true;
      if (show_debugging_info)
      {
         ALLEGRO_FONT *font = obtain_debug_font();

         float lh = 40; // "lh" is line height
         float l=0;
         al_draw_textf(font, ALLEGRO_COLOR{1, 1, 1, 1}, 20, 30 + lh*l++, ALLEGRO_ALIGN_LEFT, "physics");
         al_draw_textf(font, ALLEGRO_COLOR{1, 1, 1, 1}, 20, 30 + lh*l++, ALLEGRO_ALIGN_LEFT, "  reposition_offset: %f", 
               collision_stepper.get_reposition_offset()
            );
         al_draw_textf(font, ALLEGRO_COLOR{1, 1, 1, 1}, 20, 30 + lh*l++, ALLEGRO_ALIGN_LEFT, "player_character");
         al_draw_textf(font, ALLEGRO_COLOR{1, 1, 1, 1}, 20, 30 + lh*l++, ALLEGRO_ALIGN_LEFT, "  position_x: %f", 
               player_controlled_entity->get_place_ref().position.x
            );
         al_draw_textf(font, ALLEGRO_COLOR{1, 1, 1, 1}, 20, 30 + lh*l++, ALLEGRO_ALIGN_LEFT, "  position_y: %f", 
               player_controlled_entity->get_place_ref().position.y
            );
         al_draw_textf(font, ALLEGRO_COLOR{1, 1, 1, 1}, 20, 30 + lh*l++, ALLEGRO_ALIGN_LEFT, "  bottom_most_edge: %f", 
               player_controlled_entity->get_place_ref().get_bottommost_coordinate()
            );
         al_draw_textf(font, ALLEGRO_COLOR{1, 1, 1, 1}, 20, 30 + lh*l++, ALLEGRO_ALIGN_LEFT, "  velocity_x: %f", 
               player_controlled_entity->get_velocity_ref().position.x
            );
         al_draw_textf(font, ALLEGRO_COLOR{1, 1, 1, 1}, 20, 30 + lh*l++, ALLEGRO_ALIGN_LEFT, "  velocity_y: %f", 
            player_controlled_entity->get_velocity_ref().position.y
            );
         al_draw_textf(font, ALLEGRO_COLOR{1, 1, 1, 1}, 20, 30 + lh*l++, ALLEGRO_ALIGN_LEFT, "  flags:");
         for (auto &attribute : player_controlled_entity->Attributes::get_copy())
         {
            al_draw_textf(font, ALLEGRO_COLOR{1, 1, 1, 1}, 20, 30 + lh*l++, ALLEGRO_ALIGN_LEFT, "    - %s", 
                  attribute.first.c_str()
               );
         }
      }
      
      return;


  - name: toggle_show_collision_tile_mesh
    body: |
      show_collision_tile_mesh = !show_collision_tile_mesh;
      return;


  - name: toggle_show_tile_mesh
    body: |
      show_tile_mesh = !show_tile_mesh;
      return;


  - name: primary_update_func
    virtual: true
    override: true
    parameters:
      - name: time_now
        type: double
        default_argument: 0.0
      - name: delta_time
        type: double
        default_argument: 0.0
    body: |
      // TODO: Consider if there is a more elegant way to prevent logic from being performed than inferring against
      // currently_active_map. Consider a "unloaded" state or flag possibly.
      // TODO: Test this logic
      if (!currently_active_map)
      {
         AllegroFlare::Logger::warn_from_once(
            "AllegroFlare::Prototypes::Platforming2D::Screen::primary_update_func",
            "There is no currently_active_map. Skipping update methods."
         );
      }
      else
      {
         update();
      }
      return;


  - name: primary_render_func
    virtual: true
    override: true
    body: |
      // TODO: Consider if there is a more elegant way to prevent logic from being performed than inferring against
      // currently_active_map. Consider a "unloaded" state or flag possibly.
      // TODO: Test this logic
      if (!currently_active_map)
      {
         AllegroFlare::Logger::warn_from_once(
            "AllegroFlare::Prototypes::Platforming2D::Screen::primary_render_func",
            "There is no currently_active_map. Skipping drawing methods."
         );
      }
      else
      {
         draw();
         draw_hud();
         draw_debugging();
      }
      return;


  - name: key_char_func
    virtual: true
    override: true
    parameters:
      - name: event
        type: ALLEGRO_EVENT*
        default_argument: nullptr
    guards: [ initialized, event ]
    body: |
      switch (event->keyboard.keycode)
      {
      case ALLEGRO_KEY_1:
         toggle_show_collision_tile_mesh();
         break;
      case ALLEGRO_KEY_2:
         //toggle_show_tile_mesh();
         break;
      case ALLEGRO_KEY_PAD_PLUS:
         camera.set_zoom(camera.get_zoom() + AllegroFlare::Vec2D({0.1, 0.1}));
         break;
      case ALLEGRO_KEY_PAD_MINUS:
         camera.set_zoom(camera.get_zoom() - AllegroFlare::Vec2D({0.1, 0.1}));
         break;
      default:
         break;
      }
      return;


  - name: key_up_func
    virtual: true
    override: true
    parameters:
      - name: event
        type: ALLEGRO_EVENT*
        default_argument: nullptr
    guards: [ initialized, event ]
    body: |
      if (entity_control_connector) entity_control_connector->key_up_func(event);

      switch (event->keyboard.keycode)
      {
         //case ALLEGRO_KEY_LEFT:
            ////player_control_velocity.y = 0.0;
            //player_controls.set_left_button_pressed(false);
         //break;

         //case ALLEGRO_KEY_RIGHT:
            ////player_control_velocity.y = 0.0;
            //player_controls.set_right_button_pressed(false);
         //break;
      }
      return;


  - name: key_down_func
    virtual: true
    override: true
    parameters:
      - name: event
        type: ALLEGRO_EVENT*
        default_argument: nullptr
    guards: [ initialized, event ]
    body: |
      if (!get_gameplay_suspended())
      {
         if (entity_control_connector) entity_control_connector->key_down_func(event);

         switch (event->keyboard.keycode)
         {
            //case ALLEGRO_KEY_LEFT:
               ////player_control_velocity.x = 0.0;
               //player_controls.set_left_button_pressed(true);
            //break;

            //case ALLEGRO_KEY_RIGHT:
               ////player_control_velocity.x = 1.0;
              //player_controls.set_right_button_pressed(true);
            //break;

            case ALLEGRO_KEY_UP:
               //player_control_velocity.y = -1.0;
               //player_controls.set_up_button_pressed(true);
               check_player_collisions_with_doors();
            break;

            case ALLEGRO_KEY_DOWN:
               //player_control_velocity.y = 1.0;
            break;

            case ALLEGRO_KEY_SPACE:
               //set_player_controlled_entity_jump();
            break;

            case ALLEGRO_KEY_X:
               reverse_gravity();
            break;

            case ALLEGRO_KEY_Y:
               player_emit_projectile();
               //reverse_gravity();
            break;
         }
      }

      switch (event->keyboard.keycode) // TODO: Add boolean option to disable this "manual" toggling of pause
      {
         case ALLEGRO_KEY_P:
            toggle_suspend_gameplay();
         break;
      }
      return;


  - name: virtual_control_button_down_func
    virtual: true
    override: true
    parameters:
      - name: player
        type: AllegroFlare::Player*
        default_argument: nullptr
      - name: virtual_controller
        type: AllegroFlare::VirtualControllers::Base*
        default_argument: nullptr
      - name: virtual_controller_button_num
        type: int
        default_argument: 0
      - name: is_repeat
        type: bool
        default_argument: false
    guards: [ initialized ]
    body: |
      //int virtual_controller_button_num = event->user.data1;

      // TODO: validate virtual controller type

      if (!get_gameplay_suspended())
      {
         // TODO: Investigate if there are some inputs that should be "active" at unpause (like staying crouched, 
         // continuing moving forward if paused mid-jump, etc)
         if (virtual_controller_button_num == AllegroFlare::VirtualControllers::GenericController::BUTTON_B)
         {
            //player_controls.set_a_button_pressed(true);
            //set_player_controlled_entity_jump();
         }
         else if (virtual_controller_button_num == AllegroFlare::VirtualControllers::GenericController::BUTTON_X)
         {
            //reverse_gravity();
         }
         else if (virtual_controller_button_num == AllegroFlare::VirtualControllers::GenericController::BUTTON_Y)
         {
            //player_emit_projectile();
         }
         else if (virtual_controller_button_num == AllegroFlare::VirtualControllers::GenericController::BUTTON_RIGHT)
         {
            //player_controls.set_right_button_pressed(true);
         }
         else if (virtual_controller_button_num == AllegroFlare::VirtualControllers::GenericController::BUTTON_LEFT)
         {
            //player_controls.set_left_button_pressed(true);
         }
         else if (virtual_controller_button_num == AllegroFlare::VirtualControllers::GenericController::BUTTON_UP)
         {
            //player_controls.set_up_button_pressed(true);
            //check_player_collisions_with_doors();
         }
         else if (virtual_controller_button_num == AllegroFlare::VirtualControllers::GenericController::BUTTON_RIGHT_BUMPER)
         {
            // TODO: block if gameplay is suspended
            //player_controls.set_right_bumper_pressed(true);
         }
      }
      return;
    body_dependency_symbols:
      - AllegroFlare::VirtualControllers::GenericController


  - name: virtual_control_button_up_func
    virtual: true
    override: true
    parameters:
      - name: player
        type: AllegroFlare::Player*
        default_argument: nullptr
      - name: virtual_controller
        type: AllegroFlare::VirtualControllers::Base*
        default_argument: nullptr
      - name: virtual_controller_button_num
        type: int
        default_argument: 0
      - name: is_repeat
        type: bool
        default_argument: false
    guards: [ initialized ]
    body: |
      //int virtual_controller_button_num = event->user.data1;

      // TODO: validate virtual controller type

      if (!get_gameplay_suspended())
      {
         // TODO: Investigate if there are some inputs that should be "active" at unpause (like staying crouched, 
         // continuing moving forward if paused mid-jump, etc)
         if (virtual_controller_button_num == AllegroFlare::VirtualControllers::GenericController::BUTTON_B)
         {
            //player_controls.set_a_button_pressed(false);
         }
         else if (virtual_controller_button_num == AllegroFlare::VirtualControllers::GenericController::BUTTON_RIGHT)
         {
            //player_controls.set_right_button_pressed(false);
         }
         else if (virtual_controller_button_num == AllegroFlare::VirtualControllers::GenericController::BUTTON_LEFT)
         {
            //player_controls.set_left_button_pressed(false);
         }
         else if (virtual_controller_button_num == AllegroFlare::VirtualControllers::GenericController::BUTTON_RIGHT_BUMPER)
         {
            //player_controls.set_right_bumper_pressed(false);
         }
      }
      return;
    body_dependency_symbols:
      - AllegroFlare::VirtualControllers::GenericController


  - name: virtual_control_axis_change_func
    virtual: true
    override: true
    parameters:
      - name: event
        type: ALLEGRO_EVENT*
        default_argument: nullptr
    body: |
      //int stick = event->user.data1;
      //int axis = event->user.data2;
      //float position = event->user.data3 / 255.0f;

      //if (stick == AllegroFlare::VirtualControllers::GenericController::PRIMARY_STICK)
      //{
         //if (axis == 0)
         //{
            //AllegroFlare::vec2d vec = player_controls.get_primary_stick_position();
            //vec.x = position;
            //player_controls.set_primary_stick_position(vec);
         //}
         //if (axis == 1)
         //{
            //AllegroFlare::vec2d vec = player_controls.get_primary_stick_position();
            //vec.y = position;
            //player_controls.set_primary_stick_position(vec);
         //}
      //}

      //if (axis == 0 && position > 0.5) player_controls.set_right_button_pressed(true);
      //if (axis == 0 && position < 0.5 && position > -0.5)
      //{
         //player_controls.set_right_button_pressed(false);
         //player_controls.set_left_button_pressed(false);
      //}
      //if (axis == 0 && position < -0.5) player_controls.set_left_button_pressed(true);
      
      return;


  - name: user_event_func
    virtual: true
    override: true
    parameters:
      - name: event
        type: ALLEGRO_EVENT*
        default_argument: nullptr
    body: |
      switch(event->type)
      {
         //case ALLEGRO_FLARE_EVENT_VIRTUAL_CONTROL_BUTTON_UP:
           //virtual_control_button_up_func(event);
         //break;

         //case ALLEGRO_FLARE_EVENT_VIRTUAL_CONTROL_BUTTON_DOWN:
           //virtual_control_button_down_func(event);
         //break;

         //case ALLEGRO_FLARE_EVENT_VIRTUAL_CONTROL_AXIS_CHANGE:
           //virtual_control_axis_change_func(event);
         //break;
      }

      return;
    body_dependency_symbols:
      - AllegroFlare::EventNames


  - name: render_collision_tile_mesh
    guards: [ currently_active_map ]
    body: |
      AllegroFlare::TileMaps::TileMap<int> *tile_map = currently_active_map->get_collision_tile_mesh();
      float tile_width=16.0f;
      float tile_height=16.0f;

      if (!al_is_primitives_addon_initialized()) throw std::runtime_error("render_tile_map: primitives must be init");

      for (int y=0; y<tile_map->get_num_rows(); y++)
         for (int x=0; x<tile_map->get_num_columns(); x++)
         {
            int tile_type = tile_map->get_tile(x, y);
            switch(tile_type)
            {
               case 0:
                 al_draw_rectangle(x * tile_width, y * tile_height, (x+1) * tile_width, (y+1) * tile_height, 
                    ALLEGRO_COLOR{0.2, 0.2, 0.21, 0.21}, 1.0);
               break;

               case 1:
                 al_draw_filled_rectangle(x * tile_width, y * tile_height, (x+1) * tile_width, (y+1) * tile_height, 
                    ALLEGRO_COLOR{0.65, 0.62, 0.6, 1.0});
               break;

               default:
                 al_draw_filled_rectangle(x * tile_width, y * tile_height, (x+1) * tile_width, (y+1) * tile_height, 
                    ALLEGRO_COLOR{0.8, 0.32, 0.4, 1.0});
               break;
            }
         }
      return;


  - name: get_tile_atlas
    guards: [ currently_active_map ]
    type: AllegroFlare::TileMaps::PrimMeshAtlas*
    body: |
      return currently_active_map->get_tile_atlas();


  - name: get_tile_mesh
    guards: [ currently_active_map ]
    type: AllegroFlare::TileMaps::PrimMesh*
    body: |
      return currently_active_map->get_tile_mesh();


  - name: get_background_tile_mesh
    guards: [ currently_active_map ]
    type: AllegroFlare::TileMaps::PrimMesh*
    body: |
      return currently_active_map->get_background_tile_mesh();


  - name: background_tile_mesh_exists
    guards: [ currently_active_map ]
    type: bool
    body: |
      return (currently_active_map->get_background_tile_mesh() != nullptr);


  - name: get_collision_tile_mesh
    guards: [ currently_active_map ]
    type: AllegroFlare::TileMaps::TileMap<int>*
    body: |
      return currently_active_map->get_collision_tile_mesh();


  - name: get_current_map_entities
    type: std::vector<AllegroFlare::Prototypes::Platforming2D::Entities::Basic2D*>
    body: |
      AllegroFlare::Prototypes::Platforming2D::EntityCollectionHelper collection_helper(&entity_pool);
      std::string on_map_name = currently_active_map_name;
      return collection_helper.select_on_map(on_map_name);
    body_dependency_symbols:
      - AllegroFlare::Prototypes::Platforming2D::EntityCollectionHelper


  - name: obtain_debug_font
    guards: [ font_bin ]
    type: ALLEGRO_FONT*
    body: |
      return font_bin->auto_get("Inter-Medium.ttf -32");



dependencies:


  - symbol: AllegroFlare::BitmapBin
    headers: [ AllegroFlare/BitmapBin.hpp ]
  - symbol: al_color_name
    headers: [ allegro5/allegro_color.h ]
  - symbol: std::fixed
    headers: [ iomanip ]
  - symbol: std::map<int, int>
    headers: [ map ]
  - symbol: AllegroFlare::VirtualController
    headers: [ AllegroFlare/VirtualController.hpp ]
  - symbol: AllegroFlare::VirtualControlsProcessor
    headers: [ AllegroFlare/VirtualControlsProcessor.hpp ]
  - symbol: AllegroFlare::TileMaps::PrimMeshAtlas
    headers: [ AllegroFlare/TileMaps/PrimMeshAtlas.hpp ]
  - symbol: AllegroFlare::EventNames
    headers: [ AllegroFlare/EventNames.hpp ]
  - symbol: AllegroFlare::Prototypes::Platforming2D::Entities::Basic2DFactory
    headers: [ AllegroFlare/Prototypes/Platforming2D/Entities/Basic2DFactory.hpp ]
  - symbol: AllegroFlare::Screen
    headers: [ AllegroFlare/Screen.hpp ]
  - symbol: AllegroFlare::Frameworks::Full
    headers: [ AllegroFlare/Frameworks/Full.hpp ]
  - symbol: AllegroFlare::Placement2D
    headers: [ AllegroFlare/Placement2D.hpp ]
  - symbol: AllegroFlare::vec2d
    headers: [ AllegroFlare/Vec2D.hpp ]
  - symbol: al_color_name
    headers: [ allegro5/allegro_color.h ]
  - symbol: AllegroFlare::Physics::TileMapCollisionStepper
    headers: [ AllegroFlare/Physics/TileMapCollisionStepper.hpp ]
  - symbol: AllegroFlare::Physics::AABB2D
    headers: [ AllegroFlare/Physics/AABB2D.hpp ]
  - symbol: AllegroFlare::Prototypes::Platforming2D::EntityFlagNames
    headers: [ AllegroFlare/Prototypes/Platforming2D/EntityFlagNames.hpp ]
  - symbol: AllegroFlare::CameraControlStrategies2D::Base
    headers: [ AllegroFlare/CameraControlStrategies2D/Base.hpp ]
  - symbol: AllegroFlare::CameraControlStrategies2D::Snap
    headers: [ AllegroFlare/CameraControlStrategies2D/Snap.hpp ]
  - symbol: AllegroFlare::CameraControlStrategies2D::SmoothSnap
    headers: [ AllegroFlare/CameraControlStrategies2D/SmoothSnap.hpp ]
  - symbol: AllegroFlare::CameraControlStrategies2D::SmoothSnapWithZoomEffect
    headers: [ AllegroFlare/CameraControlStrategies2D/SmoothSnapWithZoomEffect.hpp ]
  - symbol: AllegroFlare::CameraControlStrategies2D::HorizontalRail
    headers: [ AllegroFlare/CameraControlStrategies2D/HorizontalRail.hpp ]
  - symbol: AllegroFlare::Prototypes::Platforming2D::EntityCollectionHelper
    headers: [ AllegroFlare/Prototypes/Platforming2D/EntityCollectionHelper.hpp ]
  - symbol: AllegroFlare::Prototypes::Platforming2D::Entities::TileMaps::Basic2D
    headers: [ AllegroFlare/Prototypes/Platforming2D/Entities/TileMaps/Basic2D.hpp ]
  - symbol: AllegroFlare::Prototypes::Platforming2D::Entities::Doors::Basic2D
    headers: [ AllegroFlare/Prototypes/Platforming2D/Entities/Doors/Basic2D.hpp ]
  - symbol: std::find
    headers: [ algorithm ]
  - symbol: tan
    headers: [ cmath ]
  - symbol: AllegroFlare::TileMaps::PrimMesh
    headers: [ AllegroFlare/TileMaps/PrimMesh.hpp ]
  - symbol: AllegroFlare::TileMaps::TileMap
    headers: [ AllegroFlare/TileMaps/TileMap.hpp ]
  - symbol: ALLEGRO_EVENT
    headers: [ allegro5/allegro.h ]
  - symbol: AllegroFlare::Display
    headers: [ AllegroFlare/Display.hpp ]
  - symbol: AllegroFlare::Prototypes::Platforming2D::Entities::Basic2D
    headers: [ AllegroFlare/Prototypes/Platforming2D/Entities/Basic2D.hpp ]
  - symbol: AllegroFlare::EventEmitter
    headers: [ AllegroFlare/EventEmitter.hpp ]
  - symbol: AllegroFlare::Screens::Base
    headers: [ AllegroFlare/Screens/Base.hpp ]
  - symbol: AllegroFlare::Camera2D
    headers: [ AllegroFlare/Camera2D.hpp ]
  - symbol: ALLEGRO_BITMAP
    headers: [ allegro5/allegro.h ]
  - symbol: AllegroFlare::Vec2D
    headers: [ AllegroFlare/Vec2D.hpp ]
  - symbol: AllegroFlare::Player
    headers: [ AllegroFlare/Player.hpp ]
  - symbol: AllegroFlare::VirtualControllers::Base
    headers: [ AllegroFlare/VirtualControllers/Base.hpp ]
  - symbol: AllegroFlare::VirtualControllers::GenericController
    headers: [ AllegroFlare/VirtualControllers/GenericController.hpp ]
  - symbol: AllegroFlare::Screens::Gameplay
    headers: [ AllegroFlare/Screens/Gameplay.hpp ]
  - symbol: AllegroFlare::Prototypes::Platforming2D::EntityControlConnectors::Base
    headers: [ AllegroFlare/Prototypes/Platforming2D/EntityControlConnectors/Base.hpp ]
  - symbol: AllegroFlare::Prototypes::Platforming2D::EntityControlConnectors::Basic2D
    headers: [ AllegroFlare/Prototypes/Platforming2D/EntityControlConnectors/Basic2D.hpp ]
  - symbol: AllegroFlare::Prototypes::Platforming2D::TMJObjectLoaderObjectCustomProperties
    headers: [ AllegroFlare/Prototypes/Platforming2D/TMJObjectLoaderObjectCustomProperties.hpp ]
  - symbol: AllegroFlare::Prototypes::Platforming2D::MapDictionaryListing
    headers: [ AllegroFlare/Prototypes/Platforming2D/MapDictionaryListing.hpp ]
  - symbol: std::numeric_limits
    headers: [ limits ]
  - symbol: ALLEGRO_FONT
    headers: [ allegro5/allegro_font.h ]
  - symbol: AllegroFlare::FontBin
    headers: [ AllegroFlare/FontBin.hpp ]
  - symbol: AllegroFlare::Physics::TileMapCollisionStepperCollisionInfo
    headers: [ AllegroFlare/Physics/TileMapCollisionStepperCollisionInfo.hpp ]
  - symbol: AllegroFlare::Prototypes::Platforming2D::Entities::BossZone
    headers: [ AllegroFlare/Prototypes/Platforming2D/Entities/BossZone.hpp ]
  - symbol: AllegroFlare::TileMaps::TileAtlasRepository
    headers: [ AllegroFlare/TileMaps/TileAtlasRepository.hpp ]


