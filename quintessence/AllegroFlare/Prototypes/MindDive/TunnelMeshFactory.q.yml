properties:


  - name: bitmap_bin
    type: AllegroFlare::BitmapBin*
    constructor_arg: true
    init_with: nullptr
    getter: true
    setter: true


functions:


  - name: create_classic_random
    type: AllegroFlare::Prototypes::MindDive::TunnelMesh*
    guards: [ bitmap_bin ]
    body: |
      AllegroFlare::Prototypes::MindDive::TunnelMesh *result = new AllegroFlare::Prototypes::MindDive::TunnelMesh;
      result->set_bitmap_bin(bitmap_bin);
      result->set_atlas_configuration("uv.png", 100, 100);
      result->initialize();
      result->get_prim_mesh_ref().rescale_tile_dimentions_to(2, 2*2);
      result->get_prim_mesh_ref().resize(12, 32);
      result->random_fill();
      return result;


  - name: create_random_with_walls
    type: AllegroFlare::Prototypes::MindDive::TunnelMesh*
    guards: [ bitmap_bin ]
    body: |
      AllegroFlare::Prototypes::MindDive::TunnelMesh *result = new AllegroFlare::Prototypes::MindDive::TunnelMesh;
      result->set_bitmap_bin(bitmap_bin);
      result->set_atlas_configuration("uv-with-decorations-0x.png", 50, 50);
      result->initialize();
      //result->rescale_tile_dimentions_to(2, 6);
      result->rescale_tile_dimentions_to(1, 1);
      result->resize(12, 32 * 2);
      random_fill_from(result, { { 2, 2 } });
      //random_sparce_placement(result, { { 0, 0 } }, 20);
      //random_sparce_placement(result, { { 1, 1 } }, 40);
      return result;


  - name: random_fill_from
    parameters:
      - name: tunnel_mesh
        type: AllegroFlare::Prototypes::MindDive::TunnelMesh*
        default_argument: nullptr
      - name: inclusion_list
        type: std::vector<std::pair<int, int>>
        default_argument: '{}'
    guards: [ tunnel_mesh, (!inclusion_list.empty()) ]
    body: |
      AllegroFlare::TileMaps::PrimMesh &prim_mesh = tunnel_mesh->get_prim_mesh_ref();
      AllegroFlare::TileMaps::TileMap<int> &collision_tile_map = tunnel_mesh->get_collision_tile_map_ref();
      AllegroFlare::Random random;
      for (int y=0; y<prim_mesh.get_num_rows(); y++)
         for (int x=0; x<prim_mesh.get_num_columns(); x++)
         {
            std::pair<int, int> random_element = random.get_random_element(inclusion_list);
            prim_mesh.set_tile_id(x, y, random_element.first);
            collision_tile_map.set_tile(x, y, random_element.second);
         }
      return;
    body_dependency_symbols:
      - AllegroFlare::Random


  - name: random_sparce_placement
    parameters:
      - name: tunnel_mesh
        type: AllegroFlare::Prototypes::MindDive::TunnelMesh*
        default_argument: nullptr
      - name: inclusion_list
        type: std::vector<std::pair<int, int>>
        default_argument: '{}'
      - name: one_in_chance
        type: int
        default_argument: 2
    body: |
      if (inclusion_list.empty()) return;
      AllegroFlare::TileMaps::PrimMesh &prim_mesh = tunnel_mesh->get_prim_mesh_ref();
      AllegroFlare::TileMaps::TileMap<int> &collision_tile_map = tunnel_mesh->get_collision_tile_map_ref();
      AllegroFlare::Random random;
      for (int y=0; y<prim_mesh.get_num_rows(); y++)
         for (int x=0; x<prim_mesh.get_num_columns(); x++)
         {
            bool will_place = random.get_one_in_chance(one_in_chance);
            if (will_place)
            {
               std::pair<int, int> random_element = random.get_random_element(inclusion_list);
               prim_mesh.set_tile_id(x, y, random_element.first);
               collision_tile_map.set_tile(x, y, random_element.second);
            }
         }
      return;
    body_dependency_symbols:
      - AllegroFlare::Random


  - name: random_fill_excluding
    parameters:
      - name: tunnel_mesh
        type: AllegroFlare::Prototypes::MindDive::TunnelMesh*
        default_argument: nullptr
      - name: exclusion_list
        type: std::set<int>
        default_argument: '{}'
    guards: [ tunnel_mesh ]
    body: |
      AllegroFlare::TileMaps::PrimMesh &prim_mesh = tunnel_mesh->get_prim_mesh_ref();
      AllegroFlare::TileMaps::TileMap<int> &collision_tile_map = tunnel_mesh->get_collision_tile_map_ref();
      
      AllegroFlare::Random random;
      int num_tiles_in_atlas = 100;
      for (int y=0; y<prim_mesh.get_num_rows(); y++)
         for (int x=0; x<prim_mesh.get_num_columns(); x++)
         {
            bool int_is_excluded = false;
            int random_int = -1;
            int tries_left = 100;
            bool still_tries_left = true;

            do
            {
               random_int = random.get_random_int(0, num_tiles_in_atlas-1);
               int_is_excluded =
                  std::find(exclusion_list.begin(), exclusion_list.end(), random_int) != exclusion_list.end();
               tries_left--;
               if (tries_left < 0) still_tries_left = false;
            } while(int_is_excluded && still_tries_left);

            prim_mesh.set_tile_id(x, y, random_int);
         }
      return;
    body_dependency_symbols:
      - AllegroFlare::Random


dependencies:


  - symbol: AllegroFlare::BitmapBin
    headers: [ AllegroFlare/BitmapBin.hpp ]
  - symbol: AllegroFlare::Prototypes::MindDive::TunnelMesh
    headers: [ AllegroFlare/Prototypes/MindDive/TunnelMesh.hpp ]
  - symbol: AllegroFlare::Random
    headers: [ AllegroFlare/Random.hpp ]


