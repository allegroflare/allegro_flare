properties:


  - name: bitmap_bin
    type: AllegroFlare::BitmapBin*
    constructor_arg: true
    init_with: nullptr
    getter: true
    setter: true


functions:


  - name: create_classic_random
    type: AllegroFlare::Prototypes::MindDive::TunnelMesh*
    guards: [ bitmap_bin ]
    body: |
      AllegroFlare::Prototypes::MindDive::TunnelMesh *result = new AllegroFlare::Prototypes::MindDive::TunnelMesh;
      result->set_bitmap_bin(bitmap_bin);
      result->set_atlas_configuration("uv.png", 100, 100);
      result->initialize();
      result->get_prim_mesh_ref().rescale_tile_dimentions_to(2, 2*2);
      result->get_prim_mesh_ref().resize(12, 32);
      result->random_fill();
      return result;


  - name: create_random_with_walls
    type: AllegroFlare::Prototypes::MindDive::TunnelMesh*
    guards: [ bitmap_bin ]
    body: |
      AllegroFlare::Prototypes::MindDive::TunnelMesh *result = new AllegroFlare::Prototypes::MindDive::TunnelMesh;
      result->set_bitmap_bin(bitmap_bin);
      result->set_atlas_configuration("uv-with-decorations-02.png", 50, 50);
      result->initialize();
      result->rescale_tile_dimentions_to(2, 2*2);
      result->resize(12, 32);
      random_fill_excluding(result, {0, 1, 2, 3});
      return result;


  - name: random_fill_from
    parameters:
      - name: tunnel_mesh
        type: AllegroFlare::Prototypes::MindDive::TunnelMesh*
        default_argument: nullptr
      - name: inclusion_list
        type: std::vector<int>
        default_argument: '{}'
    guards: [ tunnel_mesh, (!inclusion_list.empty()) ]
    body: |
      AllegroFlare::TileMaps::PrimMesh &prim_mesh = tunnel_mesh->get_prim_mesh_ref();
      AllegroFlare::TileMaps::TileMap<int> &collision_tile_map = tunnel_mesh->get_collision_tile_map_ref();
      AllegroFlare::Random random;
      for (int y=0; y<prim_mesh.get_num_rows(); y++)
         for (int x=0; x<prim_mesh.get_num_columns(); x++)
         {
            int random_int = random.get_random_element(inclusion_list);
            prim_mesh.set_tile_id(x, y, random_int);
         }
      return;
    body_dependency_symbols:
      - AllegroFlare::Random


  - name: random_fill_excluding
    parameters:
      - name: tunnel_mesh
        type: AllegroFlare::Prototypes::MindDive::TunnelMesh*
        default_argument: nullptr
      - name: exclusion_list
        type: std::set<int>
        default_argument: '{}'
    guards: [ tunnel_mesh ]
    body: |
      AllegroFlare::TileMaps::PrimMesh &prim_mesh = tunnel_mesh->get_prim_mesh_ref();
      AllegroFlare::TileMaps::TileMap<int> &collision_tile_map = tunnel_mesh->get_collision_tile_map_ref();
      
      AllegroFlare::Random random;
      int num_tiles_in_atlas = 100;
      for (int y=0; y<prim_mesh.get_num_rows(); y++)
         for (int x=0; x<prim_mesh.get_num_columns(); x++)
         {
            bool int_is_excluded = false;
            int random_int = -1;
            int tries_left = 100;
            bool still_tries_left = true;

            do
            {
               random_int = random.get_random_int(0, num_tiles_in_atlas-1);
               int_is_excluded =
                  std::find(exclusion_list.begin(), exclusion_list.end(), random_int) != exclusion_list.end();
               tries_left--;
               if (tries_left < 0) still_tries_left = false;
            } while(int_is_excluded && still_tries_left);

            prim_mesh.set_tile_id(x, y, random_int);
         }
      return;
    body_dependency_symbols:
      - AllegroFlare::Random


dependencies:


  - symbol: AllegroFlare::BitmapBin
    headers: [ AllegroFlare/BitmapBin.hpp ]
  - symbol: AllegroFlare::Prototypes::MindDive::TunnelMesh
    headers: [ AllegroFlare/Prototypes/MindDive/TunnelMesh.hpp ]
  - symbol: AllegroFlare::Random
    headers: [ AllegroFlare/Random.hpp ]


