parent_classes:


  - class: AllegroFlare::Elements::DialogBoxes::Base
    scope: public
    init_with: AllegroFlare::Elements::DialogBoxes::Choice::TYPE


properties:


  - name: prompt
    type: std::string
    init_with: '"[prompt-question-not-set]"'
    constructor_arg: true

  - name: options
    type: std::vector<std::pair<std::string, std::string>>
    init_with: '{}'
    constructor_arg: true

  - name: cursor_position
    type: int
    init_with: -1
    getter: true

  - name: initialized
    type: bool
    init_with: false

  - name: TYPE
    type: char*
    init_with: '(char*)"DialogBoxes/Choice"'
    static: true
    constexpr: true


methods:


  - name: update
    virtual: true
    override: true
    body: |
      // NOTE: Refactoring when this method is created; expecting that nothing is to be done here
      return;


  - name: advance
    virtual: true
    override: true
    body: |
      // TODO: rather than have this "finish" it should advance the animation to the end.  Then, if the dialog
      // has "advance()" called a second time, it will set finished to true.
      // NOTE: this is similar behavior to DialogBoxes/YouGotAnItem, it should be updated accordingly as well
      if (get_finished()) return;
      set_finished(true);


  - name: initialize
    guards: [ (!initialized) ]
    body: |
      if (options.empty())
      {
         // do nothing
      }
      else
      {
         cursor_position = 0;
      }
      initialized = true;
      return;


  - name: get_prompt
    type: std::string
    guards: [ initialized ]
    body: return prompt;


  - name: get_options
    type: std::vector<std::pair<std::string, std::string>>
    guards: [ initialized ]
    body: return options;


  - name: get_item_labels
    type: std::vector<std::string>
    body: |
      std::vector<std::string> result;
      for (auto &item : options)
      {
         result.push_back(item.first);
      }
      return result;


  - name: get_current_selection_text
    type: std::string
    guards: [ initialized ]
    body: |
      if (!has_valid_cursor_position()) return "";
      return options[cursor_position].first;


  - name: get_current_selection_value
    type: std::string
    guards: [ initialized ]
    body: |
      if (!has_valid_cursor_position()) return "";
      return options[cursor_position].second;


  - name: move_cursor_position_down
    virtual: true
    override: true
    type: void
    guards: [ initialized ]
    body: |
      if (!has_valid_cursor_position()) return;

      cursor_position++;
      if (cursor_position >= options.size()) cursor_position = cursor_position % options.size();
      return;


  - name: move_cursor_position_up
    virtual: true
    override: true
    type: void
    guards: [ initialized ]
    body: |
      if (!has_valid_cursor_position()) return;

      cursor_position--;
      if (cursor_position < 0) cursor_position = (cursor_position + (options.size() * 100)) % options.size();
      return;


  - name: has_valid_cursor_position
    private: true
    type: bool
    body: |
      return (cursor_position != -1);


dependencies:


  - symbol: AllegroFlare::Elements::DialogBoxes::Base
    headers: [ AllegroFlare/Elements/DialogBoxes/Base.hpp ]
  - symbol: std::vector<std::pair<std::string, std::string>>
    headers: [ vector, utility, string ]


