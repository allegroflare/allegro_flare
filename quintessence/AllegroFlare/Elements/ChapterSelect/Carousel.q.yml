properties:


  - name: bitmap_bin
    type: AllegroFlare::BitmapBin*
    init_with: nullptr
    constructor_arg: true
    getter: true
    setter: true

  - name: font_bin
    type: AllegroFlare::FontBin*
    init_with: nullptr
    constructor_arg: true
    getter: true
    setter: true

  - name: elements
    type: std::vector<AllegroFlare::Elements::ChapterSelect::CarouselElements::Base*>
    init_with: '{}'
    getter: true
    setter: explicit

  - name: focused_element_position
    type: int
    init_with: 0
    constructor_arg: true
    getter: true
    setter: true

  - name: element_dimensions
    type: std::map<AllegroFlare::Elements::ChapterSelect::CarouselElements::Base*, std::tuple<float, float, float, float>>
    init_with: '{}'

  - name: element_dimensions_refreshed
    type: bool
    init_with: false

  - name: camera
    type: AllegroFlare::Placement2D
    init_with: ''
    getter: true
    setter: true


methods:


  - name: set_elements
    parameters:
      - name: elements
        type: std::vector<AllegroFlare::Elements::ChapterSelect::CarouselElements::Base*>
        default_argument: '{}'
    body: |
      this->elements = elements;
      element_dimensions.clear();
      element_dimensions_refreshed = false;
      focused_element_position = 0;
      return;


  - name: rotate_carousel_left
    body: |
      if (elements.empty()) return;

      focused_element_position -= 1;
      if (focused_element_position < 0) focused_element_position += elements.size();

      reposition_camera_position_to_focused_element();
      return;


  - name: rotate_carousel_right
    body: |
      if (elements.empty()) return;

      focused_element_position += 1;
      if (focused_element_position >= elements.size()) focused_element_position -= elements.size();

      reposition_camera_position_to_focused_element();
      return;


  - name: reposition_camera_position_to_focused_element
    body: |
      camera.position.x = get_element_x_position_for(focused_element_position);
      return;


  - name: update
    body: |
      for (auto &element : elements) element->update();
      return;


  - name: render
    guards: [ bitmap_bin, font_bin ]
    body: |
      camera.start_reverse_transform();
      AllegroFlare::Placement2D list_element_placement;
      list_element_placement.align = AllegroFlare::Vec2D(0.5, 0.5);
      AllegroFlare::Elements::ChapterSelect::CarouselElementRenderer renderer(bitmap_bin, font_bin);
      int position = 0;
      for (auto &element : elements)
      {
         std::tuple<float, float, float, float> element_dimensions = get_element_dimensions(element);

         list_element_placement.position.x = std::get<0>(element_dimensions);
         list_element_placement.position.y = std::get<1>(element_dimensions);
         list_element_placement.size.x = std::get<2>(element_dimensions);
         list_element_placement.size.y = std::get<3>(element_dimensions);

         list_element_placement.start_transform();
         renderer.render(element);
         // for debugging
         al_draw_rectangle(
               0,
               0,
               list_element_placement.size.x,
               list_element_placement.size.y,
               ALLEGRO_COLOR{0.6, 0.2, 0.2, 0.2},
               2.0f
            );
         list_element_placement.restore_transform();
         position++;
      }
      camera.restore_transform();
      return;
    body_dependency_symbols:
      - AllegroFlare::Elements::ChapterSelect::CarouselElementRenderer
      - al_draw_rectangle


  - name: get_element_x_position_for
    type: float
    parameters:
      - name: position
        type: int
        default_argument: 0
    guards: [ (position >= 0), (position <= elements.size()), element_dimensions_refreshed ]
    body: |
      float arbitrary_element_spacing = 1200;
      return position * arbitrary_element_spacing;


  - name: get_element_at_position
    type: AllegroFlare::Elements::ChapterSelect::CarouselElements::Base*
    parameters:
      - name: position
        type: int
        default_argument: 0
    guards: [ (position >= 0), (position <= elements.size()) ]
    body: |
      return elements[position];


  - name: get_element_dimensions_at_position
    type: std::tuple<float, float, float, float>
    parameters:
      - name: position
        type: int
        default_argument: 0
    guards: [ (position >= 0), (position <= elements.size()), element_dimensions_refreshed ]
    body: |
      AllegroFlare::Elements::ChapterSelect::CarouselElements::Base* element = get_element_at_position(position);
      if (element_dimensions.count(element) == 0)
      {
         AllegroFlare::Logger::throw_error(
               "AllegroFlare::Elements::ChapterSelect::Carousel::get_element_dimensions_at_position",
               "Unexpected error: Could not find element_dimensions on for this element."
            );
      }
      return element_dimensions[element];


  - name: get_element_dimensions
    type: std::tuple<float, float, float, float>
    parameters:
      - name: element
        type: AllegroFlare::Elements::ChapterSelect::CarouselElements::Base*
        default_argument: nullptr
    guards: [ element ]
    body: |
      if (element_dimensions.count(element) == 0)
      {
         AllegroFlare::Logger::throw_error(
               "AllegroFlare::Elements::ChapterSelect::Carousel::get_element_dimensions_at_position",
               "Unexpected error: Could not find element_dimensions on for this element."
            );
      }
      return element_dimensions[element];


  - name: refresh_element_dimensions
    body: |
      element_dimensions.clear();
      float arbitrary_element_spacing = 1200;
      float cursor_x = 0;
      for (auto &element : elements)
      {
         // TODO: Use Renderer and calculate dimensions on these elements
         float element_width = arbitrary_element_spacing;

         element_dimensions[element] = std::make_tuple(cursor_x, 0, element_width, 200.0f);

         cursor_x += element_width;
      }

      // Sanity check
      if (element_dimensions.size() != elements.size())
      {
         AllegroFlare::Logger::throw_error(
               "AllegroFlare::Elements::ChapterSelect::Carousel",
               "Expecting the number of element_dimensions to match number of elements. Expecting unique elements in "
                  "the carousel that can be mapped to dimensions, but elements contains a non-unique list."
            );
      }
      element_dimensions_refreshed = true;
    body_dependency_symbols:
      - AllegroFlare::Logger


dependencies:


  - symbol: AllegroFlare::Elements::ChapterSelect::CarouselElements::Base
    headers: [ AllegroFlare/Elements/ChapterSelect/CarouselElements/Base.hpp ]
  - symbol: AllegroFlare::Elements::ChapterSelect::CarouselElementRenderer
    headers: [ AllegroFlare/Elements/ChapterSelect/CarouselElementRenderer.hpp ]
  - symbol: AllegroFlare::BitmapBin
    headers: [ AllegroFlare/BitmapBin.hpp ]
  - symbol: AllegroFlare::FontBin
    headers: [ AllegroFlare/FontBin.hpp ]
  - symbol: AllegroFlare::Placement2D
    headers: [ AllegroFlare/Placement2D.hpp ]
  - symbol: AllegroFlare::Logger
    headers: [ AllegroFlare/Logger.hpp ]
  - symbol: al_draw_rectangle
    headers: [ allegro5/allegro_primitives.h ]


