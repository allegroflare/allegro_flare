parent_classes:


  - class: AllegroFlare::Elements::RollingCredits::Sections::Base
    scope: public
    init_with: AllegroFlare::Elements::RollingCredits::Sections::Multicolumn::TYPE


properties:


  - name: elements
    type: std::vector<std::vector<std::string>>
    init_with: '{}'
    constructor_arg: true
    setter: true
    getter: true

  - name: TYPE
    type: char*
    init_with: '(char*)"AllegroFlare/Elements/RollingCredits/Sections/Multicolumn"'
    static: true
    constexpr: true


methods:


  - name: split_into_columns
    static: true
    type: std::vector<std::vector<std::string>>
    parameters:
      - name: names
        type: std::vector<std::string>
        default_argument: '{}'
      - name: num_columns
        type: int
        default_argument: 3
    guards: [ (num_columns >= 1) ]
    body: |
      std::vector<std::vector<std::string>> result; //(num_rows, std::vector<std::string>(num_columns, ""));

      int items_per_column = static_cast<int>(std::ceil(static_cast<double>(names.size()) / num_columns));

      //std::cout << 

      int item_count_in_this_column = 0;
      std::vector<std::string> column;
      int i=0;
      for (i=0; i<(int)names.size(); ++i)
      {
         column.push_back(names[i]);
         item_count_in_this_column++;

         if (item_count_in_this_column >= items_per_column)
         {
            item_count_in_this_column = 0;
            result.push_back(column);
            column.clear();
         }
      }

      // Append the last column if it is incomplete
      if (!column.empty()) result.push_back(column);

      return result;


dependencies:


  - symbol: AllegroFlare::Elements::RollingCredits::Sections::Base
    headers: [ AllegroFlare/Elements/RollingCredits/Sections/Base.hpp ]


