properties:


  - name: cubemap_shader
    type: AllegroFlare::Shaders::Cubemap*
    init_with: nullptr
    constructor_arg: true
    getter: true
    setter: true

  - name: entity_pool
    type: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::EntityPool*
    constructor_arg: true
    init_with: nullptr
    getter: true
    setter: true


functions:


  - name: render
    guards: [ entity_pool, cubemap_shader ]
    body: |
      using namespace AllegroFlare::GraphicsPipelines::DynamicEntityPipeline;
      //headers: [ AllegroFlare/GraphicsPipelines/DynamicEntityPipeline/SceneRenderer.hpp ]

      // Extract out the camera and render the scene
      Entities::Base *entity = entity_pool->find_with_attribute("primary_camera");
      if (!entity) throw std::runtime_error("no camera present");
      // TODO: validate the camera is of type Entities::Camera
      Entities::Camera3D *as_camera = static_cast<Entities::Camera3D*>(entity);

      // TODO: Get a proper render surface, rather than pulling from the current display
      ALLEGRO_BITMAP *render_surface = al_get_backbuffer(al_get_current_display()); // TODO: replace with render surface
      al_clear_depth_buffer(1);
      al_clear_to_color(ALLEGRO_COLOR{0.1, 0.105, 0.12, 1.0});

      AllegroFlare::Camera3D &camera = as_camera->get_camera_3d_ref();
      camera.setup_projection_on(render_surface);

      // Set the camera position in the iridescent shder
      cubemap_shader->set_camera_position(camera.get_real_position());

      //std::unordered_set<AllegroFlare::SceneGraph::Entities::Base*>
      for (auto &entity : entity_pool->get_entity_pool_ref())
      {
         // TODO: Rename legacy "as_agc_entity" to something more appropriate
         Entities::Base *as_agc_entity = static_cast<Entities::Base*>(entity);

         // Skip if entity is flagged as "do not render"
         // TODO: Introduce DO_NOT_RENDER flags
         //if (as_agc_entity->exists(EntityFlags::DO_NOT_RENDER)) continue;
         

         AllegroFlare::Model3D *model = get_model_3d(as_agc_entity); //as_agc_entity->get_model();

         if (model)
         {
            AllegroFlare::Placement3D *placement = get_placement_3d(as_agc_entity);
            if (!placement) continue; // TODO: Test this line

            // Collect render flags
            bool renders_with_iridescent = //false;
               //true;
               // TODO: Intoduce this flag (except is "renders with skybox"):
               as_agc_entity->exists("irid");//ArtGalleryOfCats::Gameplay::EntityFlags::RENDERS_WITH_IRIDESCENT);

            // Setup the render for this object
            if (renders_with_iridescent)
            {
               //Gameplay::Entities::Base *as_gac_base = static_cast<Entities::Base*>(entity);

               // NOTE: For now, this has to be set before activating the shader
               cubemap_shader->set_object_placement(placement);

               cubemap_shader->activate();
            }
            else
            {
               ALLEGRO_BITMAP *texture = get_texture(as_agc_entity); //->get_texture();
               if (texture) model->set_texture(texture);
               placement->start_transform();
               //as_agc_entity->get_placement_ref().start_transform();
            }

            // Draw the model
            model->draw();

            // Teardown the render for this object
            if (renders_with_iridescent)
            {
               cubemap_shader->deactivate();
            }
            else
            {
               placement->restore_transform();
            }
         }
         else // (!model)
         {
            ALLEGRO_BITMAP *texture = get_texture(as_agc_entity); //->get_texture();
            AllegroFlare::Placement3D *placement = get_placement_3d(as_agc_entity);

            if (texture)
            {
               placement->start_transform();
               al_draw_bitmap(texture, 0, 0, ALLEGRO_FLIP_VERTICAL);
               placement->restore_transform();
            }
         }
      }

      return;
    body_dependency_symbols:
      - AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::Camera3D


  - name: get_model_3d
    type: AllegroFlare::Model3D*
    parameters:
      - name: entity
        type: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::Base*
        default_argument: nullptr
    guards: [ entity ]
    body: |
      // TODO: Optimize this lookup
      // TODO: Consider throw on unhandled type
      if (entity->is_type(AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::DynamicModel3D::TYPE))
      {
         Entities::DynamicModel3D *as_casted = static_cast<Entities::DynamicModel3D*>(entity);
         return as_casted->get_model_3d();
      }
      else if (entity->is_type(AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::StaticModel3D::TYPE))
      {
         Entities::StaticModel3D *as_casted = static_cast<Entities::StaticModel3D*>(entity);
         return as_casted->get_model_3d();
      }
      return nullptr;
    body_dependency_symbols:
      - AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::StaticModel3D
      - AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::DynamicModel3D
   

  - name: get_placement_3d
    type: AllegroFlare::Placement3D*
    parameters:
      - name: entity
        type: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::Base*
        default_argument: nullptr
    guards: [ entity ]
    body: |
      // TODO: Optimize this lookup
      // TODO: Consider throw on unhandled type
      if (entity->is_type(AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::DynamicModel3D::TYPE))
      {
         Entities::DynamicModel3D *as_casted = static_cast<Entities::DynamicModel3D*>(entity);
         return &as_casted->get_placement_ref();
      }
      else if (entity->is_type(AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::StaticModel3D::TYPE))
      {
         Entities::StaticModel3D *as_casted = static_cast<Entities::StaticModel3D*>(entity);
         return &as_casted->get_placement_ref();
      }
      return nullptr;
    body_dependency_symbols:
      - AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::StaticModel3D
      - AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::DynamicModel3D
   

  - name: get_texture
    type: ALLEGRO_BITMAP*
    parameters:
      - name: entity
        type: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::Base*
        default_argument: nullptr
    guards: [ entity ]
    body: |
      // TODO: Optimize this lookup
      // TODO: Consider throw on unhandled type
      if (entity->is_type(AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::DynamicModel3D::TYPE))
      {
         Entities::DynamicModel3D *as_casted = static_cast<Entities::DynamicModel3D*>(entity);
         return as_casted->get_model_3d_texture();
      }
      else if (entity->is_type(AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::StaticModel3D::TYPE))
      {
         Entities::StaticModel3D *as_casted = static_cast<Entities::StaticModel3D*>(entity);
         return as_casted->get_model_3d_texture();
      }
      return nullptr;
    body_dependency_symbols:
      - AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::StaticModel3D
      - AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::DynamicModel3D
   

dependencies:


  - symbol: AllegroFlare::Placement3D
    headers: [ AllegroFlare/Placement3D.hpp ]
  - symbol: AllegroFlare::Model3D
    headers: [ AllegroFlare/Model3D.hpp ]
  - symbol: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::Base
    headers: [ AllegroFlare/GraphicsPipelines/DynamicEntityPipeline/Entities/Base.hpp ]
  - symbol: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::EntityPool
    headers: [ AllegroFlare/GraphicsPipelines/DynamicEntityPipeline/EntityPool.hpp ]
  - symbol: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::Camera3D
    headers: [ AllegroFlare/GraphicsPipelines/DynamicEntityPipeline/Entities/Camera3D.hpp ]
  - symbol: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::StaticModel3D
    headers: [ AllegroFlare/GraphicsPipelines/DynamicEntityPipeline/Entities/StaticModel3D.hpp ]
  - symbol: AllegroFlare::GraphicsPipelines::DynamicEntityPipeline::Entities::DynamicModel3D
    headers: [ AllegroFlare/GraphicsPipelines/DynamicEntityPipeline/Entities/DynamicModel3D.hpp ]
  - symbol: AllegroFlare::Shaders::Cubemap
    headers: [ AllegroFlare/Shaders/Cubemap.hpp ]
  - symbol: ALLEGRO_BITMAP
    headers: [ allegro5/allegro.h ]


