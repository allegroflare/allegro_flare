properties:


  - name: environment
    type: std::string
    constructor_arg: true
    init_with: ENVIRONMENT_UNDEF
    getter: true

  - name: ENVIRONMENT_UNDEF
    type: char*
    init_with: '(char*)"undefined"'
    static: true
    constexpr: true

  - name: ENVIRONMENT_TEST
    type: char*
    init_with: '(char*)"test"'
    static: true
    constexpr: true

  - name: ENVIRONMENT_DEVELOPMENT
    type: char*
    init_with: '(char*)"development"'
    static: true
    constexpr: true

  - name: ENVIRONMENT_DEMO
    type: char*
    init_with: '(char*)"demo"'
    static: true
    constexpr: true

  - name: ENVIRONMENT_PRODUCTION
    type: char*
    init_with: '(char*)"production"'
    static: true
    constexpr: true


functions:


  - name: set_environment
    parameters:
      - name: environment
        type: std::string
        default_argument: ENVIRONMENT_UNDEF
    guards: [ _is_valid(environment) ]
    body: |
      // TODO: If an invalid argument is passed, include the argument value in an error message
      this->environment = environment;
      return;


  - name: is_undefined
    type: bool
    body: |
      return environment == ENVIRONMENT_UNDEF;


  - name: is_production
    type: bool
    body: |
      return environment == ENVIRONMENT_PRODUCTION;


  - name: is_test
    type: bool
    body: |
      return environment == ENVIRONMENT_TEST;


  - name: is_demo
    type: bool
    body: |
      return environment == ENVIRONMENT_DEMO;


  - name: is_development
    type: bool
    body: |
      return environment == ENVIRONMENT_DEVELOPMENT;


  - name: environment_should_set_path_to_resources_path
    type: bool
    body: |
      return environment == ENVIRONMENT_PRODUCTION;


  - name: _is_valid
    type: bool
    parameters:
      - name: environment
        type: std::string
        default_argument: '"[unset-environment]"'
    body: |
      // TODO: Require a param, and do not have a default
      static std::set<std::string> valid_environments = {
         ENVIRONMENT_PRODUCTION,
         ENVIRONMENT_TEST,
         ENVIRONMENT_DEMO,
         ENVIRONMENT_DEVELOPMENT,
      };
      // NOTE: Should consider an update to -std=c++20 eventually, which has  for a std::set
      // https://en.cppreference.com/w/cpp/container/set/contains

      // DEBUG:

      return valid_environments.find(environment) != valid_environments.end();
    body_dependency_symbols:
      - std::set


  - name: is_valid
    type: bool
    body: |
      static std::set<std::string> valid_environments = {
         ENVIRONMENT_PRODUCTION,
         ENVIRONMENT_TEST,
         ENVIRONMENT_DEMO,
         ENVIRONMENT_DEVELOPMENT,
      };
      // NOTE: Should consider an update to -std=c++20 eventually, which has `contains` for a std::set
      // https://en.cppreference.com/w/cpp/container/set/contains

      // DEBUG:

      return valid_environments.find(environment) != valid_environments.end();
    body_dependency_symbols:
      - std::set


  - name: is_invalid
    type: bool
    body: |
      return !is_valid();


  - name: get_data_folder_path
    type: std::string
    guards: [ is_valid() ]
    body: |
      if (environment == ENVIRONMENT_TEST)
      {
         return "./tests/fixtures/";
      }
      else if (environment == ENVIRONMENT_DEVELOPMENT || environment == ENVIRONMENT_DEMO)
      {
         return "./bin/data/";
      }
      else if (environment == ENVIRONMENT_PRODUCTION)
      {
         // NOTE: With the production environment, it's expected to have the executable set the path. The data folder
         // will be the "./data" folder that is relative to that.
         return "./data/";
      }
      else
      {
         AllegroFlare::Logger::throw_error("AllegroFlare::DeploymentEnvironment::get_base_data_path",
               "Unexpected error occurred where a path was requested on an invalid deployment environment."
               + AllegroFlare::Logger::build_unhandled_case_message(environment)
            );
      }
      return "";
    body_dependency_symbols:
      - AllegroFlare::Logger


dependencies:


  - symbol: AllegroFlare::Logger
    headers: [ AllegroFlare/Logger.hpp ]


