parent_classes:


  - class: AllegroFlare::YAMLValidator
    scope: public
    init_with: ''


documentation:


  - notes:
      - header: Schema
        body_markdown: |
          ```yaml
          - speaker:
            pages:
              - "Foobar, boobaz!"
              - "Donkin, Dankin!"
            options:
              - type: go_to_node
                data:
                  - 
          ```
      - header: Validations
        body_markdown: |
          - must have 'speaker'
          - must have 'pages'
          - optional 'options'
          - speaker must not be blank
          - pages must not be empty
          - pages must be array
          - each pages element must be scalar
          - each pages element must not be blank or whitespace
          - options must be array
          - each option element must have 'type'
          - each option element must have 'data'


properties:


  - name: node_bank
    type: AllegroFlare::DialogTree::NodeBank
    init_with: '{}'
    getter: false
    setter: false
    getter_ref: false

  - name: SPEAKER_KEY
    type: char*
    constexpr: true
    static: true
    const: true
    init_with: '(char*)"speaker"'

  - name: PAGES_KEY
    type: char*
    constexpr: true
    static: true
    const: true
    init_with: '(char*)"pages"'

  - name: OPTIONS_KEY
    type: char*
    constexpr: true
    static: true
    const: true
    init_with: '(char*)"options"'

  - name: TEXT_KEY
    type: char*
    constexpr: true
    static: true
    const: true
    init_with: '(char*)"text"'

  - name: TYPE_KEY
    type: char*
    constexpr: true
    static: true
    const: true
    init_with: '(char*)"type"'

  - name: DATA_KEY
    type: char*
    constexpr: true
    static: true
    const: true
    init_with: '(char*)"data"'

  - name: OPTION_TYPE_NODE_KEY
    type: char*
    constexpr: true
    static: true
    const: true
    init_with: '(char*)"node"'

  - name: OPTION_TYPE_GO_TO_NODE_KEY
    type: char*
    constexpr: true
    static: true
    const: true
    init_with: '(char*)"go_to_node"'

  - name: OPTION_TYPE_EXIT_DIALOG_KEY
    type: char*
    constexpr: true
    static: true
    const: true
    init_with: '(char*)"exit_dialog"'

  - name: OPTION_DATA_TARGET_NODE_NAME_KEY
    type: char*
    constexpr: true
    static: true
    const: true
    init_with: '(char*)"target_node_name"'

  - name: loaded
    type: bool
    init_with: false


functions:


  - name: load
    type: AllegroFlare::DialogTree::NodeBank
    parameters:
      - name: yaml_as_string
        type: std::string
        default_argument: '"[unset-yaml_as_string]"'
    guards: [ (!loaded) ]
    body: |
      AllegroFlare::DialogTree::NodeBank result;
      YAML::Node root_node = YAML::Load(yaml_as_string);

      // TODO: Traverse the nodes, load as nodes

      // Insure the class has been loaded
      loaded = true;

      // Return our result
      return result;
    body_dependency_symbols:
      - std::make_pair
      - AllegroFlare::Logger
      - AllegroFlare::DialogTree::NodeOptions::Base


  - name: parse_and_create_node
    type: std::pair<std::string, AllegroFlare::DialogTree::Node*>
    parameters:
      - name: node_ptr
        type: YAML::Node*
        default_argument: nullptr
    body: |
      YAML::Node &root_node = *node_ptr; // TODO: Rename "root_node" to "node"
      AllegroFlare::DialogTree::Node *result = new AllegroFlare::DialogTree::Node;

      // Validate and extract the speaker
      validate_presence_of_key(root_node, SPEAKER_KEY);
      validate_node_type(root_node, SPEAKER_KEY, YAML::NodeType::Scalar);
      std::string speaker = root_node[std::string(SPEAKER_KEY)].as<std::string>();
      result->set_speaker(speaker);

      // Validate and extract the pages
      validate_presence_of_key(root_node, PAGES_KEY);
      validate_node_type(root_node, PAGES_KEY, YAML::NodeType::Sequence);
      YAML::Node pages_node = root_node[std::string(PAGES_KEY)];
      std::vector<std::string> pages_vector;
      for (const auto& node : pages_node)
      {
         if (node.IsScalar())
         {
            pages_vector.push_back(node.as<std::string>());
         }
         else
         {
            // TODO: Improve this error message
            // TODO: Test this error path
            AllegroFlare::Logger::throw_error("here", "pages node contains a non-scalar element");
         }
      }
      // TODO: Validate content of pages vector
      result->set_pages(pages_vector);

      // Validate and extract the options
      // TODO: "options" node is optional
      validate_presence_of_key(root_node, OPTIONS_KEY);
      validate_node_type(root_node, OPTIONS_KEY, YAML::NodeType::Sequence);
      YAML::Node options_node = root_node[std::string(OPTIONS_KEY)];
      std::vector<std::pair<std::string, AllegroFlare::DialogTree::NodeOptions::Base*>> options_vector;
      for (const auto& node : options_node)
      {
         std::string result_option_text = "[unset-result_text]";
         std::string result_option_type = "[unset-result_option_type]";
         AllegroFlare::DialogTree::NodeOptions::Base* result_option = nullptr;

         // Parse out option->text
         // TODO: Improve this error message
         validate_presence_of_key(node, TEXT_KEY);
         validate_node_type(node, TEXT_KEY, YAML::NodeType::Scalar);
         result_option_text = node[std::string(TEXT_KEY)].as<std::string>();

         // TODO: Parse out option->node type
         validate_presence_of_key(node, TYPE_KEY);
         validate_node_type(node, TYPE_KEY, YAML::NodeType::Scalar);
         std::string result_option_type_str = node[std::string(TYPE_KEY)].as<std::string>();
         YAML::Node result_option_data_node = node[std::string(DATA_KEY)];

         result_option = parse_and_create_result_option(result_option_type_str, &result_option_data_node);

         options_vector.push_back(std::make_pair(result_option_text, result_option));
      }
      result->set_options(options_vector);

      // Return the result
      return { "unnamed-node", result };
    body_dependency_symbols:
      - std::make_pair
      - AllegroFlare::Logger
      - AllegroFlare::DialogTree::NodeOptions::Base


  - name: parse_and_create_result_option
    type: AllegroFlare::DialogTree::NodeOptions::Base*
    parameters:
      - name: type
        type: std::string
        default_argument: '"[unset-type]"'
      - name: data_node_ptr
        type: YAML::Node*
        default_argument: nullptr
    guards: [ data_node_ptr ]
    body: |
      AllegroFlare::DialogTree::NodeOptions::Base* result = nullptr;

      std::map<std::string, std::function<void()>> result_options_map = {
         { OPTION_TYPE_EXIT_DIALOG_KEY, [this, &result]() mutable {
            result = parse_and_create_ExitDialog_option();
         }},
         { OPTION_TYPE_GO_TO_NODE_KEY, [this, &result, data_node_ptr](){
            result = parse_and_create_GoToNode_option(data_node_ptr);
         }},
         { OPTION_TYPE_NODE_KEY, [this, &result, data_node_ptr](){
            // NOTE: For now, option nodes do not have names. "name" is reserved for nodes on the root
            result = parse_and_create_Node_option(data_node_ptr);
         }},
      };

      // Locate and call the function to handle the item
      if (result_options_map.count(type) == 0)
      {
         // Item not found
         std::stringstream error_message;
         error_message << "[YamlLoader::parse_and_create_result_option]: error: Cannot create an option of a type \""
                       << type << "\". A declaration to handle that type does not exist.";
         throw std::runtime_error(error_message.str());
      }
      else
      {
         // Call the item
         result_options_map[type]();
      }

      return result;
    body_dependency_symbols:
      - AllegroFlare::DialogTree::NodeOptions::GoToNode
      - AllegroFlare::DialogTree::NodeOptions::ExitDialog


  - name: parse_and_create_ExitDialog_option
    type: AllegroFlare::DialogTree::NodeOptions::ExitDialog*
    body: |
      AllegroFlare::DialogTree::NodeOptions::ExitDialog* result =
         new AllegroFlare::DialogTree::NodeOptions::ExitDialog;
      return result;


  - name: parse_and_create_GoToNode_option
    type: AllegroFlare::DialogTree::NodeOptions::GoToNode*
    parameters:
      - name: data_node_ptr
        type: YAML::Node*
        default_argument: nullptr
    guards: [ data_node_ptr ]
    body: |
      YAML::Node &node = *data_node_ptr;
      AllegroFlare::DialogTree::NodeOptions::GoToNode* result = new AllegroFlare::DialogTree::NodeOptions::GoToNode;

      // Validate the data
      validate_presence_of_key(node, OPTION_DATA_TARGET_NODE_NAME_KEY);
      validate_node_type(node, OPTION_DATA_TARGET_NODE_NAME_KEY, YAML::NodeType::Scalar);
      std::string result_target_node_name = node[std::string(OPTION_DATA_TARGET_NODE_NAME_KEY)].as<std::string>();

      // Assign the data to the result
      result->set_target_node_name(result_target_node_name);

      // Return the result
      return result;


  - name: parse_and_create_Node_option
    type: AllegroFlare::DialogTree::NodeOptions::Node*
    parameters:
      - name: data_node_ptr
        type: YAML::Node*
        default_argument: nullptr
    guards: [ data_node_ptr ]
    body: |
      YAML::Node &node = *data_node_ptr;
      AllegroFlare::DialogTree::NodeOptions::Node* result = new AllegroFlare::DialogTree::NodeOptions::Node;

       
      std::pair<std::string, AllegroFlare::DialogTree::Node*> created_node_for_option =
         parse_and_create_node(&node);
      //std::string option_node_name = created_node_for_option.first; // NOTE: For now, option nodes do not have names
      AllegroFlare::DialogTree::Node* option_node = created_node_for_option.second;
      result->set_node(option_node);

      // Return the result
      return result;


dependencies:


  - symbol: std::make_pair
    headers: [ utility ]
  - symbol: AllegroFlare::YAMLValidator
    headers: [ AllegroFlare/YAMLValidator.hpp ]
  - symbol: AllegroFlare::DialogTree::Node
    headers: [ AllegroFlare/DialogTree/Node.hpp ]
  - symbol: AllegroFlare::Logger
    headers: [ AllegroFlare/Logger.hpp ]
  - symbol: AllegroFlare::DialogTree::NodeOptions::Base
    headers: [ AllegroFlare/DialogTree/NodeOptions/Base.hpp ]
  - symbol: AllegroFlare::DialogTree::NodeOptions::ExitDialog
    headers: [ AllegroFlare/DialogTree/NodeOptions/ExitDialog.hpp ]
  - symbol: AllegroFlare::DialogTree::NodeOptions::GoToNode
    headers: [ AllegroFlare/DialogTree/NodeOptions/GoToNode.hpp ]
  - symbol: AllegroFlare::DialogTree::NodeOptions::Node
    headers: [ AllegroFlare/DialogTree/NodeOptions/Node.hpp ]
  - symbol: YAML::Node
    headers: [ yaml-cpp/yaml.h ]
  - symbol: AllegroFlare::DialogTree::NodeBank
    headers: [ AllegroFlare/DialogTree/NodeBank.hpp ]


