parent_classes:


  - class: AllegroFlare::YAMLValidator
    scope: public
    init_with: ''


documentation:


  - notes:
      - header: Schema
        body_markdown: |
          ```yaml
          - speaker:
            pages:
              - "Foobar, boobaz!"
              - "Donkin, Dankin!"
            options:
              - type: go_to_node
                data:
                  - 
          ```
      - header: Validations
        body_markdown: |
          - must have 'speaker'
          - must have 'pages'
          - optional 'options'
          - speaker must not be blank
          - pages must not be empty
          - pages must be array
          - each pages element must be scalar
          - each pages element must not be blank or whitespace
          - options must be array
          - each option element must have 'type'
          - each option element must have 'data'


properties:


  - name: SPEAKER_KEY
    type: char*
    constexpr: true
    static: true
    const: true
    init_with: '(char*)"speaker"'

  - name: PAGES_KEY
    type: char*
    constexpr: true
    static: true
    const: true
    init_with: '(char*)"pages"'

  - name: OPTIONS_KEY
    type: char*
    constexpr: true
    static: true
    const: true
    init_with: '(char*)"options"'

  - name: TEXT_KEY
    type: char*
    constexpr: true
    static: true
    const: true
    init_with: '(char*)"text"'

  - name: TYPE_KEY
    type: char*
    constexpr: true
    static: true
    const: true
    init_with: '(char*)"type"'

  - name: DATA_KEY
    type: char*
    constexpr: true
    static: true
    const: true
    init_with: '(char*)"data"'

  - name: OPTION_TYPE_GO_TO_NODE_KEY
    type: char*
    constexpr: true
    static: true
    const: true
    init_with: '(char*)"go_to_node"'

  - name: OPTION_TYPE_EXIT_DIALOG_KEY
    type: char*
    constexpr: true
    static: true
    const: true
    init_with: '(char*)"exit_dialog"'


functions:


  - name: load
    type: AllegroFlare::DialogTree::Node*
    parameters:
      - name: yaml_as_string
        type: std::string
        default_argument: '""'
    body: |
      YAML::Node root_node = YAML::Load(yaml_as_string);
      AllegroFlare::DialogTree::Node *result = new AllegroFlare::DialogTree::Node;

      // Validate and extract the speaker
      validate_presence_of_key(root_node, SPEAKER_KEY);
      validate_node_type(root_node, SPEAKER_KEY, YAML::NodeType::Scalar);
      std::string speaker = root_node[std::string(SPEAKER_KEY)].as<std::string>();
      result->set_speaker(speaker);

      // Validate and extract the pages
      validate_presence_of_key(root_node, PAGES_KEY);
      validate_node_type(root_node, PAGES_KEY, YAML::NodeType::Sequence);
      YAML::Node pages_node = root_node[std::string(PAGES_KEY)];
      std::vector<std::string> pages_vector;
      for (const auto& node : pages_node)
      {
         if (node.IsScalar())
         {
            pages_vector.push_back(node.as<std::string>());
         }
         else
         {
            // TODO: Improve this error message
            // TODO: Test this error path
            AllegroFlare::Logger::throw_error("here", "pages node contains a non-scalar element");
         }
      }
      // TODO: Validate content of pages vector
      result->set_pages(pages_vector);

      // Validate and extract the options
      // TODO: "options" node is optional
      validate_presence_of_key(root_node, OPTIONS_KEY);
      validate_node_type(root_node, OPTIONS_KEY, YAML::NodeType::Sequence);
      YAML::Node options_node = root_node[std::string(OPTIONS_KEY)];
      std::vector<std::pair<std::string, AllegroFlare::DialogTree::NodeOptions::Base*>> options_vector;
      for (const auto& node : options_node)
      {
         std::string result_option_text = "[unset-result_text]";
         std::string result_option_type = "[unset-result_option_type]";
         AllegroFlare::DialogTree::NodeOptions::Base* result_option = nullptr;

         // Parse out option->text
         // TODO: Improve this error message
         validate_presence_of_key(node, TEXT_KEY);
         validate_node_type(node, TEXT_KEY, YAML::NodeType::Scalar);
         result_option_text = node[std::string(TEXT_KEY)].as<std::string>();

         // TODO: Parse out option->node type
         validate_presence_of_key(node, TYPE_KEY);
         validate_node_type(node, TYPE_KEY, YAML::NodeType::Scalar);
         std::string result_option_type_str = node[std::string(TYPE_KEY)].as<std::string>();
         YAML::Node result_option_data_node = node[std::string(DATA_KEY)];

         result_option = parse_and_create_result_option(result_option_type_str, &result_option_data_node);

         options_vector.push_back(std::make_pair(result_option_text, result_option));
      }
      result->set_options(options_vector);

      // Return our result
      return result;
    body_dependency_symbols:
      - std::make_pair
      - AllegroFlare::Logger
      - AllegroFlare::DialogTree::NodeOptions::Base


  - name: parse_and_create_result_option
    type: AllegroFlare::DialogTree::NodeOptions::Base*
    parameters:
      - name: type
        type: std::string
        default_argument: '"[unset-type]"'
      - name: data_node_ptr
        type: YAML::Node*
        default_argument: nullptr
    guards: [ data_node_ptr ]
    body: |
      AllegroFlare::DialogTree::NodeOptions::Base* result = nullptr;

      std::map<std::string, std::function<void()>> result_options_map = {
         { OPTION_TYPE_EXIT_DIALOG_KEY, [this, &result]() mutable {
            AllegroFlare::DialogTree::NodeOptions::ExitDialog* exit_dialog_result =
               new AllegroFlare::DialogTree::NodeOptions::ExitDialog;
            result = exit_dialog_result;
         }},
         { OPTION_TYPE_GO_TO_NODE_KEY, [this, &result](){
            AllegroFlare::DialogTree::NodeOptions::GoToNode* go_to_node_result =
               new AllegroFlare::DialogTree::NodeOptions::GoToNode;
            // TODO: parse the "target_node_name" and assign to "go_to_node_result"
            go_to_node_result->set_target_node_name("foobar");
            result = go_to_node_result;
         }},
      };

      // Locate and call the function to handle the item
      if (result_options_map.count(type) == 0)
      {
         // Item not found
         std::stringstream error_message;
         error_message << "[YamlLoader::parse_and_create_result_option]: error: Cannot create an option of a type \""
                       << type << "\". A declaration to handle that type does not exist.";
         throw std::runtime_error(error_message.str());
      }
      else
      {
         // Call the item
         result_options_map[type]();
      }

      return result;
    body_dependency_symbols:
      - AllegroFlare::DialogTree::NodeOptions::GoToNode
      - AllegroFlare::DialogTree::NodeOptions::ExitDialog


dependencies:


  - symbol: std::make_pair
    headers: [ utility ]
  - symbol: AllegroFlare::YAMLValidator
    headers: [ AllegroFlare/YAMLValidator.hpp ]
  - symbol: AllegroFlare::DialogTree::Node
    headers: [ AllegroFlare/DialogTree/Node.hpp ]
  - symbol: AllegroFlare::Logger
    headers: [ AllegroFlare/Logger.hpp ]
  - symbol: AllegroFlare::DialogTree::NodeOptions::Base
    headers: [ AllegroFlare/DialogTree/NodeOptions/Base.hpp ]
  - symbol: AllegroFlare::DialogTree::NodeOptions::ExitDialog
    headers: [ AllegroFlare/DialogTree/NodeOptions/ExitDialog.hpp ]
  - symbol: AllegroFlare::DialogTree::NodeOptions::GoToNode
    headers: [ AllegroFlare/DialogTree/NodeOptions/GoToNode.hpp ]
  - symbol: YAML::Node
    headers: [ yaml-cpp/yaml.h ]


