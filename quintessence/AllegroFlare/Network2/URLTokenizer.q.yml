properties:


  - name: full_url
    type: std::string
    init_with: '"[unset-full_url]"'
    constructor_arg: true
    getter: true
    setter: true


functions:


  - name: extract_port
    type: std::string
    body: |
      return split_tokens().second;


  - name: extract_host
    type: std::string
    body: |
      return split_tokens().first;


  - name: split_tokens
    type: std::pair<std::string, std::string>
    private: true
    body: |
      std::pair<std::string, std::string> result;

      std::size_t length_of_prefix = 6;

      if (full_url.substr(0, length_of_prefix) != "tcp://")
      {
         throw std::runtime_error("Network2::URLTokenizer: invalid url format (error 1)");
      }

      std::size_t pos_of_port_start = full_url.find_first_of(":", length_of_prefix);
      if (pos_of_port_start == std::string::npos)
      {
         throw std::runtime_error("Network2::URLTokenizer: invalid url format (error 2)");
      }

      // strip off the port number
      result.second = full_url.substr(pos_of_port_start+1);

      // strip off tcp prefix:
      std::string subresult = full_url.substr(0, pos_of_port_start);
      result.first = subresult.substr(6);

      if (!(has_min_length(result.second, 1)))
      {
         throw std::runtime_error("Network2::URLTokenizer: invalid url format (error 3)");
      }
      
      if (!(has_min_length(result.second, 4)))
      {
         throw std::runtime_error("Network2::URLTokenizer: invalid url format (error 4)");
      }
      
      return result;


  - name: has_min_length
    type: bool
    private: true
    static: true
    parameters:
      - name: string
        type: std::string
        default_argument: '""'
      - name: min
        type: int
        default_argument: 0
    body: |
      return (string.length() >= min);


  - name: trim
    type: std::string
    private: true
    static: true
    parameters:
      - name: s
        type: std::string
        default_argument: '""'
    body: |
      // ltrim
      s.erase(s.begin(), std::find_if(s.begin(), s.end(), [](int c) {return !std::isspace(c);}));
      // rtrim
      s.erase(std::find_if(s.rbegin(), s.rend(), [](int c) {return !std::isspace(c);}).base(), s.end());
      return s;
    


