parent_classes:


  - class: AllegroFlare::Screens::Base
    scope: public
    init_with: AllegroFlare::Runners::Complete::TYPE


properties:


  - name: framework
    type: AllegroFlare::Frameworks::Full*
    init_with: nullptr
    constructor_arg: true
    getter: true

  - name: event_emitter
    type: AllegroFlare::EventEmitter*
    init_with: nullptr
    constructor_arg: true
    getter: true

  - name: bitmap_bin
    type: AllegroFlare::BitmapBin*
    init_with: nullptr
    constructor_arg: true
    getter: true

  - name: font_bin
    type: AllegroFlare::FontBin*
    init_with: nullptr
    constructor_arg: true
    getter: true

  - name: sample_bin
    type: AllegroFlare::SampleBin*
    init_with: nullptr
    constructor_arg: true
    getter: true

  - name: model_bin
    type: AllegroFlare::ModelBin*
    init_with: nullptr
    constructor_arg: true
    getter: true

  - name: game_configuration
    type: AllegroFlare::GameConfigurations::Complete*
    init_with: nullptr
    constructor_arg: true

  - name: router
    type: AllegroFlare::Routers::Standard
    init_with: ''

  - name: saving_and_loading
    type: AllegroFlare::SavingAndLoading::SavingAndLoading
    init_with: ''
    getter_ref: true

  - name: current_save_profile_id
    type: int
    init_with: 0
    getter: explicit
    setter: explicit

  - name: current_manual_save_slot_position
    type: int
    init_with: 0
    getter: explicit
    setter: explicit

  - name: intro_logos_screen
    type: AllegroFlare::Screens::Storyboard
    init_with: ''
    getter_ref: true

  - name: intro_storyboard_screen
    type: AllegroFlare::Screens::Storyboard
    init_with: ''
    getter_ref: true

  - name: title_screen
    type: AllegroFlare::Screens::TitledMenuScreen
    init_with: ''
    getter_ref: true

  - name: display_settings_screen
    type: AllegroFlare::Screens::DisplaySettings
    init_with: ''
    getter_ref: true

  - name: achievements_screen
    type: AllegroFlare::Screens::Achievements
    init_with: ''
    getter_ref: true

  - name: version_screen
    type: AllegroFlare::Screens::Version
    init_with: ''
    getter_ref: true

  - name: load_a_saved_game_screen
    type: AllegroFlare::LoadASavedGame::Screen
    init_with: ''
    getter_ref: true

  - name: saving_and_loading_screen
    type: AllegroFlare::SavingAndLoading::Screen
    init_with: ''
    getter_ref: true

  - name: new_game_intro_storyboard_screen
    type: AllegroFlare::Screens::Storyboard
    init_with: ''
    getter_ref: true

  - name: level_select_screen
    type: AllegroFlare::Screens::LevelSelectScreen
    init_with: ''
    getter_ref: true

  - name: arbitrary_storyboard_screen
    type: AllegroFlare::Screens::Storyboard
    init_with: ''
    getter_ref: true

  - name: game_over_screen
    type: AllegroFlare::Screens::GameOverScreen
    init_with: ''
    getter_ref: true

  - name: game_won_screen
    type: AllegroFlare::Screens::GameWonScreen
    init_with: ''
    getter_ref: true

  - name: game_won_outro_storyboard_screen
    type: AllegroFlare::Screens::Storyboard
    init_with: ''
    getter_ref: true

  - name: settings_screen
    type: AllegroFlare::Screens::SettingsScreen
    init_with: ''
    getter_ref: true

  - name: rolling_credits_screen
    type: AllegroFlare::Screens::RollingCredits
    init_with: ''
    getter_ref: true

  - name: primary_gameplay_screen
    type: AllegroFlare::Screens::Gameplay*
    init_with: nullptr

  - name: primary_gameplay_subscreen
    type: AllegroFlare::Screens::Subscreen::Screen*
    init_with: nullptr

  - name: pause_screen
    type: AllegroFlare::Screens::Base*
    init_with: nullptr

  - name: shared_background
    type: AllegroFlare::Elements::Backgrounds::Base*
    init_with: nullptr

  - name: shared_foreground
    type: AllegroFlare::Elements::Backgrounds::Base*
    init_with: nullptr

  - name: release_info
    type: ReleaseInfo
    init_with: '{}'

  - name: initialized
    type: bool
    init_with: false

  - name: destroyed
    type: bool
    init_with: false

  - name: MY_ROUTE_EVENT_ACTIVATE_MY_CUSTOM_SCREEN
    type: uint32_t
    init_with: AllegroFlare::Routers::Standard::EVENT_LAST_EVENT+1
    static: true
    constexpr: true

  - name: MY_CUSTOM_SCREEN_IDENTIFIER
    type: char*
    init_with: '(char*)"my_custom_screen"'
    static: true
    constexpr: true

  - name: TYPE
    type: char*
    init_with: '(char*)"AllegroFlare/Runners/Complete"'
    static: true
    constexpr: true


documentation:


  - notes:
      - This class is a screen who's primary function is to initialize the primary framework; create the primary
        game system screens; delegate to a configuration to create gameplay screens; own, and deallocate the screens
        of the game system; and pass along game events to the user's game_configuration.


methods:


  - name: game_event_func
    virtual: true
    override: true
    parameters:
      - name: game_event
        type: AllegroFlare::GameEvent*
        default_argument: nullptr
        default_argument_dependency_symbols:
          - AllegroFlare::ForwardDeclarations::AllegroFlare::Runners::Complete
          - AllegroFlare::ForwardDeclarations::AllegroFlare::GameConfigurations::Complete
    guards: [ game_event ]
    body: |
      // TODO: See if this have "guards: [ initialized, (!destroyed) ]" as well?
      game_configuration->handle_game_event(game_event);
      return;


  - name: initialize
    guards:
      - (!initialized)
      - (!destroyed)
      - framework
      - event_emitter
      - bitmap_bin
      - font_bin
      - sample_bin
      - model_bin
      - game_configuration
    body: |
      // Create some references for convenience
      AllegroFlare::Achievements &achievements = framework->get_achievements_ref();
      AllegroFlare::AudioController &audio_controller = framework->get_audio_controller_ref();
      std::string data_folder_path = get_framework()->get_data_folder_path();

      // Pass along this runner into the configuration (for convenience)
      // TODO: Review this as a design concept, should the dependencies in game_configuration be more explicit
      game_configuration->set_runner(this);

      // Setup the saving and loading system
      // TODO: Should this be moved to framework? (maybe not, because the number of save slots is configured
      // by the game);
      saving_and_loading.set_data_folder_path(data_folder_path);
      saving_and_loading.set_num_profiles(game_configuration->get_num_save_profiles());
      saving_and_loading.set_num_manual_save_slots(game_configuration->get_num_manual_save_slots());
      saving_and_loading.set_num_autosave_save_slots(game_configuration->get_num_autosave_save_slots());
      saving_and_loading.set_num_quicksave_save_slots(game_configuration->get_num_quicksave_save_slots());
      saving_and_loading.initialize();
      saving_and_loading.create_save_file_directories_if_they_do_not_exist();
      saving_and_loading.scan_for_existing_save_files_and_load_header_data();
      set_current_save_profile_id(1); // TODO: Eventually, have this automatically loaded at start time
      set_current_manual_save_slot_position(1); // TODO: Eventually, have this automataically loaded at start time

      // Create the shared background
      shared_background = game_configuration->create_shared_background();
      shared_foreground = game_configuration->create_shared_foreground();

      // Create the primary_gameplay_screen
      primary_gameplay_screen = game_configuration->create_primary_gameplay_screen(this);

      // Create the primary_gameplay_screen
      primary_gameplay_subscreen = game_configuration->create_primary_gameplay_subscreen(this);

      // Create the pause_screen
      pause_screen = game_configuration->create_pause_screen(this);

      // Setup our router
      setup_router();

      // Set the framework to use the router we've created here
      framework->set_router(&router);

      // Fill our dialog bank
      framework->set_dialog_system_dialog_node_bank(game_configuration->build_dialog_bank_by_identifier());

      // Setup achievements
      achievements.set_achievements(game_configuration->build_achievements());

      // Setup intro logos screen (if empty, will simply be skipped)
      intro_logos_screen.set_event_emitter(event_emitter);
      intro_logos_screen.set_font_bin(font_bin);
      intro_logos_screen.set_auto_advance(true);
      intro_logos_screen.set_foreground(shared_foreground);
      intro_logos_screen.set_background(shared_background);
      intro_logos_screen.initialize();
      intro_logos_screen.get_storyboard_element_ref().set_pages(
         game_configuration->create_intro_logos_storyboard_pages()
      );

      // Setup intro storyboard screen (if empty, will simply be skipped)
      intro_storyboard_screen.set_event_emitter(event_emitter);
      intro_storyboard_screen.set_font_bin(font_bin);
      intro_storyboard_screen.set_auto_advance(true);
      intro_storyboard_screen.set_foreground(shared_foreground);
      intro_storyboard_screen.set_background(shared_background);
      intro_storyboard_screen.initialize();
      intro_storyboard_screen.get_storyboard_element_ref().set_pages(
         game_configuration->create_intro_storyboard_pages()
      );

      // Setup title screen
      title_screen.set_data_folder_path(data_folder_path);
      title_screen.set_title_text(game_configuration->title_screen_title());
      title_screen.set_footer_text(game_configuration->build_copyright_text(&release_info));
      title_screen.set_menu_options(game_configuration->build_title_screen_menu_options());
      //{
         //{ "Start new game", "start_new_game" }, // NOTE: This value is a constant expected by Routers/Complete
         //{ "Load a saved game", "goto_load_a_saved_game_screen" }, // NOTE: This value is a constant expected by Routers/Complete
         //{ "Credits", "goto_credits_screen" }, // NOTE: This value is a constant expected by Routers/Complete
         //{ "Exit", "quit" } // NOTE: This value is a constant expected by Routers/Complete
      //});
      title_screen.set_menu_font_name("RobotoCondensed-Regular.ttf");
      title_screen.set_foreground(shared_foreground);
      title_screen.set_background(shared_background);
      title_screen.initialize();

      // Setup the display settings screen
      display_settings_screen.set_event_emitter(event_emitter);
      display_settings_screen.set_bitmap_bin(bitmap_bin);
      display_settings_screen.set_font_bin(font_bin);
      display_settings_screen.set_model_bin(model_bin);
      display_settings_screen.set_display_settings_interface(framework->get_display_settings_interface());
      display_settings_screen.set_label_for_menu_option_to_exit_screen("Return to Title Screen");
      display_settings_screen.set_foreground(shared_foreground);
      display_settings_screen.set_background(shared_background);
      display_settings_screen.initialize();

      // Setup achievements screen
      achievements_screen.set_achievements(&achievements);
      achievements_screen.set_event_emitter(event_emitter);
      achievements_screen.set_font_bin(font_bin);
      achievements_screen.set_foreground(shared_foreground);
      achievements_screen.set_background(shared_background);
      achievements_screen.initialize();

      // Setup version screen
      version_screen.set_bitmap_bin(bitmap_bin);
      version_screen.set_font_bin(font_bin);
      version_screen.set_model_bin(model_bin);
      version_screen.set_event_emitter(event_emitter);
      version_screen.set_foreground(shared_foreground);
      version_screen.set_background(shared_background);
      version_screen.initialize();

      // Setup new game intro storyboard screen
      new_game_intro_storyboard_screen.set_event_emitter(event_emitter);
      new_game_intro_storyboard_screen.set_font_bin(font_bin);
      new_game_intro_storyboard_screen.set_foreground(shared_foreground);
      new_game_intro_storyboard_screen.set_background(shared_background);
      new_game_intro_storyboard_screen.initialize();
      new_game_intro_storyboard_screen.get_storyboard_element_ref().set_pages(
         game_configuration->create_new_game_intro_storyboard_pages()
      );

      // Setup arbitrary storyboard screen
      arbitrary_storyboard_screen.set_event_emitter(event_emitter);
      arbitrary_storyboard_screen.set_font_bin(font_bin);
      //arbitrary_storyboard_screen.set_auto_advance(true); // TODO: This was recently changed to false by default
      arbitrary_storyboard_screen.set_foreground(shared_foreground);
      arbitrary_storyboard_screen.set_background(shared_background);
      arbitrary_storyboard_screen.initialize();
      //arbitrary_storyboard_screen.get_storyboard_element_ref().set_pages(
         //game_configuration->create_intro_storyboard_pages()
      //);

      // Setup load a saved game screen
      load_a_saved_game_screen.set_data_folder_path(data_folder_path);
      //load_a_saved_game_screen.set_event_emitter(event_emitter);
      //load_a_saved_game_screen.set_bitmap_bin(bitmap_bin);
      //load_a_saved_game_screen.set_font_bin(font_bin);
      //load_a_saved_game_screen.set_model_bin(model_bin); // Currently not used, but required
      load_a_saved_game_screen.set_foreground(shared_foreground);
      load_a_saved_game_screen.set_background(shared_background);
      load_a_saved_game_screen.set_save_slots(game_configuration->build_save_slots_for_load_a_saved_game_screen());
      load_a_saved_game_screen.initialize();

      // Setup saving and loading screen
      saving_and_loading_screen.set_data_folder_path(data_folder_path);
      //load_a_saved_game_screen.set_event_emitter(event_emitter);
      //load_a_saved_game_screen.set_bitmap_bin(bitmap_bin);
      //load_a_saved_game_screen.set_font_bin(font_bin);
      //load_a_saved_game_screen.set_model_bin(model_bin); // Currently not used, but required
      saving_and_loading_screen.set_foreground(shared_foreground);
      saving_and_loading_screen.set_background(shared_background);
      saving_and_loading_screen.set_saving_and_loading(&saving_and_loading);
      saving_and_loading_screen.set_mode(
            AllegroFlare::SavingAndLoading::Screen::MODE_USER_CAN_CHOOSE_POPULATED_SLOT_OR_EMPTY_SLOT
         );
      saving_and_loading_screen.initialize();

      // TODO: Setup level select screen
      level_select_screen.set_event_emitter(event_emitter);
      level_select_screen.set_bitmap_bin(bitmap_bin);
      level_select_screen.set_font_bin(font_bin);
      level_select_screen.set_levels_list(
         // NOTE: if this list is empty, then the screen will automatically submit on activate
         game_configuration->build_level_list_for_level_select_screen_by_identifier("discarded-for-now")
      );
      level_select_screen.set_locked_list(
         game_configuration->build_locked_list_for_level_select_screen()
      );
      level_select_screen.set_foreground(shared_foreground);
      level_select_screen.set_background(shared_background);
      level_select_screen.initialize();

      // TODO: Setup game over screen
      game_over_screen.set_event_emitter(event_emitter);
      game_over_screen.set_font_bin(font_bin);
      game_over_screen.set_foreground(shared_foreground);
      game_over_screen.set_background(shared_background);
      game_over_screen.initialize();

      // Setup game won screen
      game_won_screen.set_font_bin(font_bin);
      game_won_screen.set_foreground(shared_foreground);
      game_won_screen.set_background(shared_background);
      //game_won_screen.initialize(); // NOTE: Initialization is not necessary for this screen

      // Setup game won outro storyboard screen
      game_won_outro_storyboard_screen.set_event_emitter(event_emitter);
      game_won_outro_storyboard_screen.set_foreground(shared_foreground);
      game_won_outro_storyboard_screen.set_background(shared_background);
      game_won_outro_storyboard_screen.initialize();

      // Setup the settings screen
      settings_screen.set_event_emitter(event_emitter); // TODO: See if this is necessary
      settings_screen.set_bitmap_bin(bitmap_bin); // Currently not used, but required
      settings_screen.set_font_bin(font_bin);
      settings_screen.set_model_bin(model_bin); // Currently not used, but required
      settings_screen.set_foreground(shared_foreground);
      settings_screen.set_background(shared_background);
      settings_screen.initialize();

      // Setup rolling credits screen
      rolling_credits_screen.set_event_emitter(event_emitter); // TODO: See if this is necessary
      rolling_credits_screen.set_font_bin(font_bin);
      rolling_credits_screen.set_foreground(shared_foreground);
      rolling_credits_screen.set_background(shared_background);
      rolling_credits_screen.set_sections(game_configuration->build_rolling_credits_sections());
      rolling_credits_screen.initialize();

      // Load up our sound effects and music tracks
      game_configuration->load_audio_controller(&framework->get_audio_controller_ref());

      // A free-for-all, "post-initialization" method for the configuration. This is useful, for example, for tweaking
      // the styling of the dialog system, making customizations to any of the standard screens, etc.
      game_configuration->on_runner_after_initialization_func(this);

      initialized = true;

      return;
    body_dependency_symbols:
      - AllegroFlare::Elements::Backgrounds::ClearToColor
      - AllegroFlare::StoryboardFactory
      - AllegroFlare::Color
      - AllegroFlare::LoadASavedGame::SaveSlots::Empty
      - AllegroFlare::Screens::TitledMenuScreen


  - name: destroy
    virtual: true
    override: true
    guards: [ (!destroyed), initialized ]
    body: |
      game_configuration->destroy_primary_gameplay_screen();
      game_configuration->destroy_pause_screen();

      title_screen.destroy();
      load_a_saved_game_screen.destroy();
      saving_and_loading_screen.destroy(); // TODO: See if this is necessary
      // TODO: Add additional destroy virtual methods for each object created
      // TODO: Consider if this method should be virtual as well, or if game_configuration should have "destroy()"
      destroyed = true;
      return;


  - name: get_current_save_profile_id
    type: int
    guards: [ initialized ]
    body: |
      return current_save_profile_id;


  - name: set_current_save_profile_id
    parameters:
      - name: current_save_profile_id
        type: int
        default_argument: 1
    guards:
      - saving_and_loading.get_initialized()
      - (current_save_profile_id >= 1)
      - (current_save_profile_id <= saving_and_loading.get_num_profiles())
    body: |
      this->current_save_profile_id = current_save_profile_id;
      return;


  - name: get_current_manual_save_slot_position
    type: int
    guards: [ initialized ]
    body: |
      return current_manual_save_slot_position;


  - name: set_current_manual_save_slot_position
    parameters:
      - name: current_manual_save_slot_position
        type: int
        default_argument: 1
    guards:
      - saving_and_loading.get_initialized()
      - (current_manual_save_slot_position >= 1)
      - (current_manual_save_slot_position <= saving_and_loading.get_num_profiles())
    body: |
      this->current_manual_save_slot_position = current_manual_save_slot_position;
      return;


  - name: on_route_event_unhandled_func
    type: bool
    static: true
    parameters:
      - name: unhandled_event
        type: uint32_t
        default_argument: 0
      - name: router
        type: AllegroFlare::Routers::Standard*
        default_argument: nullptr
      - name: user_data
        type: void*
        default_argument: nullptr
    guards: [ router, user_data ]
    body: |
      // TODO: Consider removing this method and having all Routers/Standard events be internal
      AllegroFlare::Runners::Complete* this_runner = static_cast<AllegroFlare::Runners::Complete*>(user_data);

      bool handled = false;

      switch(unhandled_event)
      {
         //case MY_ROUTE_EVENT_ACTIVATE_MY_CUSTOM_SCREEN:
            //router->activate_screen(MY_CUSTOM_SCREEN_IDENTIFIER);
            //handled = true;
         //break;
      }

      return handled;


  - name: on_gameplay_paused_func
    type: bool
    static: true
    parameters:
      - name: router
        type: AllegroFlare::Routers::Standard*
        default_argument: nullptr
      - name: user_data
        type: void*
        default_argument: nullptr
    guards: [ router, user_data ]
    body: |
      AllegroFlare::Runners::Complete* this_runner = static_cast<AllegroFlare::Runners::Complete*>(user_data);
      this_runner->game_configuration->handle_primary_gameplay_screen_paused();
      return true;


  - name: on_gameplay_unpaused_func
    type: bool
    static: true
    parameters:
      - name: router
        type: AllegroFlare::Routers::Standard*
        default_argument: nullptr
      - name: user_data
        type: void*
        default_argument: nullptr
    guards: [ router, user_data ]
    body: |
      AllegroFlare::Runners::Complete* this_runner = static_cast<AllegroFlare::Runners::Complete*>(user_data);
      this_runner->game_configuration->handle_primary_gameplay_screen_unpaused();
      return true;


  - name: on_primary_gameplay_screen_finished_func
    type: bool
    static: true
    parameters:
      - name: router
        type: AllegroFlare::Routers::Standard*
        default_argument: nullptr
      - name: user_data
        type: void*
        default_argument: nullptr
    guards: [ router, user_data ]
    body: |
      AllegroFlare::Runners::Complete* this_runner = static_cast<AllegroFlare::Runners::Complete*>(user_data);
      this_runner->game_configuration->handle_primary_gameplay_screen_finished();
      return true;


  - name: on_arbitrary_storyboard_screen_finished_func
    type: bool
    static: true
    parameters:
      - name: router
        type: AllegroFlare::Routers::Standard*
        default_argument: nullptr
      - name: user_data
        type: void*
        default_argument: nullptr
    guards: [ router, user_data ]
    body: |
      AllegroFlare::Runners::Complete* this_runner = static_cast<AllegroFlare::Runners::Complete*>(user_data);
      this_runner->game_configuration->handle_arbitrary_storyboard_screen_finished();
      return true;


  - name: on_arbitrary_storyboard_screen_activated_func
    type: bool
    static: true
    parameters:
      - name: router
        type: AllegroFlare::Routers::Standard*
        default_argument: nullptr
      - name: user_data
        type: void*
        default_argument: nullptr
    guards: [ router, user_data ]
    body: |
      AllegroFlare::Runners::Complete* this_runner = static_cast<AllegroFlare::Runners::Complete*>(user_data);
      //this_runner->game_configuration->handle_arbitrary_storyboard_screen_activated(); // TODO: Is this necessary?

      // TODO: Consider how to pass along a storyboard identifier that should be loaded
      std::string storyboard_identifier = "[unset-storyboard_identifier]";
      // Set the pages of the storyboard to this storyboard
      // TODO: Consider if the arbitrary_storyboard_screen should be a pointer and created new here
      this_runner->arbitrary_storyboard_screen.get_storyboard_element_ref().set_pages(
         this_runner->game_configuration->create_arbitrary_storyboard_pages_by_identifier(storyboard_identifier)
      );
      return true;


  - name: setup_router
    guards: [ primary_gameplay_screen ]
    body: |
      router.set_screen_manager(&framework->get_screen_manager_ref());
      router.set_event_emitter(event_emitter);
      //router.set_pause_managed_gameplay_screen(primary_gameplay_screen); // TODO: Test this // TODO: Remove this line

      // Set handlers for route events
      router.set_on_route_event_unhandled_func(on_route_event_unhandled_func);
      router.set_on_route_event_unhandled_func_user_data(this);

      // Set the "load_level" handler
      router.set_load_level_handler([this](AllegroFlare::RouteEventDatas::Base* route_event_data) -> bool {
         // TODO: Fill in the body of this function:
         // TODO: Validate route_event_data is non-void
         // TODO: Validate route_event_data is StartLevel type

         AllegroFlare::RouteEventDatas::StartLevel *as_start_level =
            static_cast<AllegroFlare::RouteEventDatas::StartLevel*>(route_event_data);

         std::string level_identifier_to_load = as_start_level->get_level_identifier();

         // NOTE: Here, legacy systems will load_level_by_identifer as a call to the primary_gameplay_screen. Newer
         // systems will manage loading from the game_configuration. The latter system is preferible so that the list
         // of levels can be managed at the game_configuration level, and level-specific classes, (something like
         // YourGame::Levels:MyUndergroundLevel) do not become dependencies with the logic in the primary gameplay
         // screen. In a lot of cases (all?) the former legacy technique simply routes to the game_configuration
         // anyway. Updating them could be good. This design remains in flux.

         bool level_was_loaded_via_the_legacy_method = false;
         {
            if (!primary_gameplay_screen)
            {
               AllegroFlare::Logger::throw_error(
                  "AllegroFlare::Runners::Complete::setup_router",
                  "primary_gameplay_screen is nullptr"
               );
            }

            // TODO: Consider adding a begin_gameplay() after this step
            bool loaded_level = primary_gameplay_screen->load_level_by_identifier(level_identifier_to_load);
            if (loaded_level == true)
            {
               level_was_loaded_via_the_legacy_method = true;
               AllegroFlare::Logger::warn_from_once(
                 "AllegroFlare::Runners::Complete::setup_router",
                 "In the load_level_handler callback, the primary_gameplay_screen returned a created level after "
                    "calling load_level_by_identifier. This is legacy behavior. Consider moving the level loading "
                    "logic to the game_configuration instead, and have "
                    "primary_gameplay_screen->load_level_by_identifier return "
                    "false."
               );
            }
         }

         if (!level_was_loaded_via_the_legacy_method)
         {
            AllegroFlare::Logger::info_from(
              "AllegroFlare::Runners::Complete::setup_router",
              "In the load_level_handler callback, proceeding to load the level \"" + level_identifier_to_load + "\" "
                 "through game_configuration."
            );

            this->game_configuration->load_level_by_identifier(level_identifier_to_load);
         }

         // TODO: Improve design and address a "return false" if the level did not load or does not exist
         // TODO: Address concern that return type of lambda may not be the same signature of the load_level_handler
         return true;
      });

      // Set the callbacks related related to GameSession
      router.set_on_create_new_session_func(
         [this](AllegroFlare::Routers::Standard* screen, void* user_data) {
            // TODO: Test this method

            AllegroFlare::GameSession &game_session = screen->get_game_session_ref();

            // TODO: Test this case
            if (game_session.get_game_progress_and_state_info() != nullptr)
            {
               AllegroFlare::Logger::info_from(
                  "AllegroFlare::Runners::Complete::setup_router",
                  "In the on_create_new_session_func callback, the game_session already has a created "
                     "\"game_progress_and_state_info\" member present. This is expected to be empty at this point, "
                     "with the member only being created once, here, at the beginning of the application's setup."
               );
            }

            // Create the game_progress_and_state_info saver/loader object. This is created on a per-game basis
            // by the configuration.
            AllegroFlare::GameProgressAndStateInfos::Base *game_progress_and_state_info_saver_loader =
               this->game_configuration->create_game_progress_and_state_info_saver_loader();

            // Assigns the created game progress and state info to the game session object
            game_session.set_game_progress_and_state_info(game_progress_and_state_info_saver_loader);
         }
      );
      //router.set_on_create_new_session_func_user_data(this);

      router.set_on_load_last_played_session_or_start_new_func(
         [this](AllegroFlare::Routers::Standard* screen, void* user_data) {
            // TODO: Test this method
            AllegroFlare::GameSession &game_session = screen->get_game_session_ref();
            // NOTE: user_data is not necessary
            this->game_configuration->load_last_played_session_or_start_new(&game_session);
         }
      );
      //router.set_on_load_last_played_session_or_start_new_func_user_data(this); // NOTE: user_data is not necessary

      // Set handlers for when the primary gameplay screen is finished
      // TODO: Rename these methods to "on_primary_gameplay_screen_finished"
      router.set_on_primary_gameplay_screen_finished_func(on_primary_gameplay_screen_finished_func);
      router.set_on_primary_gameplay_screen_finished_func_user_data(this);
      router.set_on_gameplay_paused_func(on_gameplay_paused_func);
      router.set_on_gameplay_paused_func_user_data(this);
      router.set_on_gameplay_unpaused_func(on_gameplay_unpaused_func);
      router.set_on_gameplay_unpaused_func_user_data(this);

      router.set_on_arbitrary_storyboard_screen_finished_func(on_arbitrary_storyboard_screen_finished_func);
      router.set_on_arbitrary_storyboard_screen_finished_func_user_data(this);

      router.set_on_arbitrary_storyboard_screen_activated_func(on_arbitrary_storyboard_screen_activated_func);
      router.set_on_arbitrary_storyboard_screen_activated_func_user_data(this);

      //router.set_on_before_activate_screen_func(AllegroFlare::Runners::Complete::on_before_activate_screen_func);
      //router.set_on_before_activate_screen_func_user_data(this);
      router.set_on_before_activate_screen_func(
         [this](std::string activating, std::string current, AllegroFlare::Routers::Base*, void*) {
            //: std::function<void(
            //std::string, std::string, AllegroFlare::Routers::Base*, void*
            //)>
            this->game_configuration->before_activate_screen_callback(activating, current);
         });
      router.set_on_before_activate_screen_func_user_data(this);

      // When assembling saving and loading content for save file
      router.set_on_load_save_file_content_into_gameplay_func(
         // TODO: Test this callback
         // TODO: Ensure this callback is thoroughly vetted with the right purpose. It was thrown together ad-hoc for
         // the purpose of this code block, but might not fully contain the comprehensive solution expected. Please
         // review. Some things found:
         //  - This callback assumes the save file content to load is determined by the currently selected slot
         //    in the saving_and_loading_screen. This could be flakey or cause unexpected user experience.
         //  - Storing the current_manual_save_slot_position on this class might not align with different save styles
         // TODO: Determine if this callback func signature needs to be tweaked with more proper arguments
         [this](AllegroFlare::Routers::Standard* router, void* user_data) {
            if (!this->game_configuration)
            {
               AllegroFlare::Logger::throw_error(
                  "AllegroFlare::Runners::Complete::setup_router",
                  "In router.on_load_save_file_content_into_gameplay_func lambda, a game_configuration is "
                  "required and expected but is not present."
               );
            }

            AllegroFlare::SavingAndLoading::SaveSlot *currently_selected_save_slot_in_the_saving_and_loading_screen =
               saving_and_loading_screen.get_currently_selected_save_slot();

            if (!currently_selected_save_slot_in_the_saving_and_loading_screen)
            {
               AllegroFlare::Logger::throw_error("AllegroFlare::Runners::Complete::setup_router",
                  "When attempting to obtain the currently selected save slot from the saving_and_loading screen, "
                     "a nullptr was returned."
               );
            }

            int manual_save_slot_position =
               currently_selected_save_slot_in_the_saving_and_loading_screen->get_save_slot_position();
            current_manual_save_slot_position = manual_save_slot_position; // Is this necessary?

            AllegroFlare::Logger::info_from(
               "AllegroFlare::Runners::Complete::setup_router",
               "Starting loading..."
            );

            // TODO: Obtain save file content to pass down into method
            //std::string save_file_content = "{}"; // TODO: Load from save slot // HERE
            std::string save_file_content = saving_and_loading.load_content_from_manual_save_content_file(
               current_save_profile_id,
               current_manual_save_slot_position
               //1 // Save slot position // TODO: Make this configurable
               //save_file_content // Something like "{\"from\", \"Runners/Complete\"}"
            );
            this->game_configuration->load_save_file_content_into_gameplay(save_file_content);

            AllegroFlare::Logger::info_from(
               "AllegroFlare::Runners::Complete::setup_router",
               "... loading finished."
            );

            // Start the primary_gameplay_screen
            // TODO: Determine if this is the preferred next action. If the load_a_saved_game_screen is of a save
            // style that starts a new game after loading a save slot, then the next step in the game would be to
            // begin the opening storyboard screen. Otherwise, it may want to activate the primary gameplay screen,
            // it may need to go to the level select screen, or need to trigger some other unknown event.
            this->router.emit_route_event(
               AllegroFlare::Routers::Standard::EVENT_ACTIVATE_PRIMARY_GAMEPLAY_SCREEN,
               nullptr,
               al_get_time()
            );
         });
      router.set_on_load_save_file_content_into_gameplay_func_user_data(this);
      router.set_on_start_new_game_with_empty_save_slot_func(
         [](AllegroFlare::Routers::Standard* router, void* user_data) {
            // TODO: This method
            // HERE
            AllegroFlare::Logger::info_from(
               "AllegroFlare::Runners::Complete::setup_router",
               "In definition for on_start_new_game_with_empty_save_slot_func, this method is not implemented");
         });

      // When saving
      router.set_on_save_game_func(
         [this](AllegroFlare::Routers::Standard* router, std::string save_type, void* user_data) {

            // Possible values for save_type in this context are "manual", "autosave", or "quicksave"

            // TODO: Improve this info message
            AllegroFlare::Logger::info_from(
               THIS_CLASS_AND_METHOD_NAME,
               "Saving game..."
            );

            if (save_type == "manual")
            {
               // TODO: Test this
               // Save the actual content to the save slot
               std::string save_file_content = this->game_configuration->build_save_file_content_for_current_game();
               saving_and_loading.save_to_manual_save_slot(
                  current_save_profile_id,
                  current_manual_save_slot_position, //1, // Save slot position // TODO: Make this configurable
                  save_file_content // Something like "{\"from\", \"Runners/Complete\"}"
               );
            }
            else if (save_type == "autosave")
            {
               // Confirm autosave is available before attempting save
               if (!saving_and_loading.has_autosave_save_slots())
               {
                  // TODO: Test this
                  AllegroFlare::Logger::throw_error(
                     "AllegroFlare::Runners::Complete::setup_router",
                     "In on_save_callback_func, attempted to save an \"autosave\" type save, but there are no "
                        "autosave save slots in the current configuration. To set the number of autosave slots in "
                        "your game's derived GameConfiguration, override \"int get_num_autosave_save_slots()\" to "
                        "return the number of slots you want to have available in your game."
                  );
               }

               std::string save_file_content = this->game_configuration->build_save_file_content_for_current_game();
               saving_and_loading.save_to_autosave(
                  current_save_profile_id,
                  save_file_content
               );
            }
            else if (save_type == "quicksave")
            {
               // Confirm quicksave is available before attempting save
               if (!saving_and_loading.has_quicksave_save_slots())
               {
                  // TODO: Test this
                  AllegroFlare::Logger::throw_error(
                     "AllegroFlare::Runners::Complete::setup_router",
                     "In on_save_callback_func, attempted to save an \"quicksave\" type save, but there are no "
                        "quicksave save slots in the current configuration. To set the number of quicksave slots in "
                        "your game's derived GameConfiguration, override \"int get_num_quicksave_save_slots()\" to "
                        "return the number of slots you want to have available in your game."
                  );
               }

               std::string save_file_content = this->game_configuration->build_save_file_content_for_current_game();
               saving_and_loading.save_to_quicksave(
                  current_save_profile_id,
                  save_file_content
               );
            }
            else
            {
               // TODO: Test this
               AllegroFlare::Logger::throw_error(
                  "AllegroFlare::Runners::Complete::setup_router",
                  "In on_save_callback_func, an invalid save_type argument \"" + save_type + "\" was provided."
               );
            }

            // TODO: Improve this info message
            AllegroFlare::Logger::info_from(
               THIS_CLASS_AND_METHOD_NAME,
               "...game saved successfully."
            );
         }
      );
      router.set_on_save_game_func_user_data(nullptr); // Not sure what would be passed here
      
      /*
        type: std::function<void(AllegroFlare::Routers::Standard*, void*)>
        init_with: '{}'
        getter: true
        setter: true

      - name: on_load_save_file_content_into_gameplay_user_data
        type: void*
        init_with: nullptr
        getter: true
        setter: true
      */


      // Set the routes
      router.register_screen(
         AllegroFlare::Routers::Standard::INTRO_LOGOS_SCREEN_IDENTIFIER,
         &intro_logos_screen
      );
      router.register_screen(
         AllegroFlare::Routers::Standard::INTRO_STORYBOARD_SCREEN_IDENTIFIER,
         &intro_storyboard_screen
      );
      router.register_screen(
         AllegroFlare::Routers::Standard::TITLE_SCREEN_IDENTIFIER,
         &title_screen
      );
      router.register_screen(
         AllegroFlare::Routers::Standard::ACHIEVEMENTS_SCREEN_IDENTIFIER,
         &achievements_screen
      );
      router.register_screen(
         AllegroFlare::Routers::Standard::DISPLAY_SETTINGS_SCREEN_IDENTIFIER,
         &display_settings_screen
      );
      router.register_screen(
         AllegroFlare::Routers::Standard::VERSION_SCREEN_IDENTIFIER,
         &version_screen
      );
      router.register_screen(
         AllegroFlare::Routers::Standard::NEW_GAME_INTRO_STORYBOARD_SCREEN_IDENTIFIER,
         &new_game_intro_storyboard_screen
      );
      router.register_screen(
         AllegroFlare::Routers::Standard::LEVEL_SELECT_SCREEN_IDENTIFIER,
         &level_select_screen
      );
      router.register_screen(
         AllegroFlare::Routers::Standard::ARBITRARY_STORYBOARD_SCREEN_IDENTIFIER,
         &arbitrary_storyboard_screen
      );
      router.register_screen(
         AllegroFlare::Routers::Standard::GAME_OVER_SCREEN_IDENTIFIER,
         &game_over_screen
      );
      router.register_screen(
         AllegroFlare::Routers::Standard::GAME_WON_SCREEN_IDENTIFIER,
         &game_won_screen
      );
      router.register_screen(
         AllegroFlare::Routers::Standard::SETTINGS_SCREEN_IDENTIFIER,
         &settings_screen
      );
      router.register_screen(
         AllegroFlare::Routers::Standard::GAME_WON_OUTRO_STORYBOARD_SCREEN_IDENTIFIER,
         &game_won_outro_storyboard_screen
      );
      router.register_screen(
         AllegroFlare::Routers::Standard::LOAD_A_SAVED_GAME_SCREEN_IDENTIFIER,
         //&load_a_saved_game_screen
         &saving_and_loading_screen
      );
      router.register_screen(
         AllegroFlare::Routers::Standard::CREDITS_SCREEN_IDENTIFIER,
         &rolling_credits_screen
      );
      router.register_screen(
         AllegroFlare::Routers::Standard::PRIMARY_GAMEPLAY_SCREEN_IDENTIFIER,
         primary_gameplay_screen
      );
      router.register_screen(
         AllegroFlare::Routers::Standard::PRIMARY_GAMEPLAY_SUBSCREEN_IDENTIFIER,
         primary_gameplay_subscreen
      );
      router.register_screen(
         AllegroFlare::Routers::Standard::PAUSE_SCREEN_IDENTIFIER,
         pause_screen
      );

      // Set the callbacks
      intro_logos_screen.set_on_finished_callback_func(
         [this](AllegroFlare::Screens::Storyboard* screen, void* data) {
            this->router.emit_route_event(
               AllegroFlare::Routers::Standard::EVENT_INTRO_LOGOS_SCREEN_FINISHED,
               nullptr,
               al_get_time()
            );
         }
      );
      intro_storyboard_screen.set_on_finished_callback_func(
         [this](AllegroFlare::Screens::Storyboard* screen, void* data) {
            this->router.emit_route_event(
               AllegroFlare::Routers::Standard::EVENT_INTRO_STORYBOARD_SCREEN_FINISHED,
               nullptr,
               al_get_time()
            );
         }
      );
      load_a_saved_game_screen.set_on_menu_choice_callback_func(
         [this](AllegroFlare::LoadASavedGame::Screen* screen, void* data) {
            // TODO: Test this callback
            int position_of_save_slot = -1;
            AllegroFlare::LoadASavedGame::SaveSlots::Base* currently_selected_save_slot = nullptr;
            std::string filename_for_save_slot = "[unset-filename_for_save_slot]";
           
            std::tie(position_of_save_slot, currently_selected_save_slot) = screen->get_currently_selected_save_slot();

            if (!currently_selected_save_slot)
            {
               AllegroFlare::Logger::throw_error(THIS_CLASS_AND_METHOD_NAME,
                  "In on_menu_choice_callback_func for load_a_saved_game_screen, currently_selected_save_slot is "
                  "nullptr and required for this callback. Ensure that the LoadASavedGame is validating the presence "
                  "of the save slot before submitting the menu choice."
               );
            }

            filename_for_save_slot = currently_selected_save_slot->get_filename();

            AllegroFlare::Logger::info_from(THIS_CLASS_AND_METHOD_NAME,
               "In on_menu_choice_callback_func for load_a_saved_game_screen, sending event to load from save file \""
               + filename_for_save_slot + "\" currently in save slot " + std::to_string(position_of_save_slot) + "."
            );

            this->router.emit_route_event(
               AllegroFlare::Routers::Standard::EVENT_LOAD_A_SAVED_GAME,
               nullptr, // TODO: Pass along data required to determine which save data to load
               al_get_time()
            );
         }
      );
      load_a_saved_game_screen.set_on_erase_focused_save_slot_func(
         [this](AllegroFlare::LoadASavedGame::Screen* screen, void* data) {
            // TODO: Handle here
            (void)(this); // TODO: Consider if this argument could be removed
            AllegroFlare::Logger::info_from(
              "Router::setup_router",
              "In on_erase_focused_save_slot_func, Currently there is no action implemented on this callback"
           );
         }
      );
      load_a_saved_game_screen.set_on_exit_callback_func(
         [this](AllegroFlare::LoadASavedGame::Screen* screen, void* data) {
            this->router.emit_route_event(
               AllegroFlare::Routers::Standard::EVENT_ACTIVATE_TITLE_SCREEN,
               nullptr,
               al_get_time()
            );
         }
      );
      saving_and_loading_screen.set_on_exit_callback_func([this](AllegroFlare::SavingAndLoading::Screen*, void*){
         // TODO: Fix this callback to return to account for coming from an arbitrary previous screen.
         // Typically you would have something like swap back to the title screen, or pause or other screen.
         this->router.emit_route_event(
            AllegroFlare::Routers::Standard::EVENT_ACTIVATE_TITLE_SCREEN,
            nullptr,
            al_get_time()
         );
      });
      saving_and_loading_screen.set_on_erase_focused_save_slot_func([](AllegroFlare::SavingAndLoading::Screen*, void*){
         // TODO: Test this callback
         AllegroFlare::Logger::info_from(
            "AllegroFlare::Runners::Complete::setup_router",
            "There is not implementation for this feature."
         );
      });
      saving_and_loading_screen.set_on_menu_choice_callback_func([this](AllegroFlare::SavingAndLoading::Screen*, void*){
         // TODO: Test this callback, and the branching logic
         // This usage of event emitting could be redundant? Consider direct calls instead of emitted events
         AllegroFlare::SavingAndLoading::SaveSlot *currently_selected_save_slot_in_the_saving_and_loading_screen =
            saving_and_loading_screen.get_currently_selected_save_slot();

         if (!currently_selected_save_slot_in_the_saving_and_loading_screen)
         {
            AllegroFlare::Logger::throw_error("AllegroFlare::Runners::Complete::setup_router",
               "In on_menu_choice_callback_func for saving_and_loading_screen, unable to obtain the currently "
                  "selected save slot from the saving_and_loading_screen, a nullptr was returned."
            );
         }

         bool currently_selected_save_slot_is_empty =
            currently_selected_save_slot_in_the_saving_and_loading_screen->is_empty();
         if (currently_selected_save_slot_is_empty)
         {
            this->router.emit_route_event(
               AllegroFlare::Routers::Standard::EVENT_START_NEW_GAME_ON_EMPTY_SAVE_SLOT,
               nullptr, // TODO: Pass along data required to determine which save data to load
               al_get_time()
            );
         }
         else
         {
            this->router.emit_route_event(
               AllegroFlare::Routers::Standard::EVENT_LOAD_A_SAVED_GAME,
               nullptr, // TODO: Pass along data required to determine which save data to load
               al_get_time()
            );
         }
      });
      new_game_intro_storyboard_screen.set_on_finished_callback_func(
         [this](AllegroFlare::Screens::Storyboard* screen, void* data) {
            this->router.emit_route_event(
               AllegroFlare::Routers::Standard::EVENT_NEW_GAME_INTRO_STORYBOARD_SCREEN_FINISHED,
               nullptr,
               al_get_time()
            );
         }
      );
      level_select_screen.set_on_menu_choice_callback_func(
         [this](AllegroFlare::Screens::LevelSelectScreen* screen, void* data) {
            // TODO: validate "screen" is non-void

            std::string selected_menu_option_value = screen->infer_current_menu_option_value();

            AllegroFlare::RouteEventDatas::StartLevel *route_event_data = new AllegroFlare::RouteEventDatas::StartLevel;
            route_event_data->set_level_identifier(selected_menu_option_value);

            this->router.emit_route_event(
               AllegroFlare::Routers::Standard::EVENT_START_LEVEL,
               route_event_data,
               al_get_time()
            );
         }
      );
      arbitrary_storyboard_screen.set_on_finished_callback_func(
         [this](AllegroFlare::Screens::Storyboard* screen, void* data) {
            this->router.emit_route_event(
               AllegroFlare::Routers::Standard::EVENT_ARBITRARY_STORYBOARD_SCREEN_FINISHED,
               nullptr,
               al_get_time()
            );
         }
      );
      primary_gameplay_screen->set_on_finished_callback_func(
         [this](AllegroFlare::Screens::Gameplay* screen, void* data) {
            this->router.emit_route_event(
               AllegroFlare::Routers::Standard::EVENT_PRIMARY_GAMEPLAY_SCREEN_FINISHED,
               nullptr,
               al_get_time()
            );
         }
      );
      primary_gameplay_screen->set_on_manual_save_callback_func(
         [this](AllegroFlare::Screens::Gameplay* screen, void* data) {
            // TODO: Here, emit route event for now. Consider making this an explicit event handling
            this->router.emit_route_event(
               AllegroFlare::Routers::Standard::EVENT_SAVE_TO_MANUAL_SAVE,
               nullptr,
               al_get_time()
            );
         }
      );
      primary_gameplay_screen->set_on_autosave_save_callback_func(
         [this](AllegroFlare::Screens::Gameplay* screen, void* data) {
            // TODO: Here, emit route event for now. Consider making this an explicit event handling
            this->router.emit_route_event(
               AllegroFlare::Routers::Standard::EVENT_SAVE_TO_AUTOSAVE_SAVE,
               nullptr,
               al_get_time()
            );
         }
      );
      primary_gameplay_screen->set_on_quicksave_save_callback_func(
         [this](AllegroFlare::Screens::Gameplay* screen, void* data) {
            // TODO: Here, emit route event for now. Consider making this an explicit event handling
            this->router.emit_route_event(
               AllegroFlare::Routers::Standard::EVENT_SAVE_TO_QUICKSAVE_SAVE,
               nullptr,
               al_get_time()
            );
         }
      );
      settings_screen.set_on_exit_callback_func(
         [this](AllegroFlare::Screens::SettingsScreen* screen, void* data) {
            this->router.emit_route_event(
               AllegroFlare::Routers::Standard::EVENT_ACTIVATE_TITLE_SCREEN, // NOTE: If the settings screen is
                                                                             // made accessible during gameplay,
                                                                             // this event will need to modified
                                                                             // for that case
               nullptr,
               al_get_time()
            );
         }
      );
      game_won_screen.set_on_submit_callback_func(
         [this](AllegroFlare::Screens::GameWonScreen* screen, void* data) {
            // TODO: validate "screen" is non-void

            this->router.emit_route_event(
               AllegroFlare::Routers::Standard::EVENT_ACTIVATE_TITLE_SCREEN,
               nullptr,
               al_get_time()
            );
         }
      );
      game_over_screen.set_on_menu_choice_callback_func(
         [this](AllegroFlare::Screens::GameOverScreen* screen, void* data) {
            // TODO: validate "screen" is non-void

            std::string menu_choice = screen->infer_current_menu_option_value();

            if (menu_choice == "try_again")
            {
               this->router.emit_route_event(
                  AllegroFlare::Routers::Standard::EVENT_CONTINUE_FROM_LAST_SAVE, // NOTE: This event currently does not
                                                                                  // have an effect
                  nullptr,
                  al_get_time()
               );
            }
            else if (menu_choice == "start_title_screen")
            {
               this->router.emit_route_event(
                  AllegroFlare::Routers::Standard::EVENT_ACTIVATE_TITLE_SCREEN, // TODO: Have this activate a
                                                                                // confirmation dialog
                  nullptr,
                  al_get_time()
               );
            }
            else
            {
               AllegroFlare::Logger::throw_error("Boobaz", "buzz");
            }
         }
      );
      game_won_outro_storyboard_screen.set_on_finished_callback_func(
         [this](AllegroFlare::Screens::Storyboard* screen, void* data) {
            this->router.emit_route_event(
               AllegroFlare::Routers::Standard::EVENT_GAME_WON_OUTRO_STORYBOARD_SCREEN_FINISHED,
               nullptr,
               al_get_time()
            );
         }
      );
      rolling_credits_screen.set_on_finished_callback_func(
         [this](AllegroFlare::Screens::RollingCredits* screen, void* data) {
            this->router.emit_route_event(
               AllegroFlare::Routers::Standard::EVENT_CREDITS_SCREEN_FINISHED,
               nullptr,
               al_get_time()
            );
         }
      );
      title_screen.set_on_finished_callback_func(
         [this](AllegroFlare::Screens::TitledMenuScreen* screen, void* data) {
            this->router.emit_route_event(
               AllegroFlare::Routers::Standard::EVENT_TITLE_SCREEN_FINISHED,
               nullptr,
               al_get_time()
            );
         }
      );
      title_screen.set_on_menu_choice_callback_func(
         [this](AllegroFlare::Screens::TitledMenuScreen* screen, std::string menu_choice, void* data) {
            //std::string menu_choice = screen->infer_current_menu_option_value();

            if (menu_choice == "start_new_game")
            {
               // TODO: If current game session is valid and has a running GameProgressAndSaveInfo,
               // Emit a confirmation dialog "this will destroy the current game, do you wish to
               // continue" OR move the gamer to a "pick a save slot to start new game" screen
               this->router.emit_route_event(
                  AllegroFlare::Routers::Standard::EVENT_START_NEW_GAME,
                  nullptr,
                  al_get_time()
               );
            }
            else if (menu_choice == "continue_from_last_save")
            {
               // TODO: Consider this implementation is unclear and my not be ideal (it's a license to change it)
               this->game_configuration->load_game_progress_and_state_info_into_universe(); // was "continue_from_last_save"
               this->router.emit_route_event(
                  AllegroFlare::Routers::Standard::EVENT_ACTIVATE_PRIMARY_GAMEPLAY_SCREEN,
                  nullptr,
                  al_get_time()
               );
            }
            else if (menu_choice == "goto_load_a_saved_game_screen")
            {
               this->router.emit_route_event(
                  AllegroFlare::Routers::Standard::EVENT_ACTIVATE_LOAD_A_SAVED_GAME_SCREEN,
                  nullptr,
                  al_get_time()
               );
            }
            else if (menu_choice == "quit")
            {
               this->router.emit_route_event(
                  AllegroFlare::Routers::Standard::EVENT_EXIT_GAME,
                  nullptr,
                  al_get_time()
               );
            }
            else if (menu_choice == "goto_achievements_screen")
            {
               this->router.emit_route_event(
                  AllegroFlare::Routers::Standard::EVENT_ACTIVATE_ACHIEVEMENTS_SCREEN,
                  nullptr,
                  al_get_time()
               );
            }
            else if (menu_choice == "goto_display_settings_screen")
            {
               this->router.emit_route_event(
                  AllegroFlare::Routers::Standard::EVENT_ACTIVATE_DISPLAY_SETTINGS_SCREEN,
                  nullptr,
                  al_get_time()
               );
            }
            else if (menu_choice == "goto_version_screen")
            {
               this->router.emit_route_event(
                  AllegroFlare::Routers::Standard::EVENT_ACTIVATE_VERSION_SCREEN,
                  nullptr,
                  al_get_time()
               );
            }
            else if (menu_choice == "goto_settings_screen")
            {
               this->router.emit_route_event(
                  AllegroFlare::Routers::Standard::EVENT_ACTIVATE_SETTINGS_SCREEN,
                  nullptr,
                  al_get_time()
               );
            }
            else if (menu_choice == "goto_credits_screen")
            {
               this->router.emit_route_event(
                  AllegroFlare::Routers::Standard::EVENT_ACTIVATE_CREDITS_SCREEN,
                  nullptr,
                  al_get_time()
               );
            }
            else
            {
               AllegroFlare::Logger::throw_error(
                  "AllegroFlare::Runners::Complete::setup_router",
                  "Within the definition for title_screen.on_menu_choice_callback_func, there is no case to handle the "
                     "menu_choice \"" + menu_choice + "\"."
               );
            }
         }
      );
      achievements_screen.set_on_exit_callback_func(
         [this](AllegroFlare::Screens::Achievements* screen, void* data) {
            // TODO: This should be a push/pop'd screen
            this->router.emit_route_event(
               AllegroFlare::Routers::Standard::EVENT_ACTIVATE_TITLE_SCREEN,
               nullptr,
               al_get_time()
            );
         }
      );
      display_settings_screen.set_on_exit_callback_func(
         [this](AllegroFlare::Screens::DisplaySettings* screen, void* data) {
            // TODO: This should be a push/pop'd screen
            this->router.emit_route_event(
               AllegroFlare::Routers::Standard::EVENT_ACTIVATE_TITLE_SCREEN,
               nullptr,
               al_get_time()
            );
         }
      );
      version_screen.set_on_exit_callback_func(
         [this](AllegroFlare::Screens::Version* screen, void* data) {
            // TODO: This should be a push/pop'd screen
            this->router.emit_route_event(
               AllegroFlare::Routers::Standard::EVENT_ACTIVATE_TITLE_SCREEN,
               nullptr,
               al_get_time()
            );
         }
      );

      return;
    body_dependency_symbols:
      - AllegroFlare::Logger
      - AllegroFlare::RouteEventDatas::StartLevel
      - AllegroFlare::GameSession
      - AllegroFlare::GameProgressAndStateInfos::Base


  - name: run
    parameters:
      - name: game_configuration
        type: AllegroFlare::GameConfigurations::Complete*
        default_argument: nullptr
      - name: deployment_environment_mode
        type: std::string
        default_argument: '"[unset-deployment_environment_mode]"'
    guards: [ game_configuration ]
    static: true
    body: |
      // setup the framework
      AllegroFlare::Frameworks::Full *framework = new AllegroFlare::Frameworks::Full();
      framework->set_deployment_environment(deployment_environment_mode);
      //if (disable_escape_key_will_shutdown) framework.disable_escape_key_will_shutdown();
      framework->initialize();

      // instantiate our actual game runner
      AllegroFlare::Runners::Complete runner(
         framework,
         &framework->get_event_emitter_ref(),
         &framework->get_bitmap_bin_ref(),
         &framework->get_font_bin_ref(),
         &framework->get_sample_bin_ref(),
         &framework->get_model_bin_ref(),
         game_configuration
      );
      runner.initialize();
      framework->register_screen("runner", &runner);

      framework->run_loop();

      runner.destroy();

      delete framework;
      return;
    body_dependency_symbols:
      - AllegroFlare::Frameworks::Full


dependencies:


  - symbol: AllegroFlare::Screens::Base
    headers: [ AllegroFlare/Screens/Base.hpp ]
  - symbol: AllegroFlare::EventEmitter
    headers: [ AllegroFlare/EventEmitter.hpp ]
  - symbol: AllegroFlare::Frameworks::Full
    headers: [ AllegroFlare/Frameworks/Full.hpp ]
  - symbol: AllegroFlare::BitmapBin
    headers: [ AllegroFlare/BitmapBin.hpp ]
  - symbol: AllegroFlare::FontBin
    headers: [ AllegroFlare/FontBin.hpp ]
  - symbol: AllegroFlare::SampleBin
    headers: [ AllegroFlare/SampleBin.hpp ]
  - symbol: AllegroFlare::ModelBin
    headers: [ AllegroFlare/ModelBin.hpp ]
  - symbol: AllegroFlare::GameEvent
    headers: [ AllegroFlare/GameEvent.hpp ]
  - symbol: AllegroFlare::Routers::Standard
    headers: [ AllegroFlare/Routers/Standard.hpp ]
  - symbol: AllegroFlare::Screens::Storyboard
    headers: [ AllegroFlare/Screens/Storyboard.hpp ]
  - symbol: AllegroFlare::Screens::Achievements
    headers: [ AllegroFlare/Screens/Achievements.hpp ]
  - symbol: AllegroFlare::Screens::TitleScreen
    headers: [ AllegroFlare/Screens/TitleScreen.hpp ]
  - symbol: AllegroFlare::Screens::GameOverScreen
    headers: [ AllegroFlare/Screens/GameOverScreen.hpp ]
  - symbol: AllegroFlare::Screens::GameWonScreen
    headers: [ AllegroFlare/Screens/GameWonScreen.hpp ]
  - symbol: AllegroFlare::Screens::RollingCredits
    headers: [ AllegroFlare/Screens/RollingCredits.hpp ]
  - symbol: AllegroFlare::Screens::Version
    headers: [ AllegroFlare/Screens/Version.hpp ]
  - symbol: AllegroFlare::Screens::LevelSelectScreen
    headers: [ AllegroFlare/Screens/LevelSelectScreen.hpp ]
  - symbol: AllegroFlare::Screens::SettingsScreen
    headers: [ AllegroFlare/Screens/SettingsScreen.hpp ]
  - symbol: AllegroFlare::LoadASavedGame::Screen
    headers: [ AllegroFlare/LoadASavedGame/Screen.hpp ]
  - symbol: AllegroFlare::Achievements
    headers: [ AllegroFlare/Achievements.hpp ]
  - symbol: AllegroFlare::StoryboardFactory
    headers: [ AllegroFlare/StoryboardFactory.hpp ]
  - symbol: AllegroFlare::Logger
    headers: [ AllegroFlare/Logger.hpp ]
  - symbol: AllegroFlare::RouteEventDatas::StartLevel
    headers: [ AllegroFlare/RouteEventDatas/StartLevel.hpp ]
  - symbol: AllegroFlare::GameSession
    headers: [ AllegroFlare/GameSession.hpp ]
  - symbol: AllegroFlare::Color
    headers: [ AllegroFlare/Color.hpp ]
  - symbol: AllegroFlare::Elements::Backgrounds::Base
    headers: [ AllegroFlare/Elements/Backgrounds/Base.hpp ]
  - symbol: AllegroFlare::Elements::Backgrounds::ClearToColor
    headers: [ AllegroFlare/Elements/Backgrounds/ClearToColor.hpp ]
  - symbol: ReleaseInfo
    headers: [ ReleaseInfo.hpp ]
  - symbol: AllegroFlare::EventNames
    headers: [ AllegroFlare/EventNames.hpp ]
  - symbol: AllegroFlare::GameEventDatas::ScreenActivated
    headers: [ AllegroFlare/GameEventDatas/ScreenActivated.hpp ]
  - symbol: AllegroFlare::GameConfigurations::Complete
    headers: [ AllegroFlare/GameConfigurations/Complete.hpp ]
  - symbol: AllegroFlare::LoadASavedGame::SaveSlots::Empty
    headers: [ AllegroFlare/LoadASavedGame/SaveSlots/Empty.hpp ]
  - symbol: AllegroFlare::Screens::Gameplay
    headers: [ AllegroFlare/Screens/Gameplay.hpp ]
  - symbol: AllegroFlare::GameProgressAndStateInfos::Base
    headers: [ AllegroFlare/GameProgressAndStateInfos/Base.hpp ]
  - symbol: AllegroFlare::Achievement
    headers: [ AllegroFlare/Achievement.hpp ]
  - symbol: AllegroFlare::Elements::StoryboardPages::Base
    headers: [ AllegroFlare/Elements/StoryboardPages/Base.hpp ]
  - symbol: AllegroFlare::ForwardDeclarations::AllegroFlare::Runners::Complete
    headers: [ AllegroFlare/ForwardDeclarations/AllegroFlare/Runners/Complete.hpp ]
  - symbol: AllegroFlare::ForwardDeclarations::AllegroFlare::GameConfigurations::Complete
    headers: [ AllegroFlare/ForwardDeclarations/AllegroFlare/GameConfigurations/Complete.hpp ]
  - symbol: AllegroFlare::Screens::DisplaySettings
    headers: [ AllegroFlare/Screens/DisplaySettings.hpp ]
  - symbol: AllegroFlare::Screens::PauseScreen
    headers: [ AllegroFlare/Screens/PauseScreen.hpp ]
  - symbol: AllegroFlare::Screens::Subscreen::Screen
    headers: [ AllegroFlare/Screens/Subscreen/Screen.hpp ]
  - symbol: AllegroFlare::Screens::TitledMenuScreen
    headers: [ AllegroFlare/Screens/TitledMenuScreen.hpp ]
  - symbol: AllegroFlare::SavingAndLoading::SavingAndLoading
    headers: [ AllegroFlare/SavingAndLoading/SavingAndLoading.hpp ]
  - symbol: AllegroFlare::SavingAndLoading::Screen
    headers: [ AllegroFlare/SavingAndLoading/Screen.hpp ]


