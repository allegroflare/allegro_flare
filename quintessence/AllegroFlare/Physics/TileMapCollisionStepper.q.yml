properties:


  - name: collision_tile_map
    type: AllegroFlare::TileMaps::TileMap<int>*
    init_with: nullptr
    constructor_arg: true

  - name: aabb2d
    type: AllegroFlare::Physics::AABB2D*
    init_with: nullptr
    constructor_arg: true

  - name: tile_width
    type: float
    init_with: 16.0f
    constructor_arg: true

  - name: tile_height
    type: float
    init_with: 16.0f
    constructor_arg: true


functions:


  - name: step
    type: std::vector<AllegroFlare::Physics::TileMapCollisionStepperCollisionInfo>
    guards: [ collision_tile_map, aabb2d ]
    body: |
      std::vector<AllegroFlare::Physics::TileMapCollisionStepperCollisionInfo> result_infos;
      AllegroFlare::Physics::AABB2D &obj = *aabb2d;
      AllegroFlare::TileMaps::TileMap<int> &map = *collision_tile_map;

      // collect the position before any alterations
      AllegroFlare::Physics::AABB2D obj_before = obj;

      // test horizontal first
      std::vector<AllegroFlare::Physics::Int2D> horizontal_collided_blocks = get_next_collided_tile_coords_1d(
            obj.get_x(), obj.get_y(), obj.get_velocity_x(), obj.get_w(), obj.get_h(), tile_width, tile_height
      );

      // react to the collision here:
      if (!horizontal_collided_blocks.empty())
      {
         for (AllegroFlare::Physics::Int2D &t : horizontal_collided_blocks)
         {
            int tile_value = map.get_tile(t.get_x(), t.get_y());

            if (tile_value == 1) // tile is solid
            {
               if (obj.get_velocity_x() > 0)
               {
                  result_infos.push_back(
                     AllegroFlare::Physics::TileMapCollisionStepperCollisionInfo(
                        AllegroFlare::Physics::Int2D(t.get_x(), t.get_y()),
                        tile_value,
                        obj.get_velocity_x(),
                        obj.get_velocity_y(),
                        true,
                        AllegroFlare::Physics::TileMapCollisionStepperCollisionInfo::EVENT_COLLIDED_AGAINST
                     )
                  );

                  obj.set_right_edge(get_tile_left_edge(t.get_x(), tile_width) - 0.0001);
                  obj.set_velocity_x(0.0);
               }
               else if (obj.get_velocity_x() < 0)
               {
                  result_infos.push_back(
                     AllegroFlare::Physics::TileMapCollisionStepperCollisionInfo(
                        AllegroFlare::Physics::Int2D(t.get_x(), t.get_y()),
                        tile_value,
                        obj.get_velocity_x(),
                        obj.get_velocity_y(),
                        true,
                        AllegroFlare::Physics::TileMapCollisionStepperCollisionInfo::EVENT_COLLIDED_AGAINST
                     )
                  );

                  obj.set_left_edge(get_tile_right_edge(t.get_x(), tile_width) + 0.0001);
                  obj.set_velocity_x(0.0);
               }
            }
            else // tile is not solid (aka, "1")
            {
               // do nothing (this result is handled later in the function)
            }
         }
      }

      obj.set_x(obj.get_x() + obj.get_velocity_x());

      // test vertical second
      std::vector<AllegroFlare::Physics::Int2D> vertical_collided_blocks = get_next_collided_tile_coords_1d(
         obj.get_y(), obj.get_x(), obj.get_velocity_y(), obj.get_h(), obj.get_w(), tile_height, tile_width
      );
      for(AllegroFlare::Physics::Int2D &tile_coord : vertical_collided_blocks) tile_coord.rotate();
      if (!vertical_collided_blocks.empty())
      {
         for (AllegroFlare::Physics::Int2D &t : vertical_collided_blocks)
         {
            int tile_value = map.get_tile(t.get_x(), t.get_y());

            if (tile_value == 1) // tile is solid
            {
               if (obj.get_velocity_y() > 0)
               {
                  result_infos.push_back(
                     AllegroFlare::Physics::TileMapCollisionStepperCollisionInfo(
                        AllegroFlare::Physics::Int2D(t.get_x(), t.get_y()),
                        tile_value,
                        obj.get_velocity_x(),
                        obj.get_velocity_y(),
                        true,
                        AllegroFlare::Physics::TileMapCollisionStepperCollisionInfo::EVENT_COLLIDED_AGAINST
                     )
                  );

                  obj.set_bottom_edge(get_tile_top_edge(t.get_y(), tile_height) - 0.0001);
                  obj.set_velocity_y(0.0);
               }
               else if (obj.get_velocity_y() < 0)
               {
                  result_infos.push_back(
                     AllegroFlare::Physics::TileMapCollisionStepperCollisionInfo(
                        AllegroFlare::Physics::Int2D(t.get_x(), t.get_y()),
                        tile_value,
                        obj.get_velocity_x(),
                        obj.get_velocity_y(),
                        true,
                        AllegroFlare::Physics::TileMapCollisionStepperCollisionInfo::EVENT_COLLIDED_AGAINST
                     )
                  );

                  obj.set_top_edge(get_tile_bottom_edge(t.get_y(), tile_height) + 0.0001);
                  obj.set_velocity_y(0.0);
               }
            }
            else // tile is not solid (aka, "1")
            {
               // do nothing (this result is handled later in the function)
            }
         }
      }
      obj.set_y(obj.get_y() + obj.get_velocity_y());


      AllegroFlare::Physics::AABB2D obj_after = obj;

      // collect the "now_tiles" and "next_tiles" and calculate the difference information
      std::vector<AllegroFlare::Physics::Int2D> now_tiles = tiles_within_aabb2d(obj_before);
      std::vector<AllegroFlare::Physics::Int2D> next_tiles = tiles_within_aabb2d(obj_after);
      std::vector<AllegroFlare::Physics::TileMapCollisionStepperCollisionInfo> difference_infos =
         calculate_difference_info(now_tiles, next_tiles, obj_before.get_velocity_x(), obj_before.get_velocity_y());

      // append the difference_infos to the result
      result_infos.insert(result_infos.end(), difference_infos.begin(), difference_infos.end());

      return result_infos;
    body_dependency_symbols:
      - AllegroFlare::Physics::AABB2D
      - AllegroFlare::Physics::TileMapCollisionStepperCollisionInfo


  - name: adjacent_to_bottom_edge
    type: bool
    parameters:
      - name: tile_width
        type: float
        default_argument: 16.0f
      - name: tile_height
        type: float
        default_argument: 16.0f
    guards: [ collision_tile_map, aabb2d ]
    body: |
      AllegroFlare::Physics::AABB2D &obj = *aabb2d;

      std::vector<AllegroFlare::Physics::Int2D> tiles = get_next_collided_tile_coords_1d(
         obj.get_y(),
         obj.get_x(),
         0.0004,
         obj.get_h(),
         obj.get_w(),
         tile_height,
         tile_width
      );
      if (tiles.empty()) return false;

      for (auto &t : tiles)
      {
         t.rotate();
         if (collision_tile_map->get_tile(t.get_x(), t.get_y()) == 1) return true;
      }
      return false;


  - name: adjacent_to_right_edge
    type: bool
    parameters:
      - name: tile_width
        type: float
        default_argument: 16.0f
      - name: tile_height
        type: float
        default_argument: 16.0f
    guards: [ collision_tile_map, aabb2d ]
    body: |
      AllegroFlare::Physics::AABB2D &obj = *aabb2d;

      std::vector<AllegroFlare::Physics::Int2D> tiles = get_next_collided_tile_coords_1d(
         obj.get_x(),
         obj.get_y(),
         0.0004,
         obj.get_w(),
         obj.get_h(),
         tile_width,
         tile_height
      );
      if (tiles.empty()) return false;

      for (auto &t : tiles)
      {
         //t.rotate();
         if (collision_tile_map->get_tile(t.get_x(), t.get_y()) == 1) return true;
      }
      return false;


  - name: adjacent_to_top_edge
    type: bool
    parameters:
      - name: tile_width
        type: float
        default_argument: 16.0f
      - name: tile_height
        type: float
        default_argument: 16.0f
    guards: [ collision_tile_map, aabb2d ]
    body: |
      AllegroFlare::Physics::AABB2D &obj = *aabb2d;

      std::vector<AllegroFlare::Physics::Int2D> tiles = get_next_collided_tile_coords_1d(
         obj.get_y(),
         obj.get_x(),
         -0.0004,
         obj.get_h(),
         obj.get_w(),
         tile_height,
         tile_width
      );
      if (tiles.empty()) return false;

      for (auto &t : tiles)
      {
         t.rotate();
         if (collision_tile_map->get_tile(t.get_x(), t.get_y()) == 1) return true;
      }
      return false;


  - name: get_tile_coords_below_left_foot
    type: std::pair<int, int>
    parameters:
      - name: x
        type: float
        default_argument: 0.0f
      - name: y
        type: float
        default_argument: 0.0f
      - name: height
        type: float
        default_argument: 1.0f
    body: |
      std::pair<int, int> result{
         world_x_coords_to_tile_coords_x(x),
         world_y_coords_to_tile_coords_y(y+height+0.0001f)
      };
      return result;


  - name: get_tile_coords_below_right_foot
    type: std::pair<int, int>
    parameters:
      - name: x
        type: float
        default_argument: 0.0f
      - name: y
        type: float
        default_argument: 0.0f
      - name: width
        type: float
        default_argument: 1.0f
      - name: height
        type: float
        default_argument: 1.0f
    body: |
      std::pair<int, int> result{
         world_x_coords_to_tile_coords_x(x+width),
         world_y_coords_to_tile_coords_y(y+height+0.0001f)
      };
      return result;


  - name: adjacent_to_left_edge
    type: bool
    parameters:
      - name: tile_width
        type: float
        default_argument: 16.0f
      - name: tile_height
        type: float
        default_argument: 16.0f
    guards: [ collision_tile_map, aabb2d ]
    body: |
      AllegroFlare::Physics::AABB2D &obj = *aabb2d;

      std::vector<AllegroFlare::Physics::Int2D> tiles = get_next_collided_tile_coords_1d(
         obj.get_x(),
         obj.get_y(),
         -0.0004,
         obj.get_w(),
         obj.get_h(),
         tile_height,
         tile_width
      );
      if (tiles.empty()) return false;

      for (auto &t : tiles)
      {
         //t.rotate();
         if (collision_tile_map->get_tile(t.get_x(), t.get_y()) == 1) return true;
      }
      return false;


  - name: get_next_collided_tile_coords_1d
    private: true
    type: std::vector<AllegroFlare::Physics::Int2D> 
    parameters:
      - name: x
        type: float
        default_argument: 0.0f
      - name: y
        type: float
        default_argument: 0.0f
      - name: velocity
        type: float
        default_argument: 0.0f
      - name: depth_of_body
        type: float
        default_argument: 1.0f
      - name: length_of_edge
        type: float
        default_argument: 1.0f
      - name: tile_length_n
        type: float
        default_argument: 1.0f
      - name: tile_length_m
        type: float
        default_argument: 1.0f
    body: |
      std::vector<AllegroFlare::Physics::Int2D> collided_tiles;

      if (velocity > 0) x += depth_of_body;

      int now = world_coords_to_tile_coords(x, tile_length_n); //TileMap::world_to_tile(x);
      int next = world_coords_to_tile_coords(x + velocity, tile_length_n); //TileMap::world_to_tile(x + velocity);

      if (now != next)
      {
         // new tiles have been entered
         int start_y = world_coords_to_tile_coords(y, tile_length_m); //TileMap::world_to_tile(y);
         float inset_y = std::fmod(y, tile_length_m); // fmod(y, 16.0);
         int num_tiles_along_edge = std::max(1, (int)std::ceil((length_of_edge + inset_y) / tile_length_m));
         collided_tiles.reserve(num_tiles_along_edge);

         // add a list of tiles to the thing
         for (int i=0; i<num_tiles_along_edge; i++)
         {
            collided_tiles.push_back(AllegroFlare::Physics::Int2D(next, start_y+i));
         }
      }

      return collided_tiles;
    body_dependency_symbols:
      - std::fmod


  - name: get_stepped_tile_collisions
    type: std::vector<AllegroFlare::Physics::TileMapCollisionStepperCollisionInfo>
    parameters:
      - name: x
        type: float
        default_argument: 0.0f
      - name: y
        type: float
        default_argument: 0.0f
      - name: velocity_x
        type: float
        default_argument: 0.0f
      - name: velocity_y
        type: float
        default_argument: 0.0f
      - name: width
        type: float
        default_argument: 1.0f
      - name: height
        type: float
        default_argument: 1.0f
      - name: tile_width
        type: float
        default_argument: 1.0f
      - name: tile_height
        type: float
        default_argument: 1.0f
    body: |
      std::vector<AllegroFlare::Physics::Int2D> now_tiles = tiles_within(x, y, width, height, tile_width, tile_height);
      std::vector<AllegroFlare::Physics::Int2D> next_tiles = tiles_within(
         x+velocity_x,
         y+velocity_y,
         width+velocity_x,
         height+velocity_y,
         tile_width,
         tile_height
      );
      return calculate_difference_info(now_tiles, next_tiles, velocity_x, velocity_y);


  - name: calculate_difference_info
    type: std::vector<AllegroFlare::Physics::TileMapCollisionStepperCollisionInfo>
    parameters:
      - name: now_tiles
        type: std::vector<AllegroFlare::Physics::Int2D>
        default_argument: '{}'
      - name: next_tiles
        type: std::vector<AllegroFlare::Physics::Int2D>
        default_argument: '{}'
      - name: velocity_x
        type: float
        default_argument: 0.0f
      - name: velocity_y
        type: float
        default_argument: 0.0f
    body: |
      std::vector<AllegroFlare::Physics::TileMapCollisionStepperCollisionInfo> result;

      std::vector<AllegroFlare::Physics::Int2D> stayed_on_tiles;
      //std::vector<AllegroFlare::Physics::Int2D> &entered_tiles = next_tiles;
      //std::vector<AllegroFlare::Physics::Int2D> &exited_tiles = now_tiles;

      std::set<int> next_tile_indexes_to_remove;
      std::set<int> now_tile_indexes_to_remove;

      for (int i=0; i<next_tiles.size(); i++)
      {
         for (int j=0; j<now_tiles.size(); j++)
         //for (auto &now_tile : now_tiles)
         {
            if (next_tiles[i] == now_tiles[j])
            {
               // add them to the stayed_on_tiles
               stayed_on_tiles.push_back(now_tiles[j]);

               // remove this tile from both sets
               next_tile_indexes_to_remove.insert(i);
               now_tile_indexes_to_remove.insert(j);
            }
         }
      }

      //std::cout << "next tiles count: " << next_tiles.size() << std::endl;
      //std::cout << "now tiles count: " << now_tiles.size() << std::endl;
      //std::cout << "next tiles to remove count: " << next_tile_indexes_to_remove.size() << std::endl;
      //std::cout << "now tiles to remove count: " << now_tile_indexes_to_remove.size() << std::endl;

      // remove the indexes from the set
      for (int i=next_tile_indexes_to_remove.size()-1; i>=0; i--)
      {
         int index_to_remove = *std::next(next_tile_indexes_to_remove.begin(), i);
         next_tiles.erase(next_tiles.begin() + index_to_remove);
      }
      for (int i=now_tile_indexes_to_remove.size()-1; i>=0; i--)
      {
         int index_to_remove = *std::next(now_tile_indexes_to_remove.begin(), i);
         now_tiles.erase(now_tiles.begin() + index_to_remove);
      }

      // aggrigate the results
      std::vector<AllegroFlare::Physics::Int2D> &entered_tiles = next_tiles;
      std::vector<AllegroFlare::Physics::Int2D> &exited_tiles = now_tiles;

      // aggrigate the result (EVENT_STAYED_ON)
      for (auto &stayed_on_tile : stayed_on_tiles)
      {
         result.push_back(AllegroFlare::Physics::TileMapCollisionStepperCollisionInfo(
            stayed_on_tile,
            collision_tile_map ? collision_tile_map->get_tile(stayed_on_tile.get_x(), stayed_on_tile.get_y()) : -999,
            velocity_x,
            velocity_y,
            false,
            AllegroFlare::Physics::TileMapCollisionStepperCollisionInfo::EVENT_STAYED_ON
         ));
      }

      // aggrigate the result (EVENT_ENTERED)
      for (auto &entered_tile : entered_tiles)
      {
         result.push_back(AllegroFlare::Physics::TileMapCollisionStepperCollisionInfo(
            entered_tile,
            collision_tile_map ? collision_tile_map->get_tile(entered_tile.get_x(), entered_tile.get_y()) : -999,
            velocity_x,
            velocity_y,
            false,
            AllegroFlare::Physics::TileMapCollisionStepperCollisionInfo::EVENT_ENTERED
         ));
      }

      // aggrigate the result (EVENT_EXITED)
      for (auto &exited_tile : exited_tiles)
      {
         result.push_back(AllegroFlare::Physics::TileMapCollisionStepperCollisionInfo(
            exited_tile,
            collision_tile_map ? collision_tile_map->get_tile(exited_tile.get_x(), exited_tile.get_y()) : -999,
            velocity_x,
            velocity_y,
            false,
            AllegroFlare::Physics::TileMapCollisionStepperCollisionInfo::EVENT_EXITED
         ));
      }

      return result;
    body_dependency_symbols:
      - std::fmod
      - AllegroFlare::Testing::Comparison::AllegroFlare::Physics::Int2D
      - std::set


  - name: tiles_within_aabb2d
    type: std::vector<AllegroFlare::Physics::Int2D> 
    parameters:
      - name: aabb2d
        type: AllegroFlare::Physics::AABB2D
        default_argument: '{}'
    body: |
      return tiles_within(aabb2d.get_x(), aabb2d.get_y(), aabb2d.get_w(), aabb2d.get_h(), tile_width, tile_height);


  - name: tiles_within
    type: std::vector<AllegroFlare::Physics::Int2D> 
    parameters:
      - name: x
        type: float
        default_argument: 0.0f
      - name: y
        type: float
        default_argument: 0.0f
      - name: width
        type: float
        default_argument: 1.0f
      - name: height
        type: float
        default_argument: 1.0f
      - name: tile_width
        type: float
        default_argument: 1.0f
      - name: tile_height
        type: float
        default_argument: 1.0f
    guards: [ (width >= 0), (height >= 0), (tile_width > 0.0f), (tile_height > 0.0f) ]
    body: |
      std::vector<AllegroFlare::Physics::Int2D> result_tiles;

      int left_tile_x = world_coords_to_tile_coords(x, tile_width);
      int top_tile_y = world_coords_to_tile_coords(y, tile_height);
      int right_tile_x = world_coords_to_tile_coords(x+width, tile_width);
      int bottom_tile_y = world_coords_to_tile_coords(y+height, tile_height);

      for (int tile_y = top_tile_y; tile_y <= bottom_tile_y; tile_y++)
         for (int tile_x = left_tile_x; tile_x <= right_tile_x; tile_x++)
         {
            result_tiles.push_back(AllegroFlare::Physics::Int2D(tile_x, tile_y));
         }

      return result_tiles;


  - name: world_coords_to_tile_coords
    private: true
    type: int
    parameters:
      - name: world_pos
        type: float
        default_argument: 0.0f
      - name: tile_length
        type: float
        default_argument: 1.0f
    body: |
      return (int)(world_pos / tile_length);


  - name: world_x_coords_to_tile_coords_x
    private: true
    type: int
    parameters:
      - name: world_pos_x
        type: float
        default_argument: 0.0f
    body: |
      return (int)(world_pos_x / tile_width);


  - name: world_y_coords_to_tile_coords_y
    private: true
    type: int
    parameters:
      - name: world_pos_y
        type: float
        default_argument: 0.0f
    body: |
      return (int)(world_pos_y / tile_height);


  - name: get_tile_left_edge
    type: float
    parameters:
      - name: tile_x
        type: float
        default_argument: 0.0f
      - name: tile_width
        type: float
        default_argument: 16.0f
    body: |
      return tile_x * tile_width;


  - name: get_tile_right_edge
    type: float
    parameters:
      - name: tile_x
        type: float
        default_argument: 0.0f
      - name: tile_width
        type: float
        default_argument: 16.0f
    body: |
      return (tile_x+1) * tile_width;


  - name: get_tile_top_edge
    type: float
    parameters:
      - name: tile_y
        type: float
        default_argument: 0.0f
      - name: tile_height
        type: float
        default_argument: 16.0f
    body: |
      return tile_y * tile_height;


  - name: get_tile_bottom_edge
    type: float
    parameters:
      - name: tile_y
        type: float
        default_argument: 0.0f
      - name: tile_height
        type: float
        default_argument: 16.0f
    body: |
      return (tile_y+1) * tile_height;


dependencies:


  - symbol: std::fmod
    headers: [ cmath ]
  - symbol: AllegroFlare::Physics::AABB2D
    headers: [ AllegroFlare/Physics/AABB2D.hpp ]
  - symbol: std::vector<AllegroFlare::Physics::Int2D> 
    headers: [ vector, AllegroFlare/Physics/Int2D.hpp ]
  - symbol: std::pair<int, int>
    headers: [ utility ]
  - symbol: AllegroFlare::TileMaps::TileMap
    headers: [ AllegroFlare/TileMaps/TileMap.hpp ]
  - symbol: AllegroFlare::Physics::Int2D
    headers: [ AllegroFlare/Physics/Int2D.hpp ]
  - symbol: AllegroFlare::Physics::TileMapCollisionStepperCollisionInfo
    headers: [ AllegroFlare/Physics/TileMapCollisionStepperCollisionInfo.hpp ]
  - symbol: AllegroFlare::Testing::Comparison::AllegroFlare::Physics::Int2D
    headers: [ AllegroFlare/Testing/Comparison/AllegroFlare/Physics/Int2D.hpp ]


