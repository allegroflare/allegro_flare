parent_classes:


  - class: AllegroFlare::CSVParser
    scope: public
    init_with: ''


properties:


  - name: assets_bitmap_bin
    type: AllegroFlare::BitmapBin*
    init_with: nullptr
    constructor_arg: true
    getter: true
    setter: true

  - name: csv_full_path
    type: std::string
    init_with: '"[unset-csv_full_path]"'
    getter: true
    setter: true

  - name: assets
    type: std::map<std::string, AllegroFlare::AssetStudio::Asset*>
    init_with: '{}'
    getter: explicit

  - name: sprite_sheets
    type: std::map<std::tuple<std::string, int, int, int>, AllegroFlare::FrameAnimation::SpriteSheet*>
    init_with: '{}'

  - name: sprite_sheet_scale
    type: int
    init_with: 3
    getter: true
    setter: before_initialized

  - name: loaded
    type: bool
    init_with: false


documentation:


  - todos:
    - This class is actually an integration when used as expected. Consider testing it on both sides, in
      /../Repos/AllegroFlare and in /../Assets/
    

methods:


  - name: get_initialized
    type: bool
    body: |
      return loaded;


  - name: get_assets
    type: std::map<std::string, AllegroFlare::AssetStudio::Asset*>
    guards: [ loaded ]
    body: |
      return assets;


  - name: level_exists
    type: bool
    parameters:
      - name: level_identifier
        type: std::string
        default_argument: '"[unset-level_identifier]"'
    guards: [ loaded ]
    body: |
      return (assets.find(level_identifier) != assets.end());


  - name: toi
    type: int
    static: true
    parameters:
      - name: value
        type: std::string
        default_argument: '"[unset-value]"'
    body: |
      if (value.empty()) return 0;
      if (value[0] == '+') value.erase(0, 1); // Pop front on the '+' sign
      return std::atoi(value.c_str());
    body_dependency_symbols:
      - std::atoi


  - name: tof
    type: float
    static: true
    parameters:
      - name: value
        type: std::string
        default_argument: '"[unset-value]"'
    body: |
      if (value.empty()) return 0;
      if (value[0] == '+') value.erase(0, 1); // Pop front on the '+' sign
      return std::stof(value.c_str());
    body_dependency_symbols:
      - std::stof


  - name: comma_separated_quoted_strings_to_vector_of_strings
    type: std::vector<std::string>
    static: true
    parameters:
      - name: comma_separated_quoted_strings
        type: std::string
        default_argument: '"[unset-comma_separated_quoted_strings]"'
    body: |
      std::vector<std::string> result;
      std::stringstream ss(comma_separated_quoted_strings);
      std::string current_element;
      bool in_quotes = false;

      // Parse the CSV list character by character
      for (char ch : comma_separated_quoted_strings)
      {
         if (ch == '"')
         {
            // Toggle quotes state
            in_quotes = !in_quotes;
         }
         else if (ch == ',' && !in_quotes)
         {
            // Found a comma outside quotes, push the current element
            result.push_back(current_element);
            current_element.clear(); // Reset for the next element
         }
         else if (in_quotes)
         {
            current_element += ch;
         }
      }

      // Push the last element if it's not empty
      if (!current_element.empty())
      {
         result.push_back(current_element);
      }

      return result;


  - name: comma_separated_strings_to_vector_of_strings
    type: std::vector<std::string>
    static: true
    parameters:
      - name: comma_separated_strings
        type: std::string
        default_argument: '"[unset-comma_separated_strings]"'
    body: |
      // NOTE: Does not account for nested strings
      return tokenize(comma_separated_strings, ',');


  - name: str_to_playmode
    type: std::pair<bool, uint32_t>
    parameters:
      - name: playmode_string
        type: std::string
        default_argument: '"[unset-playmode_string]"'
    body: |
      if (playmode_string == "once")
      {
         return { true, AllegroFlare::FrameAnimation::Animation::PLAYMODE_FORWARD_ONCE };
      }
      else if (playmode_string == "loop")
      {
         return { true, AllegroFlare::FrameAnimation::Animation::PLAYMODE_FORWARD_LOOP };
      }
      else if (playmode_string == "ping_pong_forward")
      {
         return { true, AllegroFlare::FrameAnimation::Animation::PLAYMODE_FORWARD_PING_PONG };
      }

      return { false, 0 };


  - name: find_level
    type: AllegroFlare::AssetStudio::Asset*
    parameters:
      - name: level_identifier
        type: std::string
        default_argument: '"[unset-level_identifier]"'
    guards: [ loaded, level_exists(level_identifier) ]
    body: |
      return assets[level_identifier];


  - name: validate_key_and_return
    type: std::string
    static: true
    parameters:
      - name: extracted_row
        type: std::map<std::string, std::string>*
        default_argument: nullptr
      - name: key
        type: std::string
        default_argument: '"[unset-key]"'
    body: |
      if (extracted_row->count(key) == 0)
      {
         std::vector<std::string> valid_keys;
         for (const auto& pair : *extracted_row) valid_keys.push_back(pair.first);

         std::stringstream ss;
         ss << "[";
         for (auto &valid_key : valid_keys)
         {
            ss << "\"" << valid_key << "\", ";
         }
         ss << "]";

         AllegroFlare::Logger::throw_error(
            "Robieo::CSVToLevelLoader::validate_key_and_return",
            "key \"" + key + "\" does not exist. The following keys are present: " + ss.str() + "."
         );
      }
      return extracted_row->operator[](key);
    body_dependency_symbols:
      - AllegroFlare::Logger


  - name: create_sprite_sheet_from_individual_images
    type: AllegroFlare::FrameAnimation::SpriteSheet*
    private: true
    parameters:
      - name: individual_frame_image_filenames
        type: std::vector<std::string>
        default_argument: '{}'
      - name: cell_width
        type: int
        default_argument: 16
      - name: cell_height
        type: int
        default_argument: 16
      - name: _sprite_sheet_scale
        type: int
        default_argument: 2
    guards: [ assets_bitmap_bin, (!individual_frame_image_filenames.empty()) ]
    body: |
      // TODO: Consider caching the created result_sprite_sheet;

      std::vector<ALLEGRO_BITMAP*> bitmaps;
      for (auto &individual_frame_image_filename : individual_frame_image_filenames)
      {
         bitmaps.push_back(assets_bitmap_bin->auto_get(individual_frame_image_filename));
      }
     
      AllegroFlare::FrameAnimation::SpriteStripAssembler sprite_strip_assembler;
      sprite_strip_assembler.set_bitmaps(bitmaps);
      sprite_strip_assembler.assemble();
      ALLEGRO_BITMAP* sprite_strip = sprite_strip_assembler.get_sprite_strip();

      // Given the newly assembled sprite_strip (aka atlas), build the sprite_sheet
      AllegroFlare::FrameAnimation::SpriteSheet *result_sprite_sheet =
         new AllegroFlare::FrameAnimation::SpriteSheet(sprite_strip, cell_width, cell_height, _sprite_sheet_scale);
      result_sprite_sheet->initialize();

      // Cleanup
      al_destroy_bitmap(sprite_strip);
      // Cleanup the individual frame images in the bin here
      for (auto &individual_frame_image_filename : individual_frame_image_filenames)
      {
         // TODO: This could wierdly clobber, consider checking all the image frames do *not* already exist in the
         // bin at the beginning of the method before continuing.
         assets_bitmap_bin->destroy(individual_frame_image_filename);
      }

      return result_sprite_sheet;
    body_dependency_symbols:
       - AllegroFlare::FrameAnimation::SpriteStripAssembler


  - name: obtain_sprite_sheet
    type: AllegroFlare::FrameAnimation::SpriteSheet*
    private: true
    parameters:
      - name: filename
        type: std::string
        default_argument: '"[unset-filename]"'
      - name: cell_width
        type: int
        default_argument: 16
      - name: cell_height
        type: int
        default_argument: 16
      - name: _sprite_sheet_scale
        type: int
        default_argument: 2
    guards: [ assets_bitmap_bin ]
    body: |
      // TODO: Guard after assets_bitmap_bin is initialized

      //std::map<std::tuple<filename, int, int, int>, AllegroFlare::FrameAnimation::SpriteSheet*> cache;
      std::tuple<std::string, int, int, int> sprite_sheet_key(filename, cell_width, cell_height, _sprite_sheet_scale);
      if (sprite_sheets.find(sprite_sheet_key) == sprite_sheets.end())
      {
         // Create sprite sheet
         ALLEGRO_BITMAP* sprite_sheet_atlas = al_clone_bitmap(
               assets_bitmap_bin->auto_get(filename)
            );
         AllegroFlare::FrameAnimation::SpriteSheet *result_sprite_sheet =
            new AllegroFlare::FrameAnimation::SpriteSheet(sprite_sheet_atlas, cell_width, cell_height, _sprite_sheet_scale);
         result_sprite_sheet->initialize();

         al_destroy_bitmap(sprite_sheet_atlas);

         // Add the sprite sheet to the list of sprite sheets
         sprite_sheets[sprite_sheet_key] = result_sprite_sheet;
      }

      return sprite_sheets[sprite_sheet_key];

      //ALLEGRO_BITMAP* sprite_sheet_atlas = al_clone_bitmap(
            //assets_bitmap_bin->auto_get(filename)
            ////assets_bitmap_bin.auto_get("grotto_escape_pack/Base pack/graphics/player.png")
         //);
      //AllegroFlare::FrameAnimation::SpriteSheet *result_sprite_sheet =
         //new AllegroFlare::FrameAnimation::SpriteSheet(sprite_sheet_atlas, cell_width, cell_height, _sprite_sheet_scale);

      //al_destroy_bitmap(sprite_sheet_atlas);

      //return result_sprite_sheet;
    body_dependency_symbols:
      - AllegroFlare::FrameAnimation::SpriteSheet


  - name: build_n_frames
    type: std::vector<AllegroFlare::FrameAnimation::Frame>
    parameters:
      - name: num_frames
        type: uint32_t
        default_argument: 1
      - name: start_frame_num
        type: uint32_t
        default_argument: 0
      - name: each_frame_duration
        type: float
        default_argument: 0.08f
      - name: each_frame_align_x
        type: float
        default_argument: 0.0f
      - name: each_frame_align_y
        type: float
        default_argument: 0.0f
      - name: each_frame_align_in_container_x
        type: float
        default_argument: 0.0f
      - name: each_frame_align_in_container_y
        type: float
        default_argument: 0.0f
      - name: each_frame_anchor_x
        type: float
        default_argument: 0.0f
      - name: each_frame_anchor_y
        type: float
        default_argument: 0.0f
    guards: [ (num_frames >= 1), (start_frame_num >= 0), (each_frame_duration >= 0.0001) ]
    body: |
      std::vector<AllegroFlare::FrameAnimation::Frame> result;
      for (uint32_t i=0; i<num_frames; i++)
      {
         AllegroFlare::FrameAnimation::Frame result_frame(start_frame_num + i, each_frame_duration);
         result_frame.set_align_x(each_frame_align_x);
         result_frame.set_align_y(each_frame_align_y);
         result_frame.set_align_in_container_x(each_frame_align_in_container_x);
         result_frame.set_align_in_container_y(each_frame_align_in_container_y);
         result_frame.set_anchor_x(each_frame_anchor_x);
         result_frame.set_anchor_y(each_frame_anchor_y);
         
         //result.push_back({ start_frame_num + i, each_frame_duration });
         result.push_back(result_frame);
      }
      return result;


  - name: build_frames_from_hash
    type: std::vector<AllegroFlare::FrameAnimation::Frame>
    parameters:
      - name: frame_data_hash
        type: std::string
        default_argument: '"[unset-frame_data_hash]"'
    body: |
      AllegroFlare::Logger::throw_error(
         "AllegroFlare::AssetStudio::DatabaseCSVLoader::build_frames_from_hash",
         "This feature is not yet supported."
      );

      std::vector<AllegroFlare::FrameAnimation::Frame> result;
      // TODO: If frame animation and alignment data is incuded in the hash, parse and use it here
      return result;


  - name: load
    guards: [ (!loaded), assets_bitmap_bin ]
    body: |
      //
      // Obtain the content from the file and parse it to extractable data
      //

      if (!std::filesystem::exists(csv_full_path))
      {
         AllegroFlare::Logger::throw_error(
            "AllegroFlare::AssetStudio::DatabaseCSVLoader::load",
            "The file \"" + csv_full_path + "\" does not exist."
         );
      }
      std::string content = AllegroFlare::php::file_get_contents(csv_full_path);
      if (content.empty())
      {
         AllegroFlare::Logger::throw_error(
            "AllegroFlare::AssetStudio::DatabaseCSVLoader::load",
            "The file \"" + csv_full_path + "\" is present but appears to be empty."
         );
      }
      AllegroFlare::CSVParser csv_parser;
      csv_parser.set_raw_csv_content(content);
      csv_parser.parse();
      csv_parser.assemble_column_headers(3);

      //
      // Extract the data from the CSV into AssetStudio/Asset objects
      //

      std::set<std::string> hidden_assets;
      int first_record_row = csv_parser.get_num_header_rows();
      int row_i = first_record_row;
      for (std::map<std::string, std::string> &extracted_row : csv_parser.extract_all_rows())
      {
         std::string visibility = validate_key_and_return(&extracted_row, "visibility");
         std::string identifier = validate_key_and_return(&extracted_row, "identifier");

         // Skip over "hidden" assets
         if (visibility == "hidden")
         {
            // TODO: Report hidden assets at end of loading process
            // Store the hidden asset identifier to report at the end what assets are hidden for debugging
            hidden_assets.insert(identifier);
            continue;
         }

         //
         // Extract the data from the CSV to variables
         //

         std::string asset_pack_identifier = validate_key_and_return(&extracted_row, "asset_pack_identifier");
         std::string intra_pack_identifier = validate_key_and_return(&extracted_row, "intra_pack_identifier");
         int id = toi(validate_key_and_return(&extracted_row, "id"));
         std::string type = validate_key_and_return(&extracted_row, "type");
         int cell_width = toi(validate_key_and_return(&extracted_row, "cell_width"));
         int cell_height = toi(validate_key_and_return(&extracted_row, "cell_height"));
         std::string playmode = validate_key_and_return(&extracted_row, "playmode");
         float align_x = tof(validate_key_and_return(&extracted_row, "align_x"));
         float align_y = tof(validate_key_and_return(&extracted_row, "align_y"));
         float align_in_container_x = tof(validate_key_and_return(&extracted_row, "align_in_container_x"));
         float align_in_container_y = tof(validate_key_and_return(&extracted_row, "align_in_container_y"));
         float anchor_x = tof(validate_key_and_return(&extracted_row, "anchor_x"));
         float anchor_y = tof(validate_key_and_return(&extracted_row, "anchor_y"));
         std::string image_filename = validate_key_and_return(&extracted_row, "image_filename");
         std::string images_list_raw = validate_key_and_return(&extracted_row, "images_list");


         //
         // Load the frame data for the animation
         //
         // For animations, "frame_data" refers to the timings for each animation frame. Currently all animations
         // will have a "num_frames", "start_from_frame", "each_frame_duration".
         // Some animations may have "in_hash" which allows the user to specify different animation speeds for
         // individual frames. The "in_hash" feature is currently not supported.

         std::string frame_data__in_hash = validate_key_and_return(&extracted_row, "frame_data__in_hash");
         std::string frame_data__build_n_frames__num_frames =
            validate_key_and_return(&extracted_row, "frame_data__build_n_frames__num_frames");
         std::string frame_data__build_n_frames__start_from_frame =
            validate_key_and_return(&extracted_row, "frame_data__build_n_frames__start_from_frame");
         std::string frame_data__build_n_frames__each_frame_duration =
            validate_key_and_return(&extracted_row, "frame_data__build_n_frames__each_frame_duration");

         bool using_build_n_frames_frame_data = 
            !(
                  frame_data__build_n_frames__num_frames.empty()
               && frame_data__build_n_frames__start_from_frame.empty()
               && frame_data__build_n_frames__each_frame_duration.empty()
            );
         bool using_in_hash_frame_data = !frame_data__in_hash.empty();

         std::vector<AllegroFlare::FrameAnimation::Frame> frame_data;

         if (using_build_n_frames_frame_data && using_in_hash_frame_data)
         {
            AllegroFlare::Logger::throw_error(
               "AllegroFlare::AssetStudio::DatabaseCSVLoader::load",
               "When loading row " + std::to_string(row_i) + ", both \"build_n_frames\" and \"in_hash\" sections "
                  "contain data. Either one section or the other should be used, but not both."
            );
         }
         else if (!using_build_n_frames_frame_data && !using_in_hash_frame_data)
         {
            // NOTE: Assuming this is a tileset
            // TODO: Consider guarding with a type==tileset or something.
            AllegroFlare::Logger::warn_from(
               "AllegroFlare::AssetStudio::DatabaseCSVLoader::load",
               "When loading row " + std::to_string(row_i) + ", there is empty data in the \"frame_data__\" columns. "
                  "If this is a tilemap, please discard this message. Note that there are currently no features "
                  "implemented for tilemaps."
            );
         }
         else if (using_build_n_frames_frame_data)
         {
            frame_data = build_n_frames(
                  toi(frame_data__build_n_frames__num_frames), // TODO: Test this int
                  toi(frame_data__build_n_frames__start_from_frame), // TODO: Test this int
                  tof(frame_data__build_n_frames__each_frame_duration), // TODO: Test this float
                  align_x, // TODO: Test this float
                  align_y, // TODO: Test this float
                  align_in_container_x, // TODO: Test this float
                  align_in_container_y, // TODO: Test this float
                  anchor_x, // TODO: Test this float
                  anchor_y  // TODO: Test this float
               );
         }
         else if (using_in_hash_frame_data)
         {
            frame_data = build_frames_from_hash(frame_data__in_hash);
         }
         else
         {
            AllegroFlare::Logger::throw_error(
               "AllegroFlare::AssetStudio::DatabaseCSVLoader::load",
               "Weird error in unexpected code path."
            );
         }

         // Load the image (or images) data
         //
         // Typically, artists will provide their animations either as a collection of individual image files, or
         // a single file sprite sheet strip. In the assets.db CSV file, there are two columns "images_list"
         // and "image_filename" to represent either type of resource. Either one or the other should be present,
         // but not both (or neither).

         std::vector<std::string> images_list = {}; // NOTE: Images list is never loaded here. This feature is not
                                                    // yet supported.
         AllegroFlare::FrameAnimation::SpriteSheet* sprite_sheet = nullptr;

         if (image_filename.empty() && images_list_raw.empty())
         {
            // Both "image_filename" and "images_list" columns erroneously have data in them
            AllegroFlare::Logger::throw_error(
               "AllegroFlare::AssetStudio::DatabaseCSVLoader::load",
               "When loading row " + std::to_string(row_i) + ", there is data in both the \"images_list\" and "
                  " \"image_filename\" columns. Data should exist in either one or the other, but not both."
            );
         }
         else if (!image_filename.empty() && !images_list_raw.empty())
         {
            // Neither "image_filename" and "images_list" columns have data in them
            AllegroFlare::Logger::throw_error(
               "AllegroFlare::AssetStudio::DatabaseCSVLoader::load",
               "When loading row " + std::to_string(row_i) + ", there no data in either the \"images_list\" and "
                  " \"image_filename\" columns. Data should be present in or the other (but not both)."
            );
         }
         else if (!image_filename.empty())
         {
            // NOTE: MOST COMMON USE CASE
            // There is "image_filename" data present on this record.
            std::string full_path_to_image_file = asset_pack_identifier + "/extracted/" + image_filename;
            sprite_sheet = obtain_sprite_sheet(full_path_to_image_file, cell_width, cell_height, sprite_sheet_scale);
         }
         else if (!images_list_raw.empty())
         {
            // TODO: Handle this case:
            // TODO: Split
            //std::string full_path_to_image_file = asset_pack_identifier + "/extracted/" + image_filename;
            images_list = comma_separated_strings_to_vector_of_strings(images_list_raw);

            //std::cout << "*** images_list detected ***" << std::endl;
            //std::cout << "  - images_list.size(): " << images_list.size() << std::endl;
            //std::cout << "  - frame_data.size(): " << frame_data.size() << std::endl;
            //std::cout << "  - images_list_raw: ###" << images_list_raw << "###" << std::endl;

            if (images_list.size() != frame_data.size())
            {
               AllegroFlare::Logger::throw_error(
                  "AllegroFlare::AssetStudio::DatabaseCSVLoader::load",
                  "When processing asset \"" + identifier + "\", the number of images in "
                     "the \"images_list\" (" + std::to_string(images_list.size()) + ") was not the same as the "
                     "\"frame_data\"'s \"num_frames\" "
                     "(" + std::to_string(frame_data.size()) + ")"
               );
            }

            //AllegroFlare::Logger::warn_from(
               //"AllegroFlare::AssetStudio::DatabaseCSVLoader::load",
               //"When processing asset \"" + identifier + "\", an \"images_list\" was supplied. This feature is "
                  //"not yet implemented (you should add it in now, tho). For now, skipping this asset."
            //);

            // Build the extended path_to_image_file
            for (auto &image_list_item : images_list)
            {
               image_list_item = asset_pack_identifier + "/extracted/" + image_list_item;
            }

            sprite_sheet = create_sprite_sheet_from_individual_images(
                  images_list,
                  cell_width,
                  cell_height,
                  sprite_sheet_scale
               );
            //using_single_image_file = false;
            //continue;
              //asset_pack_identifier + "/extracted/" + image_filename;
            //AllegroFlare::Logger::throw_error(
               //"AllegroFlare::AssetStudio::DatabaseCSVLoader::load",
               //"foofoo2"
            //);
         }
         //std::string full_path_to_image_file = asset_pack_identifier + "/extracted/" + image_filename;



         // Parse the "playmode"

         std::pair<bool, uint32_t> playmode_parsed_data =
               { true, AllegroFlare::FrameAnimation::Animation::PLAYMODE_FORWARD_ONCE };

         if (!playmode.empty())
         {
            playmode_parsed_data = str_to_playmode(playmode);
         }
         //else
         //{
            //std::cout << "- identifier: \"" << identifier << "\"" << std::endl;
            //std::cout << "    playmode: \"" << playmode << "\" -> " << playmode_parsed_data.second << std::endl;
         //}

         if (playmode_parsed_data.first == false)
         {
            AllegroFlare::Logger::throw_error(
               "AllegroFlare::AssetStudio::DatabaseCSVLoader::load",
               "Unrecognized playmode \"" + playmode + "\" when loading row " + std::to_string(row_i) + "."
            );
         }


         // Build the sprite sheet
         //AllegroFlare::FrameAnimation::SpriteSheet* sprite_sheet =
            //obtain_sprite_sheet(full_path_to_image_file, cell_width, cell_height, 2);

         // Build the animation
         AllegroFlare::FrameAnimation::Animation *animation =
            new AllegroFlare::FrameAnimation::Animation(
               sprite_sheet,
               identifier,
               frame_data,
               playmode_parsed_data.second
            );
         
         // NOTE: The animation is not initialized. This is because at *use* time, the animation is copied from the
         // database into the using object's posession, at which point that animation is then initialized.

         // Load the data into the asset
         AllegroFlare::AssetStudio::Asset *asset = new AllegroFlare::AssetStudio::Asset;
         asset->id = id;
         asset->identifier = identifier;
         asset->animation = animation;
         asset->cell_width = cell_width;
         asset->cell_height = cell_height;
         // TODO: Look into if these properties should only exist in the animation's frame_data (and not the asset)
         {
            asset->align_x = align_x;
            asset->align_y = align_y;
            asset->align_in_container_x = align_in_container_x;
            asset->align_in_container_y = align_in_container_y;
            asset->anchor_x = anchor_x;
            asset->anchor_y = anchor_y;
         }
         asset->asset_pack_identifier = asset_pack_identifier;
         asset->intra_pack_identifier = intra_pack_identifier;
         asset->type = type;
         asset->image_filename = image_filename;
         asset->images_list = images_list;

         assets.insert({ asset->identifier, asset });

         // Showing loaded asset
         std::cout << "Asset \"" << asset->identifier << "\" loaded. "
                   << "Dimensions: (" << asset->cell_width << ", " << asset->cell_height << "), "
                   << "Frames: " << animation->get_num_frames() << std::endl;

         // If it's an "icon_set", then consider building unique assets for each icon
         int icon_id = 1;
         if (type == "icon_set")
         {
            std::cout << "Building \"icon_set\" for \"" << identifier << "\"" << std::endl;

            for (int i=0; i<sprite_sheet->get_num_sprites(); i++)
            {
               std::string icon_identifier = identifier + "-icon_" + std::to_string(icon_id);
               // TODO: See if icon_identifier clashes

               AllegroFlare::AssetStudio::Asset *icon_asset = new AllegroFlare::AssetStudio::Asset;
               icon_asset->id = id + i + 10000; // TODO: Figure out some way to create unique names and ids from icons
               icon_asset->identifier = icon_identifier;
               icon_asset->bitmap = sprite_sheet->get_cell(i);
               icon_asset->cell_width = cell_width;
               icon_asset->cell_height = cell_height;
               icon_asset->type = "icon";

               assets.insert({ icon_asset->identifier, icon_asset });

               icon_id++;
            }
         }
         
         //ALLEGRO_BITMAP *get_cell(int index);
         //ALLEGRO_BITMAP *get_atlas();
         //int get_num_sprites();
         
         row_i++;
      }

      loaded = true;
      return;
    body_dependency_symbols:
      - std::filesystem::exists
      - AllegroFlare::CSVParser
      - AllegroFlare::UsefulPHP
      - std::set


  - name: split
    type: std::vector<std::string>
    private: true
    static: true
    parameters:
      - name: string
        type: std::string
        default_argument: '""'
      - name: delimiter
        type: char
        default_argument: "' '"
    body: |
      std::vector<std::string> elems;
      auto result = std::back_inserter(elems);
      std::stringstream ss(string);
      std::string item;
      while (std::getline(ss, item, delimiter)) { *(result++) = item; }
      return elems;


  - name: tokenize
    private: true
    static: true
    type: std::vector<std::string>
    parameters:
      - name: str
        type: std::string
        default_argument: '""'
      - name: delim
        type: char
        default_argument: "'|'"
    body: |
      std::vector<std::string> tokens = split(str, delim);
      for (auto &token : tokens) token = trim(token);
      return tokens;


  - name: trim
    type: std::string
    private: true
    static: true
    parameters:
      - name: s
        type: std::string
        default_argument: '""'
    body: |
      // ltrim
      s.erase(s.begin(), std::find_if(s.begin(), s.end(), [](int c) {return !std::isspace(c);}));
      // rtrim
      s.erase(std::find_if(s.rbegin(), s.rend(), [](int c) {return !std::isspace(c);}).base(), s.end());
      return s;
    body_dependency_symbols:
      - std::find_if


dependencies:


  - symbol: AllegroFlare::CSVParser
    headers: [ AllegroFlare/CSVParser.hpp ]
  - symbol: AllegroFlare::UsefulPHP
    headers: [ AllegroFlare/UsefulPHP.hpp ]
  - symbol: SurviveTheCity::CSVParser
    headers: [ SurviveTheCity/CSVParser.hpp ]
  - symbol: AllegroFlare::AssetStudio::Asset
    headers: [ AllegroFlare/AssetStudio/Asset.hpp ]
  - symbol: AllegroFlare::Logger
    headers: [ AllegroFlare/Logger.hpp ]
  - symbol: std::atoi
    headers: [ cstdlib ]
  - symbol: std::stof
    headers: [ string ]
  - symbol: AllegroFlare::BitmapBin
    headers: [ AllegroFlare/BitmapBin.hpp ]
  - symbol: AllegroFlare::FrameAnimation::SpriteSheet
    headers: [ AllegroFlare/FrameAnimation/SpriteSheet.hpp ]
  - symbol: AllegroFlare::FrameAnimation::Frame
    headers: [ AllegroFlare/FrameAnimation/Frame.hpp ]
  - symbol: std::find_if
    headers: [ algorithm ]
  - symbol: AllegroFlare::FrameAnimation::SpriteStripAssembler
    headers: [ AllegroFlare/FrameAnimation/SpriteStripAssembler.hpp ]
  - symbol: std::filesystem::exists
    headers: [ filesystem ]


