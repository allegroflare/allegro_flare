parent_classes:


  - class: AllegroFlare::Screens::Base
    scope: public
    init_with: '"TitleScreen"'


properties:


  - name: event_emitter
    type: AllegroFlare::EventEmitter*
    init_with: nullptr
    constructor_arg: true
    setter: true

  - name: font_bin
    type: AllegroFlare::FontBin*
    init_with: nullptr
    constructor_arg: true
    setter: true

  - name: bitmap_bin
    type: AllegroFlare::BitmapBin*
    init_with: nullptr
    constructor_arg: true
    setter: true

  - name: title_text
    type: std::string
    init_with: '"Untitled Game"'
    constructor_arg: true
    getter: true
    setter: true

  - name: copyright_text
    type: std::string
    init_with: '"Copyright 2022"'
    constructor_arg: true
    getter: true
    setter: true

  - name: background_bitmap_name
    type: std::string
    init_with: '""'
    constructor_arg: true
    getter: true
    setter: true

  - name: title_bitmap_name
    type: std::string
    init_with: '""'
    constructor_arg: true
    getter: true
    setter: true

  - name: title_font_name
    type: std::string
    init_with: '"Inter-Medium.ttf"'
    constructor_arg: true
    getter: true
    setter: true

  - name: menu_font_name
    type: std::string
    init_with: '"Inter-Medium.ttf"'
    constructor_arg: true
    getter: true
    setter: true

  - name: copyright_font_name
    type: std::string
    init_with: '"Inter-Medium.ttf"'
    constructor_arg: true
    getter: true
    setter: true

  - name: title_text_color
    type: ALLEGRO_COLOR
    init_with: ALLEGRO_COLOR{1, 1, 1, 1}
    constructor_arg: true
    getter: true
    setter: true

  - name: menu_text_color
    type: ALLEGRO_COLOR
    init_with: ALLEGRO_COLOR{1, 1, 1, 1}
    constructor_arg: true
    getter: true
    setter: true

  - name: menu_selector_color
    type: ALLEGRO_COLOR
    init_with: ALLEGRO_COLOR{1, 1, 1, 1}
    constructor_arg: true
    getter: true
    setter: true

  - name: menu_selected_text_color
    type: ALLEGRO_COLOR
    init_with: ALLEGRO_COLOR{0, 0, 0, 1}
    constructor_arg: true
    getter: true
    setter: true

  - name: copyright_text_color
    type: ALLEGRO_COLOR
    init_with: ALLEGRO_COLOR{1, 1, 1, 1}
    constructor_arg: true
    getter: true
    setter: true

  - name: title_font_size
    type: int
    init_with: -90
    constructor_arg: true
    getter: true
    setter: true

  - name: menu_font_size
    type: int
    init_with: -48
    constructor_arg: true
    getter: true
    setter: true

  - name: copyright_font_size
    type: int
    init_with: -32
    constructor_arg: true
    getter: true
    setter: true

  - name: menu_options
    type: std::vector<std::pair<std::string, std::string>>
    init_with: 'build_default_menu_options()'
    getter: true

  - name: menu_position_x
    type: float
    init_with: 1920 / 2
    getter: true
    setter: true

  - name: menu_position_y
    type: float
    init_with: 1080 / 2
    getter: true
    setter: true

  - name: cursor_position
    type: int
    init_with: 0
    getter: true

  - name: menu_move_sound_effect_identifier
    type: std::string
    init_with: '"menu_move"'
    getter: true
    setter: true

  - name: menu_move_sound_effect_enabled
    type: bool
    init_with: true
    getter: true
    setter: true

  - name: menu_select_option_sound_effect_identifier
    type: std::string
    init_with: '"menu_select"'
    getter: true
    setter: true

  - name: menu_select_option_sound_effect_enabled
    type: bool
    init_with: true
    getter: true
    setter: true

  - name: menu_option_activated
    type: bool
    init_with: false
    getter: true

  - name: menu_option_chosen
    type: bool
    init_with: false
    getter: true

  - name: menu_option_chosen_at
    type: float
    init_with: 0.0f

  - name: menu_option_selection_activation_delay
    type: float
    init_with: 1.0f
    getter: true
    setter: true

  - name: state
    type: uint32_t
    init_with: STATE_UNDEF

  - name: state_is_busy
    type: bool
    init_with: false

  - name: state_changed_at
    type: float
    init_with: 0.0f

  - name: STATE_UNDEF
    type: uint32_t
    init_with: 0
    const: true
    static: true
    constexpr: true

  - name: STATE_REVEALING
    type: uint32_t
    init_with: 1
    const: true
    static: true
    constexpr: true

  - name: STATE_AWAITING_USER_INPUT
    type: uint32_t
    init_with: 2
    const: true
    static: true
    constexpr: true

  - name: STATE_CLOSING_DOWN
    type: uint32_t
    init_with: 3
    const: true
    static: true
    constexpr: true


functions:


  - name: TODO
    body: |
      // There is some confusing naming between "selected", "chosen", etc.  Selected seems to signify
      // either "highlighted" or "chosen" depending on the casses.
      return;


  - name: set_font_name
    parameters:
      - name: font_name
        type: std::string
        default_argument: '"[unset-font_name]"'
    body: |
      title_font_name = font_name;
      menu_font_name = font_name;
      copyright_font_name = font_name;
      return;


  - name: set_state
    parameters:
      - name: state
        type: uint32_t
        default_argument: STATE_UNDEF
      - name: override_if_busy
        type: bool
        default_argument: false
    guards: [ is_valid_state(state) ]
    body: |
      if (this->state == state) return;
      if (!override_if_busy && state_is_busy) return;
      uint32_t previous_state = this->state;

      switch (state)
      {
         case STATE_REVEALING:
         break;

         case STATE_AWAITING_USER_INPUT:
         break;

         case STATE_CLOSING_DOWN:
         break;

         default:
            throw std::runtime_error("weird error");
         break;
      }

      this->state = state;
      state_changed_at = al_get_time();

      return;


  - name: update_state
    parameters:
      - name: time_now
        type: float
        default_argument: al_get_time()
    guards: [ is_valid_state(state) ]
    body: |
      float age = infer_current_state_age(time_now);

      switch (state)
      {
         case STATE_REVEALING:
         break;

         case STATE_AWAITING_USER_INPUT:
         break;

         case STATE_CLOSING_DOWN:
         break;

         default:
            throw std::runtime_error("weird error");
         break;
      }

      return;


  - name: is_valid_state
    type: bool
    static: true
    parameters:
      - name: state
        type: uint32_t
        default_argument: STATE_UNDEF
    body: |
      std::set<uint32_t> valid_states =
      {
         STATE_REVEALING,
         STATE_AWAITING_USER_INPUT,
         STATE_CLOSING_DOWN,
      };
      return (valid_states.count(state) > 0);
    body_dependency_symbols:
      - std::set


  - name: infer_current_state_age
    type: float
    parameters:
      - name: time_now
        type: float
        default_argument: al_get_time()
    body: |
      return (time_now - state_changed_at);


  - name: on_activate
    virtual: true
    override: true
    body: |
      cursor_position = 0;
      menu_option_chosen = false;
      menu_option_activated = false;
      return;


  - name: set_menu_options
    parameters:
      - name: menu_options
        type: std::vector<std::pair<std::string, std::string>>
        default_argument: '{}'
    body: |
      this->menu_options = menu_options;
      cursor_position = 0;
      return;


  - name: move_cursor_up
    private: true
    body: |
      if (menu_is_empty()) return;
      if (menu_option_chosen) return;

      if (menu_move_sound_effect_enabled) play_menu_move_sound_effect();

      cursor_position--;
      if (cursor_position < 0) cursor_position += menu_options.size();

      return;


  - name: move_cursor_down
    private: true
    body: |
      if (menu_is_empty()) return;
      if (menu_option_chosen) return;

      if (menu_move_sound_effect_enabled) play_menu_move_sound_effect();

      cursor_position++;
      if (cursor_position >= menu_options.size()) cursor_position = cursor_position % menu_options.size();

      return;


  - name: activate_menu_option
    virtual: true
    parameters:
      - name: menu_option_name
        type: std::string
        default_argument: '"[unset-menu-option-name]"'
    body: |
      event_emitter->emit_game_event(menu_option_name);
      return;
    

  - name: select_menu_option
    private: true
    guards: [ event_emitter ]
    guards: [ (!menu_option_chosen) ]
    body: |
      if (menu_is_empty())
      {
         std::cout <<
            "[AllegroFlare::Screens::TitleScreen::select_menu_option()] error: can not select a menu item, "
            "the menu is empty."
            << std::endl;
         return;
      }

      menu_option_chosen_at = al_get_time();
      menu_option_chosen = true;

      //if (menu_select_option_sound_effect) play_menu_select_option_sound_effect();
      if (menu_select_option_sound_effect_enabled) play_menu_select_option_sound_effect();

      //std::string current_menu_option_value = infer_current_menu_option_value();
      //activate_menu_option(current_menu_option_value);

      return;
    body_dependency_symbols:
      - ALLEGRO_FLARE_EVENT_START_NEW_GAME


  - name: primary_timer_func
    virtual: true
    override: true
    body: |
      if (menu_option_chosen && !menu_option_activated)
      {
         float state_age = (al_get_time() - menu_option_chosen_at);
         if (state_age > menu_option_selection_activation_delay)
         {
            std::string current_menu_option_value = infer_current_menu_option_value();
            activate_menu_option(current_menu_option_value);
            menu_option_activated = true;
         }
      }

      render();
      return;


  - name: render
    guards: [ al_is_system_installed(), al_is_primitives_addon_initialized(), al_is_font_addon_initialized() ]
    body: |
      //al_set_render_state(ALLEGRO_DEPTH_FUNCTION, ALLEGRO_RENDER_LESS);
      //al_set_render_state(ALLEGRO_DEPTH_FUNCTION, ALLEGRO_RENDER_LESS_EQUAL);

      draw_background();
      draw_title();
      draw_copyright_text();
      draw_menu();
      return;


  - name: draw_background
    body: |
      if (background_bitmap_name.empty()) return;
      ALLEGRO_BITMAP *background = obtain_background_bitmap();
      if (!background) return;

      al_draw_scaled_bitmap(background,
         0, 0, al_get_bitmap_width(background), al_get_bitmap_height(background),
         0, 0, 1920, 1080, 0);

      return;


  - name: draw_title
    body: |
      if (!title_bitmap_name.empty())
      {
         ALLEGRO_BITMAP *title_bitmap = obtain_title_bitmap();
         if (title_bitmap)
         {
            AllegroFlare::Placement2D place;
            place.position.x = 1920 / 2;
            place.position.y = 1080 / 3;
            place.size.x = al_get_bitmap_width(title_bitmap);
            place.size.y = al_get_bitmap_height(title_bitmap);
            place.start_transform();
            al_draw_bitmap(title_bitmap, 0, 0, 0);
            place.restore_transform();
         }
      }
      else if (!title_text.empty())
      {
         // TODO: review guards on this function
         ALLEGRO_FONT *title_font = obtain_title_font();
         int surface_width = 1920;
         int surface_height = 1080;
         al_draw_text(
            title_font,
            title_text_color, //ALLEGRO_COLOR{1, 1, 1, 1},
            surface_width / 2,
            surface_height / 3,
            ALLEGRO_ALIGN_CENTER,
            get_title_text().c_str()
         );
      }
      return;
    body_dependency_symbols:
      - AllegroFlare::Placement2D


  - name: draw_copyright_text
    body: |
      // TODO: review guards on this function
      ALLEGRO_FONT *copyright_font = obtain_copyright_font();
      int surface_width = 1920;
      int surface_height = 1080;
      float line_height = al_get_font_line_height(copyright_font);

      int number_of_lines = 1;
      for (int i = 0; i < copyright_text.size(); i++) if (copyright_text[i] == '\n') number_of_lines++;

      al_draw_multiline_text(
         copyright_font,
         copyright_text_color,
         surface_width/2,
         surface_height - 80 - (int)(number_of_lines * line_height / 2),
         surface_width,
         line_height,
         ALLEGRO_ALIGN_CENTER,
         get_copyright_text().c_str()
      );
      return;


  - name: draw_menu
    guards: [ al_is_primitives_addon_initialized() ]
    body: |
      // TODO: review guards on this function
      ALLEGRO_FONT *menu_font = obtain_menu_font();
      int surface_width = 1920;
      int surface_height = 1080;
      float h_font_line_height = (int)(al_get_font_line_height(menu_font) * 0.5f);
      float menu_item_vertical_spacing = (int)(al_get_font_line_height(menu_font) * 1.25f);
      float h_menu_item_vertical_spacing = (int)(al_get_font_line_height(menu_font) * 1.25f);
      int menu_item_num = 0;

      // get longest menu option text length
      int longest_menu_option_text_width = 0;
      for (auto &menu_option : menu_options)
      {
         std::string menu_item_text = std::get<0>(menu_option);
         int this_menu_item_text_width = al_get_text_width(menu_font, menu_item_text.c_str());
         if (this_menu_item_text_width > longest_menu_option_text_width)
            longest_menu_option_text_width = this_menu_item_text_width;
      }

      // render each menu item
      for (auto &menu_option : menu_options)
      {
         bool showing_cursor_on_this_option = false;
         if (menu_item_num == cursor_position) showing_cursor_on_this_option = true;
         std::string menu_item_text = std::get<0>(menu_option);

         ALLEGRO_COLOR this_menu_text_color = showing_cursor_on_this_option
            ? menu_selected_text_color : menu_text_color;

         float x = menu_position_x;
         float y = menu_position_y + menu_item_vertical_spacing * menu_item_num;

         if (showing_cursor_on_this_option)
         {
            float box_width = longest_menu_option_text_width + 148;
            float box_height = al_get_font_line_height(menu_font) + 6;
            float h_box_width = box_width * 0.5;
            float h_box_height = box_height * 0.5;
            al_draw_filled_rectangle(x-h_box_width, y-h_box_height, x+h_box_width, y+h_box_height, menu_selector_color);
         }

         al_draw_text(
            menu_font,
            this_menu_text_color,
            (int)x,
            (int)(y-h_font_line_height),
            ALLEGRO_ALIGN_CENTER,
            menu_item_text.c_str()
         );

         menu_item_num++;
      }
      return;
    body_dependency_symbols:
      - al_draw_filled_rectangle
      - al_is_primitives_addon_initialized


  - name: infer_current_menu_option_value
    private: true
    type: std::string
    body: |
      if (menu_options.empty()) return "";
      if (cursor_position < 0 || cursor_position >= menu_options.size())
      {
         throw std::runtime_error("[AllegroFlare/Screens/TitleScreen]: error: cursor_position is not in "
                                  "a valid position to get the current menu choice's value.");
      }
      std::string current_menu_option_value = std::get<1>(menu_options[cursor_position]);
      return current_menu_option_value;


  - name: infer_current_menu_option_label
    private: true
    type: std::string
    body: |
      if (menu_options.empty()) return "";
      if (cursor_position < 0 || cursor_position >= menu_options.size())
      {
         throw std::runtime_error("[AllegroFlare/Screens/TitleScreen]: error: cursor_position is not in "
                                  "a valid position to get the current menu choice's label.");
      }
      std::string current_menu_option_value = std::get<1>(menu_options[cursor_position]);
      return current_menu_option_value;


  - name: play_menu_move_sound_effect
    body: |
      event_emitter->emit_play_sound_effect_event(menu_move_sound_effect_identifier);
      return;


  - name: play_menu_select_option_sound_effect
    body: |
      event_emitter->emit_play_sound_effect_event(menu_select_option_sound_effect_identifier);
      return;


  - name: obtain_title_font
    private: true
    type: ALLEGRO_FONT*
    guards: [ font_bin ]
    body: |
      std::stringstream composite_font_str;
      composite_font_str << title_font_name << " " << title_font_size;
      return font_bin->auto_get(composite_font_str.str());


  - name: obtain_menu_font
    private: true
    type: ALLEGRO_FONT*
    guards: [ font_bin ]
    body: |
      std::stringstream composite_font_str;
      composite_font_str << menu_font_name << " " << menu_font_size;
      return font_bin->auto_get(composite_font_str.str());


  - name: obtain_copyright_font
    private: true
    type: ALLEGRO_FONT*
    guards: [ font_bin ]
    body: |
      std::stringstream composite_font_str;
      composite_font_str << copyright_font_name << " " << copyright_font_size;
      return font_bin->auto_get(composite_font_str.str());


  - name: obtain_background_bitmap
    private: true
    type: ALLEGRO_BITMAP*
    guards: [ bitmap_bin ]
    body: |
      return bitmap_bin->auto_get(background_bitmap_name);


  - name: obtain_title_bitmap
    private: true
    type: ALLEGRO_BITMAP*
    guards: [ bitmap_bin ]
    body: |
      return bitmap_bin->auto_get(title_bitmap_name);


  - name: virtual_control_button_down_func
    virtual: true
    override: true
    parameters:
      - name: player_num
        type: int
        default_argument: 0
      - name: button_num
        type: int
        default_argument: 0
      - name: is_repeat
        type: bool
        default_argument: 'false'
    body: |
      if (menu_option_chosen) return;

      if (button_num == VirtualControls::BUTTON_UP) move_cursor_up();
      if (button_num == VirtualControls::BUTTON_DOWN) move_cursor_down();
      if (button_num == VirtualControls::BUTTON_A
         || button_num == VirtualControls::BUTTON_START
         )
      {
         select_menu_option();
      }
    body_dependency_symbols:
      - AllegroFlare::VirtualControls


  - name: menu_is_empty
    type: bool
    private: true
    body: |
      return menu_options.empty();


  - name: menu_has_items
    type: bool
    private: true
    body: |
      return !menu_is_empty();


  - name: build_default_menu_options
    type: std::vector<std::pair<std::string, std::string>>
    static: true
    body: |
      std::vector<std::pair<std::string, std::string>> result;
      result = { { "Start new game", "start_new_game" }, { "Credits", "show_credits" }, { "Exit", "exit_game" } };
      return result;


dependencies:

  - symbol: ALLEGRO_EVENT*
    headers: [ allegro5/allegro.h ]
  - symbol: ALLEGRO_FLARE_EVENT_START_NEW_GAME
    headers: [ AllegroFlare/EventNames.hpp ]
  - symbol: AllegroFlare::EventEmitter*
    headers: [ AllegroFlare/EventEmitter.hpp ]
  - symbol: std::vector<std::pair<std::string, std::string>>
    headers: [ vector, utility, string ]
  - symbol: AllegroFlare::Screens::Base
    headers: [ AllegroFlare/Screens/Base.hpp ]
  - symbol: AllegroFlare::FontBin*
    headers: [ AllegroFlare/FontBin.hpp ]
  - symbol: AllegroFlare::BitmapBin*
    headers: [ AllegroFlare/BitmapBin.hpp ]
  - symbol: ALLEGRO_BITMAP*
    headers: [ allegro5/allegro.h ]
  - symbol: ALLEGRO_FONT*
    headers: [ allegro5/allegro_font.h ]
  - symbol: ALLEGRO_COLOR
    headers: [ allegro5/allegro.h ]
  - symbol: AllegroFlare::Placement2D
    headers: [ AllegroFlare/Placement2D.hpp ]
  - symbol: AllegroFlare::VirtualControls
    headers: [ AllegroFlare/VirtualControls.hpp ]
  - symbol: al_draw_filled_rectangle
    headers: [ allegro5/allegro_primitives.h ]
  - symbol: al_is_primitives_addon_initialized
    headers: [ allegro5/allegro_primitives.h ]

  - symbol: ALLEGRO_BITMAP
    headers: [ allegro5/allegro.h ]
  - symbol: ALLEGRO_FONT
    headers: [ allegro5/allegro_font.h ]
  - symbol: AllegroFlare::FontBin
    headers: [ AllegroFlare/FontBin.hpp ]
  - symbol: AllegroFlare::BitmapBin
    headers: [ AllegroFlare/BitmapBin.hpp ]
  - symbol: AllegroFlare::EventEmitter
    headers: [ AllegroFlare/EventEmitter.hpp ]


